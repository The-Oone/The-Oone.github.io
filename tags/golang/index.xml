<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on 踩坑记录</title><link>https://the-oone.github.io/tags/golang/</link><description>Recent content in Golang on 踩坑记录</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Ting</copyright><lastBuildDate>Wed, 15 Jan 2025 13:12:33 +0800</lastBuildDate><atom:link href="https://the-oone.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Slice</title><link>https://the-oone.github.io/p/slice/</link><pubDate>Wed, 15 Jan 2025 13:12:33 +0800</pubDate><guid>https://the-oone.github.io/p/slice/</guid><description>&lt;h2 id="什么是-slice">什么是 Slice
&lt;/h2>&lt;p>切片是基于数组实现的，底层是数组，可以理解为对底层数组的抽象&lt;/p>
&lt;h3 id="数据结构">数据结构
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">slice&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">array&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span> &lt;span class="c1">// 指向底层数组的指针，占 8 字节
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">len&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="c1">// 切片长度，占 8 字节
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">cap&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="c1">// 切片容量，占 8 字节
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="初始化">初始化
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 直接声明
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">s1&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 使用字面量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">s2&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 使用 make
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">s3&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 指定长度为1.容量为4
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">s4&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 指定长度为 1，容量默认为1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 从其他切片或数组中截取
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">arr&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s5&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>基于切片和数组创建的切片会和原数组或切片共享底层空间，修改切片会影响原数组或切片&lt;/strong>&lt;/p>
&lt;h3 id="扩容">扩容
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 追加元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// [1 2]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 追加切片
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// [1 2 3 4]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>V1.18 版本之前
&lt;ul>
&lt;li>如果所需容量大于原容量的二倍，则新容量为所需容量。&lt;/li>
&lt;li>如果原slice容量小于1024，则新slice容量将扩大为原来的二倍。&lt;/li>
&lt;li>如果原slice容量大于或等于1024，则新slice容量将扩大为原来的1.25倍。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>V1.18 版本
&lt;ul>
&lt;li>如果所需容量大于原容量的二倍，则新容量为所需容量。&lt;/li>
&lt;li>如果原slice容量小于256，则新slice容量将扩大为原来的二倍。&lt;/li>
&lt;li>如果原容量大于或等于256，进入一个循环，每次容量增加（旧容量 + 3 * threshold）/ 4 。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>而每次扩容后，切片将会开辟一块新的空间，将原切片中的数据拷贝到新地址中，而原先的那片空间就会被抛弃（仅限于没有其他指针指向原先的老空间）&lt;/p>
&lt;h2 id="array-和-slice-的区别">Array 和 Slice 的区别
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>数组是固定长度，其大小在定义阶段就必须确定，函数传递中数组传递值。它的物理空间连续，性能相对较高，适合存储已知数量元素的场景。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>切片是动态的序列，其是一个引用类型，指向了底层数组，大小可变，函数传递中传递引用。性能较低，但是灵活性高，适合数量未知或者频繁需要增删的场景&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="slice-线程安全嘛">Slice 线程安全嘛
&lt;/h2>&lt;p>slice 底层结构并没有使用加锁等方式，不支持并发读写，所以&lt;strong>并不是线程安全&lt;/strong>的，使用多个 goroutine 对类型为 slice 的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; &lt;strong>slice在并发执行中不会报错，但是数据会丢失&lt;/strong>&lt;/p>
&lt;h2 id="slice-深拷贝和浅拷贝">Slice 深拷贝和浅拷贝
&lt;/h2>&lt;h3 id="深拷贝">深拷贝
&lt;/h3>&lt;p>拷贝的是数据本身，创造一个新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s1&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s2&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;s1: %v, %p\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// s1: [1 2 3 4 5], 0xc00000e420
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nb">copy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;s2: %v, %p\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// s2: [1 2 3 4 5], 0xc00000e450
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">s3&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">v&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">s1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s3&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">v&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;s3: %v, %p\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// s3: [1 2 3 4 5], 0xc00000e480
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="浅拷贝">浅拷贝
&lt;/h3>&lt;p>拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s1&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;s1: %v, %p\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// s1: [1 2 3 4 5], 0xc00000e420
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">s2&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;s2: %v, %p\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// s2: [1 2 3 4 5], 0xc00000e420
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="nil-slice-和-空slilce">nil slice 和 空slilce
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>nil slice 表示未初始化的切片，不分配任何内存，其值为 nil&lt;/p>
&lt;/li>
&lt;li>
&lt;p>空 slice 表示已初始化但长度为零，分配内存&lt;/p>
&lt;/li>
&lt;li>
&lt;p>二者并不相等，但是对这两个都可以进行 append 操作&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="c1">// nil slice
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">b&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{}&lt;/span> &lt;span class="c1">// empty slice
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// false
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">// 0 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">// 0 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// a现在是包含一个元素的切片 [1]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">// [1] 1 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">b&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// b现在也是包含一个元素的切片 [1]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">// [1] 1 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul></description></item><item><title>垃圾回收 GC</title><link>https://the-oone.github.io/p/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-gc/</link><pubDate>Tue, 14 Jan 2025 13:19:36 +0800</pubDate><guid>https://the-oone.github.io/p/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-gc/</guid><description>&lt;h2 id="什么是-gc">什么是 GC
&lt;/h2>&lt;p>垃圾回收（Garbage Collection，GC）是一种自动内存管理机制。&lt;/p>
&lt;p>现代高级编程语言管理内存有两种方式：&lt;/p>
&lt;ul>
&lt;li>手动：C/C++，Rust等，需要主动申请或者释放内存&lt;/li>
&lt;li>自动：Java，Golang等，有内存分配器和垃圾收集器自动分配和回收内存&lt;/li>
&lt;/ul>
&lt;p>程序中会使用两种内存：&lt;/p>
&lt;ul>
&lt;li>堆内存：程序共享的内存，由 GC 进行回收&lt;/li>
&lt;li>栈内存：线程专用的内存，存储函数的参数值、局部变量等，由操作系统自动分配释放&lt;/li>
&lt;/ul>
&lt;h2 id="go-的垃圾回收">Go 的垃圾回收
&lt;/h2>&lt;h3 id="gc-相关术语">GC 相关术语
&lt;/h3>&lt;ul>
&lt;li>STW：全称 stop the word，GC 期间某个阶段会停止所有的赋值器，中断程序逻辑，以确定引用关系。&lt;/li>
&lt;li>root 对象：根对象是指赋值器不需要通过其他对象就可以直接访问到的对象&lt;/li>
&lt;/ul>
&lt;h3 id="gc-v13">GC V1.3
&lt;/h3>&lt;p>1.3 版本 Go 使用&lt;strong>标记-清除&lt;/strong>作为垃圾回收算法：&lt;/p>
&lt;ol>
&lt;li>开启STW，停止程序的运行&lt;/li>
&lt;li>从根节点遍历，标记找出的所有可达对象&lt;/li>
&lt;li>清理未标记的对象&lt;/li>
&lt;li>继续运行程序&lt;/li>
&lt;/ol>
&lt;p>重复循环上述 1-4 步，直到 process 程序生命周期结束。标记清除法的&lt;strong>最大弊端就是在整个GC期间需要STW&lt;/strong>，将整个程序暂停。因为如果不进行STW的话，会出现已经被标记的对象A，引用了新的未被标记的对象B，但由于对象A已经标记过了，不会再重新扫描A对B的可达性，从而将B对象当做垃圾回收掉。&lt;/p>
&lt;h3 id="gc-v15">GC V1.5
&lt;/h3>&lt;p>1.5 版本使用&lt;strong>标记-清除算法，结合三色标记，插入写屏障&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>创建白、灰、黑三个集合&lt;/li>
&lt;li>将所有对象先放入白色集合中&lt;/li>
&lt;li>遍历所有 root 对象，把遍历到的对象从白色集合放入灰色集合（这里放入灰色集合的都是根节点直接可达的对象）&lt;/li>
&lt;li>遍历灰色集合，将灰色对象直接可达的对象从白色集合放入灰色集合，自身标记为黑色&lt;/li>
&lt;li>重复第四步，直至灰色集合中没有任何对象&lt;/li>
&lt;li>回收白色集合内的所有对象&lt;/li>
&lt;/ol>
&lt;p>对于上述的算法来讲,仍然需要依赖STW的。因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。&lt;/p>
&lt;p>在三色标记法过程中对象丢失需要同时满足两个条件：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>条件一&lt;/strong>：白色对象被黑色对象引用&lt;/li>
&lt;li>&lt;strong>条件二&lt;/strong>：灰色对象和白色对象之间的可达关系遭到破坏&lt;/li>
&lt;/ul>
&lt;p>Go 团队提出两个解决方案&lt;/p>
&lt;ul>
&lt;li>&lt;strong>强三色不变式&lt;/strong>：不允许黑色对象引用白色对象，破坏条件一&lt;/li>
&lt;li>&lt;strong>弱三色不变式&lt;/strong>：黑色对象可以引用白色对象，但是白色对象的上游必须存在灰色对象，破坏条件二&lt;/li>
&lt;/ul>
&lt;p>Go 团队基于上述不变式提出两种实现机制：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>插入写屏障&lt;/strong>（满足强三色不变式）
&lt;ul>
&lt;li>规则：当一个对象引用另一个对象时，将另一个对象标记为灰色&lt;/li>
&lt;li>劣势：无法管理栈操作，需要 STW 重新扫描栈&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>删除写屏障&lt;/strong>（满足弱三色不变式）
&lt;ul>
&lt;li>规则：在删除引用时，如果被删除引用的对象自身为灰色或者白色，那么会标记为灰色&lt;/li>
&lt;li>劣势：冗余扫描成本高，回收精度低&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="gc-v18">GC V1.8
&lt;/h3>&lt;p>1.8 版本使用&lt;strong>标记-清除算法，结合三色标记法和混合写屏障&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>GC 开始将栈上的所有可达对象均标记为黑色&lt;/li>
&lt;li>GC 期间，任何在栈上创建的新对象，均为黑色&lt;/li>
&lt;li>堆上被删除对象标记为灰色&lt;/li>
&lt;li>堆上被添加的对象标记为灰色&lt;/li>
&lt;/ol>
&lt;h2 id="gc-的触发时间">GC 的触发时间
&lt;/h2>&lt;ul>
&lt;li>主动触发：调用 &lt;code>runtime.GC()&lt;/code> 方法&lt;/li>
&lt;li>被动触发：
&lt;ul>
&lt;li>定时触发，该触发条件由 &lt;code>runtime.forcegcperiod&lt;/code> 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，触发 GC&lt;/li>
&lt;li>根据内存分配阈值触发，该触发条件由环境变量 GOGC 控制，默认值为100（100%），当前堆内存占用是上次 GC 结束后占用内存的 2 倍时，触发 GC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="gc-调优">GC 调优
&lt;/h2>&lt;ul>
&lt;li>控制内存分配的速度，限制&lt;code>Goroutine&lt;/code>的数量，提高赋值器&lt;code>mutator&lt;/code>的CPU利用率(降低GC的CPU利用率)&lt;/li>
&lt;li>少量使用&lt;code>+&lt;/code>连接&lt;code>string&lt;/code>&lt;/li>
&lt;li>&lt;code>slice&lt;/code>提前分配足够的内存来降低扩容带来的拷贝&lt;/li>
&lt;li>避免&lt;code>map key&lt;/code>对象过多，导致扫描时间增加&lt;/li>
&lt;li>变量复用，减少对象分配，例如使用&lt;code>sync.Pool&lt;/code>来复用需要频繁创建临时对象，使用全局变量&lt;/li>
&lt;li>增大&lt;code>GOGC&lt;/code>的值，降低GC的运行频率&lt;/li>
&lt;/ul></description></item><item><title>GMP 调度模型</title><link>https://the-oone.github.io/p/gmp-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 13 Jan 2025 14:46:19 +0800</pubDate><guid>https://the-oone.github.io/p/gmp-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h2 id="历史背景">历史背景
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">&lt;/th>
&lt;th style="text-align: center">含义&lt;/th>
&lt;th style="text-align: center">缺点&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">进程时代&lt;/td>
&lt;td style="text-align: center">一个程序就是一个进程，所有进程严格按照时间执行&lt;/td>
&lt;td style="text-align: center">进程阻塞十分损耗性能、只能串行执行任务&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">线程时代&lt;/td>
&lt;td style="text-align: center">一个进程阻塞，可以切换到其他进程&lt;/td>
&lt;td style="text-align: center">上下文切换成本高、协程内存占用较高&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">协程时代&lt;/td>
&lt;td style="text-align: center">协程绑定线程，CPU 调度线程执行&lt;/td>
&lt;td style="text-align: center">实现复杂，协程和线程的绑定依赖调度器算法&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="gmp-调度模型是什么">GMP 调度模型是什么
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131539627.png"
loading="lazy"
alt="image-20250113153916514"
>&lt;/p>
&lt;p>G：&lt;em>Goroutine&lt;/em>，是 Go 的用户级线程，每个 go 关键字都会创建一个 Goroutine。其数量理论上只受内存大小影响。&lt;/p>
&lt;p>M：&lt;em>Machine&lt;/em>，Go 对&lt;strong>操作系统线程&lt;/strong>的封装，M在绑定有效的 P 后，进入一个调度循环，而调度循环的机制大致是从 P 的本地运行队列以及全局队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。&lt;strong>M的数量有限制，默认数量限制是 10000&lt;/strong>，可以通过 debug.SetMaxThreads() 方法进行设置，如果有M空闲，那么就会回收或者睡眠。&lt;/p>
&lt;p>P：&lt;em>Processor&lt;/em>，&lt;strong>虚拟处理器，M执行G所需要的资源和上下文，只有将 P 和 M 绑定，才能让 P 的 runq 中的 G 真正运行起来&lt;/strong>。P的数量受本机的CPU核数影响，可通过环境变量$GOMAXPROCS或在runtime.GOMAXPROCS()来设置，默认为CPU核心数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//src/runtime/runtime2.go
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">g&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">goid&lt;/span> &lt;span class="kt">int64&lt;/span> &lt;span class="c1">// 唯一的goroutine的ID
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">sched&lt;/span> &lt;span class="nx">gobuf&lt;/span> &lt;span class="c1">// goroutine切换时，用于保存g的上下文
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">stack&lt;/span> &lt;span class="nx">stack&lt;/span> &lt;span class="c1">// 栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gopc&lt;/span> &lt;span class="c1">// pc of go statement that created this goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">startpc&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// pc of goroutine function
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">lock&lt;/span> &lt;span class="nx">mutex&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">id&lt;/span> &lt;span class="kt">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">status&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// one of pidle/prunning/...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Queue of runnable goroutines. Accessed without lock.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runqhead&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// 本地队列队头
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runqtail&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// 本地队列队尾
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runq&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">256&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">guintptr&lt;/span> &lt;span class="c1">// 本地队列，大小256的数组，数组往往会被都读入到缓存中，对缓存友好，效率较高
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runnext&lt;/span> &lt;span class="nx">guintptr&lt;/span> &lt;span class="c1">// 下一个优先执行的goroutine（一定是最后生产出来的)，为了实现局部性原理，runnext中的G永远会被最先调度执行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">m&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">g0&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 每个M都有一个自己的G0，不指向任何可执行的函数，在调度或系统调用时，M会切换到G0，使用G0的栈空间来调度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">curg&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 当前正在执行的G
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">schedt&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">runq&lt;/span> &lt;span class="nx">gQueue&lt;/span> &lt;span class="c1">// 全局队列，链表（长度无限制）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runqsize&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">// 全局队列长度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="go-调度原理">Go 调度原理
&lt;/h2>&lt;h3 id="调度对象">调度对象
&lt;/h3>&lt;ul>
&lt;li>G 的来源
&lt;ul>
&lt;li>P 的 runnext（1 个 G）&lt;/li>
&lt;li>P 的本地队列（数组，最多 256 个 G）&lt;/li>
&lt;li>全局 G 队列（链表，G 数量无限制）&lt;/li>
&lt;li>网络轮询器（存放网络调用阻塞的 G）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>P 的来源
&lt;ul>
&lt;li>全局 P 队列（数组，GOMAXPROCS个P）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>M 的来源
&lt;ul>
&lt;li>休眠线程队列（未绑定 P，长时间休眠会等待GC回收销毁）&lt;/li>
&lt;li>运行线程（绑定 P，指向 P 中的 G）&lt;/li>
&lt;li>自旋线程（绑定 P，指向 M 的 G0）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="goroutine-调度流程">Goroutine 调度流程
&lt;/h3>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131542604.png"
loading="lazy"
alt="image-20250113154209545"
>&lt;/p>
&lt;p>上图是一个完整调度流程：&lt;/p>
&lt;ol>
&lt;li>通过 go func() 创建一个 &lt;em>G&lt;/em>&lt;/li>
&lt;li>创建的 &lt;em>G&lt;/em> 优先保存到本地队列 &lt;em>P&lt;/em>，若本地 &lt;em>P&lt;/em> 已满则进去全局队列&lt;/li>
&lt;li>唤醒或者新建 &lt;em>M&lt;/em> 执行任务，进入调度循环（4，5，6)&lt;/li>
&lt;li>&lt;em>M&lt;/em> 依次会从本地队列 &lt;em>P&lt;/em>，全局队列，其他本地队列 &lt;em>P&lt;/em> 获取 &lt;em>G&lt;/em>&lt;/li>
&lt;li>&lt;em>M&lt;/em> 调度和执行 &lt;em>G&lt;/em>
&lt;ul>
&lt;li>如果 &lt;em>M&lt;/em> 在执行 &lt;em>G&lt;/em> 的过程发生&lt;strong>系统调用阻塞&lt;/strong>（同步），会阻塞 &lt;em>G&lt;/em> 和 &lt;em>M&lt;/em>（操作系统限制），此时 &lt;em>P&lt;/em> 会和当前 &lt;em>M&lt;/em> 解绑，并寻找新的 &lt;em>M&lt;/em>，如果没有空闲的 &lt;em>M&lt;/em> 就会新建一个 &lt;em>M&lt;/em> ，接管正在阻塞G所属的P，接着继续执行 P中其余的G，这种阻塞后释放P的方式称之为hand off。当&lt;strong>系统调用结束&lt;/strong>后，这个G会尝试获取一个空闲的P执行，优先获取之前绑定的P，并放入到这个P的本地队列，如果获取不到P，那么这个线程M变成休眠状态，加入到空闲线程中，然后这个G会被放入到全局队列中。&lt;/li>
&lt;li>如果M在执行G的过程发生网络IO等操作阻塞时（异步），阻塞G，&lt;strong>不会阻塞M&lt;/strong>。M会寻找P中其它可执行的G继续执行，G会被网络轮询器network poller 接手，当阻塞的G恢复后，G1从network poller 被移回到P的 LRQ 中，重新进入可执行状态。异步情况下，通过调度，Go scheduler 成功地将 I/O 的任务转变成了 CPU 任务，或者说将内核级别的线程切换转变成了用户级别的 goroutine 切换，大大提高了效率。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;em>M&lt;/em> 执行完 &lt;em>G&lt;/em> 后清理现场，重新进入调度循环（将 M 上运⾏的goroutine切换为G0，G0负责调度时协程的切换）&lt;/li>
&lt;/ol>
&lt;h3 id="调度器生命周期">调度器生命周期
&lt;/h3>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501132210897.png"
loading="lazy"
alt="image-20250113221048794"
>&lt;/p>
&lt;ul>
&lt;li>M0：M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。&lt;/li>
&lt;li>G0：G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。&lt;/li>
&lt;/ul>
&lt;h3 id="调度时机">调度时机
&lt;/h3>&lt;ul>
&lt;li>抢占式调度
&lt;ul>
&lt;li>sysmon检测到协程运行过久(比如sleep，死循环)&lt;/li>
&lt;li>切换到g0，进入调度循环&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>主动调度
&lt;ul>
&lt;li>新起一个协程和协程执行完毕触发调度循环&lt;/li>
&lt;li>主动调用runtime.Gosched()切换到g0，进入调度循环&lt;/li>
&lt;li>垃圾回收之后。stw之后，会重新选择g开始执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>被动调度
&lt;ul>
&lt;li>系统调用(比如文件IO)阻塞(同步)，阻塞G和M，P与M分离，将P交给其它M绑定，其它M执行P的剩余G&lt;/li>
&lt;li>网络IO调用阻塞(异步) ，阻塞G，G移动到NetPoller，M执行P的剩余G&lt;/li>
&lt;li>atomic/mutex/channel等阻塞(异步)，阻塞G，G移动到channel的等待队列中，M执行P的剩余G&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="如何挑选下一个执行的-goroutine">如何挑选下一个执行的 Goroutine
&lt;/h3>&lt;ol>
&lt;li>每执行61次调度循环，从全局队列获取G，若有则直接返回&lt;/li>
&lt;li>从P上的runnext看一下是否有G，若有则直接返回&lt;/li>
&lt;li>从P上的本地队列看一下是否有G，若有则直接返回&lt;/li>
&lt;li>上面都没查找到时，则去全局队列、网络轮询器查找或者从其他Р中窃取,t一直阻塞直到获取到一个可用 的G为止&lt;/li>
&lt;/ol>
&lt;p>netpoller中拿到的G是 &lt;code>_Gwaiting状态&lt;/code>（存放的是因为网络IO被阻塞的G)，从其它地方拿到的是&lt;code>_Grunnable状态&lt;/code>&lt;/p>
&lt;h3 id="goroutine-的调度方式">Goroutine 的调度方式
&lt;/h3>&lt;h4 id="基于协作的抢占式调度流程12-版本实现">基于协作的抢占式调度流程（1.2 版本实现）
&lt;/h4>&lt;ol>
&lt;li>编译器会在调用函数前插入runtime.morestack，让运行时有机会在这段代码中检查是否需要执行抢占
调度&lt;/li>
&lt;li>Go语言运行时会在垃圾回收暂停程序、系统监控发现Goroutine运行超过10ms，那么会在这个协程设置
一个抢占标记&lt;/li>
&lt;li>当发生函数调用时，可能会执行编译器插入的runtime.morestack，它调用的runtime.newstack会检查抢
占标记，如果有抢占标记就会触发抢占让出cpu，切到调度主协程里&lt;/li>
&lt;/ol>
&lt;p>只能局部解决问题，只在有函数调用的地方才能插入“抢占”代码（埋点），对于没有函数调用而是纯算法循环计算的 G，Go 调度器依然无法抢占。&lt;/p>
&lt;h4 id="基于信号的抢占式调度114版本实现">基于信号的抢占式调度（1.14版本实现）
&lt;/h4>&lt;ol>
&lt;li>M注册一个SIGURG信号的处理函数:sighandler&lt;/li>
&lt;li>sysmon启动后会间隔性的进行监控，最长间隔10ms，最短间隔20us。如果发现某协程独占
P超过10ms，会给M发送抢占信号&lt;/li>
&lt;li>M收到信号后，内核执行sighandler函数把当前协程的状态从_Grunning正在执行改成_Grunnable可执
行，把抢占的协程放到全局队列里，M继续寻找其他goroutine来运行&lt;/li>
&lt;li>被抢占的G再次调度过来执行时，会继续原来的执行流&lt;/li>
&lt;/ol>
&lt;p>抢占分为&lt;code>_Prunning&lt;/code>和&lt;code>_Psyscall&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>_Psyscall&lt;/code>抢占通常是由于阻塞性系统调用引起的，比如磁盘io、cgo。&lt;/li>
&lt;li>&lt;code>_Prunning&lt;/code>抢占通常是由于一些类似死循环的计算逻辑引起的。&lt;/li>
&lt;/ul>
&lt;h2 id="work-staeling--hand-off">work staeling &amp;amp; hand off
&lt;/h2>&lt;h3 id="work-stealing-机制">work stealing 机制
&lt;/h3>&lt;p>当线程M⽆可运⾏的G时，尝试从其他M绑定的 P （每次选择的 P 不一定相同）偷取 G（当前 P 中一半的 G），减少空转，提高了线程利用率。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131639460.png"
loading="lazy"
alt="image-20250113163923392"
>&lt;/p>
&lt;h3 id="hand-off-机制">hand off 机制
&lt;/h3>&lt;p>也称为 P 分离机制，当线程 M 因为 G 进行的系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的 M 执行，也提高了线程利用率。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131646778.png"
loading="lazy"
alt="image-20250113164624713"
>&lt;/p></description></item><item><title>Goroutine</title><link>https://the-oone.github.io/p/goroutine/</link><pubDate>Sun, 12 Jan 2025 16:55:26 +0800</pubDate><guid>https://the-oone.github.io/p/goroutine/</guid><description>&lt;h2 id="为什么需要-goroutine">为什么需要 Goroutine
&lt;/h2>&lt;p>简单一句话，Goroutine 相比线程拥有更优越的开销性能。&lt;/p>
&lt;p>这里先简单介绍下进程、线程、协程：&lt;/p>
&lt;ul>
&lt;li>进程：操作系统创建、资源分配的基本单位、同一个进程内的线程会共享资源。&lt;/li>
&lt;li>线程：操作系统创建、CPU 调度的基本单位、有独立的堆栈空间&lt;/li>
&lt;li>协程：可通过用户程序创建
&lt;ul>
&lt;li>有栈协程：golang&lt;/li>
&lt;li>无栈协程：c++，rust 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Goroutine 就是一个用户级线程，相比传统线程更加轻量（传统协程 1 MB，Goroutine 约 2 KB）。其不涉及内核态的切换，因此 golang 的并发性能很好。&lt;/p>
&lt;h2 id="如何关闭-goroutine">如何关闭 Goroutine
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>关闭 channel&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 根据第二个参数进行判别，当关闭 channel 时，根据其返回结果跳出
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>定期轮询 channel&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">done&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="s">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">done&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ch&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">done&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;接收到的值：&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;over&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>变量 done 作为 channel 类型，用作信号量处理 Goroutine 的关闭。for-loop 结合 select 进行监听，处理完业务之后才会调用 close 关闭 channel。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 context&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">cancel&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WithCancel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Background&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">default&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">cancel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;over&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 context 中，可以借助 ctx.Done 获取一个只读的 channel，可用来识别当前 channel 是否已被关闭。context 对于跨 Goroutine 控制灵活，可以调动 context.WithTimeout 根据时间，或者主动调用 cancel 方法手动关闭。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="如何实现并行-goroutine">如何实现并行 Goroutine
&lt;/h2>&lt;p>通过设置最大的可同时使用的 CPU 核心数&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 设置并行 Goroutine 数量为 2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GOMAXPROCS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="为什么不能大量使用-goroutine">为什么不能大量使用 Goroutine
&lt;/h2>&lt;ul>
&lt;li>虽然 Goroutine 的初始栈（自动扩容）很小，但是大部分业务需要更多的栈空间，而频繁的扩容需要很大的成本。&lt;/li>
&lt;li>Golang 的 GMP 调度模型中的 M 和 P 是有数量限制的，大量的 Goroutine 会导致过长的调度队列，从而影响性能。&lt;/li>
&lt;li>过多的 Goroutine 还会导致频繁的 GC，影响性能。&lt;/li>
&lt;/ul>
&lt;h2 id="goroutine-a-能否停止另一个-goroutine">Goroutine A 能否停止另一个 Goroutine
&lt;/h2>&lt;p>不能。Goroutine 只有自己主动退出，不能被外界的 Goroutine 关闭。&lt;/p>
&lt;h2 id="父-goroutine-退出子-goroutine-一定会退出嘛">父 Goroutine 退出，子 Goroutine 一定会退出嘛
&lt;/h2>&lt;ul>
&lt;li>当&lt;strong>父 Goroutine 为 main&lt;/strong> 时，所有的子 Goroutine 都&lt;strong>会&lt;/strong>跟着父 Goroutine 退出&lt;/li>
&lt;li>若&lt;strong>父 Goroutine 不为 main&lt;/strong> 时，子 Goroutine &lt;strong>不会&lt;/strong>跟着父 Goroutine 退出&lt;/li>
&lt;/ul>
&lt;h2 id="goroutine-的状态流转">Goroutine 的状态流转
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501132129821.png"
loading="lazy"
alt="image-20250113212939765"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">&lt;/th>
&lt;th style="text-align: center">状态&lt;/th>
&lt;th style="text-align: center">含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">_Gidle&lt;/td>
&lt;td style="text-align: center">空闲态&lt;/td>
&lt;td style="text-align: center">G 刚刚创建，还未初始化&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Grunnable&lt;/td>
&lt;td style="text-align: center">就绪态&lt;/td>
&lt;td style="text-align: center">G 在运行队列，等待 M 取出（此时 M 有 P）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Grunning&lt;/td>
&lt;td style="text-align: center">运行态&lt;/td>
&lt;td style="text-align: center">M 正在运行 G&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Gsyscall&lt;/td>
&lt;td style="text-align: center">系统调用&lt;/td>
&lt;td style="text-align: center">M 中运行的 G 发起系统调用（此时 M 无 P）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Gwaiting&lt;/td>
&lt;td style="text-align: center">阻塞态&lt;/td>
&lt;td style="text-align: center">G 等待执行资源&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Gdead&lt;/td>
&lt;td style="text-align: center">完成态&lt;/td>
&lt;td style="text-align: center">G 已经执行完毕&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Gcopystack&lt;/td>
&lt;td style="text-align: center">复制栈&lt;/td>
&lt;td style="text-align: center">G 正获取一个新的栈空间，并将原内容复制过去&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="goroutine-泄露">Goroutine 泄露
&lt;/h2>&lt;p>Goroutine 没有被正确的关闭或管理，会导致他们在程序运行过程中无法被回收，最终导致资源浪费和潜在的性能问题&lt;/p>
&lt;h3 id="泄露原因">泄露原因
&lt;/h3>&lt;ul>
&lt;li>Goroutine 内部进行 channel/mutex 等读写操作被一直阻塞&lt;/li>
&lt;li>Goroutine 内的业务逻辑进入死循环，资源无法释放&lt;/li>
&lt;li>Goroutine 内的业务逻辑进入长时间等待，又不断新增的 Goroutine 进入等待&lt;/li>
&lt;/ul>
&lt;h3 id="泄露场景">泄露场景
&lt;/h3>&lt;ul>
&lt;li>未初始化 channel&lt;/li>
&lt;li>channel 发送未接收&lt;/li>
&lt;li>channel 接收未发送&lt;/li>
&lt;li>资源连接未关闭&lt;/li>
&lt;li>未成功解锁&lt;/li>
&lt;li>死循环&lt;/li>
&lt;li>sync.WaitGroup 使用不当&lt;/li>
&lt;/ul>
&lt;h2 id="多个协程交替打印奇偶数字">多个协程交替打印奇偶数字
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;sync&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 创建两个channel用于同步
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">even&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">odd&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 创建WaitGroup等待所有协程完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">wg&lt;/span> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">WaitGroup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 打印偶数的协程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">defer&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">even&lt;/span> &lt;span class="c1">// 等待偶数信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;偶数: %d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">odd&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span> &lt;span class="c1">// 发送奇数信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 最后一次打印完需要再消费一次even channel,避免死锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">even&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 打印奇数的协程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">defer&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;奇数: %d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">even&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span> &lt;span class="c1">// 发送偶数信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">odd&lt;/span> &lt;span class="c1">// 等待奇数信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 最后发送一次信号给偶数协程,让其能够退出
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">even&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 等待所有协程完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 关闭channel
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">even&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">odd&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item></channel></rss>