<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Go 的内存分配机制 Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。\n"><title>Go内存分配</title>
<link rel=canonical href=https://the-oone.github.io/p/go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/><link rel=stylesheet href=/scss/style.min.4c95e9eba1df99fc729adf1fbbd70932e74a1463683ffb6ede4a153a51f6c6c3.css><meta property='og:title' content="Go内存分配"><meta property='og:description' content="Go 的内存分配机制 Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。\n"><meta property='og:url' content='https://the-oone.github.io/p/go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/'><meta property='og:site_name' content='踩坑记录'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Golang'><meta property='article:published_time' content='2025-01-15T14:44:36+08:00'><meta property='article:modified_time' content='2025-01-15T14:44:36+08:00'><meta name=twitter:title content="Go内存分配"><meta name=twitter:description content="Go 的内存分配机制 Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。\n"><link rel="shortcut icon" href=/%e5%a4%aa%e9%98%b3%e7%a5%9e%e9%b8%9f.svg><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/misans@3.1.1/lib/misans-400-regular.min.css></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><div id=article-toolbar style=position:sticky;top:5px;z-index:1000><a href=/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span></a></div><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#go-的内存分配机制>Go 的内存分配机制</a><ol><li><a href=#设计思想>设计思想</a></li><li><a href=#分配组件>分配组件</a><ol><li><a href=#mspan内存管理单元>mspan：内存管理单元</a></li><li><a href=#mcache线程缓存>mcache：线程缓存</a></li><li><a href=#mcentral中心缓存>mcentral：中心缓存</a></li><li><a href=#mheap页堆>mheap：页堆</a></li><li><a href=#分配流程>分配流程</a></li></ol></li></ol></li><li><a href=#内存逃逸>内存逃逸</a><ol><li><a href=#指针逃逸>指针逃逸</a></li><li><a href=#栈空间不足>栈空间不足</a></li><li><a href=#变量大小不确定>变量大小不确定</a></li><li><a href=#interface-动态类型逃逸>interface{} 动态类型逃逸</a></li><li><a href=#闭包引用对象>闭包引用对象</a></li><li><a href=#小结>小结</a></li></ol></li><li><a href=#go-内存对齐机制>Go 内存对齐机制</a><ol><li><a href=#内存对齐>内存对齐</a></li><li><a href=#对齐系数>对齐系数</a></li><li><a href=#对齐原则>对齐原则</a></li><li><a href=#优势>优势</a></li><li><a href=#劣势>劣势</a></li></ol></li><li><a href=#make-和-new-的异同>make 和 new 的异同</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E7%BC%96%E7%A8%8B/>编程</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/>Go内存分配</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2025/01/15</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 8 分钟</time></div></footer></div></header><section class=article-content><h2 id=go-的内存分配机制>Go 的内存分配机制</h2><p>Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。</p><h3 id=设计思想>设计思想</h3><ul><li>内存分配算法采用<code>TCMalloc算法</code>，每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向加锁向全局内存池申请，减少系统调用并且避免不同线程对全局内存池的锁竞争</li><li>把内存切分的非常的细小，分为多级管理，以降低锁的粒度</li><li>回收对象内存时，并没有将其真正释放掉，只是放回预先分配的大块内存中，以便复用。只有内存闲置过多的时候，才会尝试归还部分内存给操作系统，降低整体开销</li></ul><h3 id=分配组件>分配组件</h3><p>Go 的内存管理组件主要有：<code>mspan</code>、<code>mcache</code>、<code>mcentral</code>、<code>mheap</code></p><h4 id=mspan内存管理单元>mspan：内存管理单元</h4><p>mspan是内存管理的基本单元，该结构体中包含next和 prev两个字段，它们分别指向了前一个和后一个mspan，每个mspan都管理npages个大小为8KB的页，一个span是由多个page组成的，这里的页不是操作系统中的内存页，它们是操作系统内存页的整数倍。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>mspan</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>next</span> <span class=o>*</span><span class=nx>mspan</span> <span class=c1>//后指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>prev</span> <span class=o>*</span><span class=nx>mspan</span> <span class=c1>//前指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>startAddr</span> <span class=kt>uintptr</span> <span class=c1>//管理页的起始地址，指向page
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>npages</span> <span class=kt>uintptr</span> <span class=c1>//页数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>spanclass</span> <span class=nx>spanClass</span> <span class=c1>//规格，字节数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>spanclass</span> <span class=kt>uint8</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=mcache线程缓存>mcache：线程缓存</h4><p>mcache 管理线程在本地缓存的 mspan，每个 goroutine 绑定的P都有一个 <code>mcache</code> 字段</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>mcache</span> <span class=kd>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>alloc</span> <span class=p>[</span><span class=nx>numSpanClasses</span><span class=p>]</span><span class=o>*</span><span class=nx>mspan</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>_NumSizeClasses</span><span class=p>=</span><span class=mi>68</span>
</span></span><span class=line><span class=cl><span class=nx>numSpanClassed</span><span class=p>=</span><span class=nx>_NumSizeClassed</span><span class=o>&lt;&lt;</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><p><code>mcache</code> 用 <code>Span Classes </code>作为索引管理多个用于分配的 <code>mspan</code>，它包含所有规格的 <code>mspan</code>。它是<code>_NumSizeClasses</code> 的2倍，也就是 <code>68*2=136</code>，其中 <code>*2</code> 是将spanClass分成了有指针和没有指针两种,方便与垃圾回收。对于每种规格，有2个mspan，一个mspan不包含指针，另一个mspan则包含指针。对于无指针对象的<code>mspan</code>在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。</p><p><code>mcache</code>在初始化的时候是没有任何<code>mspan</code>资源的，在使用过程中会动态地从<code>mcentral</code>申请，之后会缓存下来。当对象小于等于32KB大小时，使用<code>mcache</code>的相应规格的<code>mspan</code>进行分配。</p><h4 id=mcentral中心缓存>mcentral：中心缓存</h4><p>mcentral管理全局的mspan供所有线程使用，全局mheap变量包含central字段，每个 mcentral 结构都维护在<strong>mheap</strong>结构内</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>mcentral</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>spanclass</span> <span class=nx>spanClass</span> <span class=c1>// 指当前规格大小
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>partial</span> <span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=nx>spanSet</span> <span class=c1>// 有空闲object的mspan列表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>full</span>    <span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=nx>spanSet</span> <span class=c1>// 没有空闲object的mspan列表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>每个mcentral管理一种spanClass的mspan，并将有空闲空间和没有空闲空间的mspan分开管理。partial和 full<code>的数据类型为</code>spanSet，表示 <code>mspans</code>集，可以通过pop、push来获得mspans</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>spanSet</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>spineLock</span> <span class=nx>mutex</span>
</span></span><span class=line><span class=cl>    <span class=nx>spine</span>     <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 指向[]span的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>spineLen</span>  <span class=kt>uintptr</span>        <span class=c1>// Spine array length, accessed atomically
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>spineCap</span>  <span class=kt>uintptr</span>        <span class=c1>// Spine array cap, accessed under lock
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>index</span> <span class=nx>headTailIndex</span>  <span class=c1>// 前32位是头指针，后32位是尾指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>简单说下<code>mcache</code>从<code>mcentral</code>获取和归还<code>mspan</code>的流程：</p><ul><li>获取； 加锁，从<code>partial</code>链表找到一个可用的<code>mspan</code>；并将其从<code>partial</code>链表删除；将取出的<code>mspan</code>加入到<code>full</code>链表；将<code>mspan</code>返回给工作线程，解锁。</li><li>归还； 加锁，将<code>mspan</code>从<code>full</code>链表删除；将<code>mspan</code>加入到<code>partial</code>链表，解锁。</li></ul><h4 id=mheap页堆>mheap：页堆</h4><p>mheap管理Go的所有动态分配内存，可以认为是Go程序持有的整个堆空间，全局唯一</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>mheap_</span> <span class=nx>mheap</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>mheap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>lock</span>      <span class=nx>mutex</span>    <span class=c1>// 全局锁
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>pages</span>     <span class=nx>pageAlloc</span> <span class=c1>// 页面分配的数据结构
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>allspans</span> <span class=p>[]</span><span class=o>*</span><span class=nx>mspan</span> <span class=c1>// 所有通过 mheap_ 申请的mspans
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 堆
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>arenas</span> <span class=p>[</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=nx>arenaL1Bits</span><span class=p>]</span><span class=o>*</span><span class=p>[</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=nx>arenaL2Bits</span><span class=p>]</span><span class=o>*</span><span class=nx>heapArena</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=c1>// 所有中心缓存mcentral
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>central</span> <span class=p>[</span><span class=nx>numSpanClasses</span><span class=p>]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>mcentral</span> <span class=nx>mcentral</span>
</span></span><span class=line><span class=cl>        <span class=nx>pad</span>      <span class=p>[</span><span class=nx>cpu</span><span class=p>.</span><span class=nx>CacheLinePadSize</span> <span class=o>-</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>mcentral</span><span class=p>{})</span><span class=o>%</span><span class=nx>cpu</span><span class=p>.</span><span class=nx>CacheLinePadSize</span><span class=p>]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>所有<code>mcentral</code>的集合则是存放于<code>mheap</code>中的。<code>mheap</code>里的<code>arena</code> 区域是堆内存的抽象，运行时会将 <code>8KB</code> 看做一页，这些内存页中存储了所有在堆上初始化的对象。运行时使用二维的 runtime.heapArena 数组管理所有的内存，每个 runtime.heapArena 都会管理 64MB 的内存。</p><p>当申请内存时，依次经过 <code>mcache</code> 和 <code>mcentral</code> 都没有可用合适规格的大小内存，这时候会向 <code>mheap</code> 申请一块内存。然后按指定规格划分为一些列表，并将其添加到相同规格大小的 <code>mcentral</code> 的 <code>非空闲列表</code> 后面</p><h4 id=分配流程>分配流程</h4><p><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501151526696.png loading=lazy alt=image-20250115152613550></p><ul><li>首先通过计算使用的大小规格</li><li>然后使用<code>mcache</code>中对应大小规格的块分配。</li><li>如果<code>mcentral</code>中没有可用的块，则向<code>mheap</code>申请，并根据算法找到最合适的<code>mspan</code>。</li><li>如果申请到的<code>mspan</code> 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。</li><li>如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）</li></ul><h2 id=内存逃逸>内存逃逸</h2><p>内存逃逸指的是在函数内部分配的变量在函数结束后仍然被其他部分引用，导致其生命周期延长到函数外部。这种情况下，变量将不再局限于函数栈中，而是被分配到堆上。内存逃逸会导致额外的内存分配和垃圾回收的开销，影响程序的性能。</p><h3 id=指针逃逸>指针逃逸</h3><p>在函数中创建了一个对象，返回了这个对象的指针。这种情况下，函数虽然退出了，但是因为指针的存在，对象的内存不能随着函数结束而回收，因此只能分配在堆上。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>add</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>float64</span><span class=p>)</span> <span class=o>*</span><span class=kt>float64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这段代码中 <code>res</code> 变量发生了逃逸。使用 <code>go build -gcflags=-m</code> 指令可以看到：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># command-line-arguments</span>
</span></span><span class=line><span class=cl>./test6.go:3:6: can inline add
</span></span><span class=line><span class=cl>./test6.go:8:6: can inline main
</span></span><span class=line><span class=cl>./test6.go:9:5: inlining call to add
</span></span><span class=line><span class=cl>./test6.go:4:2: moved to heap: res
</span></span></code></pre></td></tr></table></div></div><h3 id=栈空间不足>栈空间不足</h3><p>当栈空间足够时，不会发生逃逸，但是当变量过大时，已经完全超过栈空间的大小时，将会发生逃逸到堆上分配内存。局部变量s占用内存过大，编译器会将其分配到堆上</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>nums</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>8192</span><span class=p>)</span>  <span class=c1>// 64KB
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>8191</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Int</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>nums</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>8193</span><span class=p>)</span> <span class=c1>// 64KB + 8B
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>8192</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Int</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>f1</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>f2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>上述代码中，<code>f1</code> 函数发生未内存逃逸，<code>f2</code> 函数发生内存逃逸。（博主环境为 Windows 10，Go 1.23.0）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=err>#</span> <span class=nx>command</span><span class=o>-</span><span class=nx>line</span><span class=o>-</span><span class=nx>arguments</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=o>/</span><span class=nx>test7</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>8</span><span class=p>:</span><span class=mi>14</span><span class=p>:</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>8192</span><span class=p>)</span> <span class=nx>does</span> <span class=nx>not</span> <span class=nx>escape</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=o>/</span><span class=nx>test7</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>15</span><span class=p>:</span><span class=mi>14</span><span class=p>:</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>8193</span><span class=p>)</span> <span class=nx>escapes</span> <span class=nx>to</span> <span class=nx>heap</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=变量大小不确定>变量大小不确定</h3><p>编译期间无法确定slice的长度，这种情况为了保证内存的安全，编译器也会触发逃逸，在堆上进行分配内存。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>nums</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Int</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>f</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># command-line-arguments</span>
</span></span><span class=line><span class=cl>./test8.go:12:6: can inline main
</span></span><span class=line><span class=cl>./test8.go:6:14: make<span class=o>([]</span>int, n<span class=o>)</span> escapes to heap
</span></span></code></pre></td></tr></table></div></div><h3 id=interface-动态类型逃逸>interface{} 动态类型逃逸</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;hello world&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>hello world</code> 字符串作为实参传递给 <code>fmt.Println()</code>，但是因为 <code>fmt.Println()</code> 的参数类型定义为 <code>interface{}</code> 因此也会发生内存逃逸。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># command-line-arguments</span>
</span></span><span class=line><span class=cl>./test9.go:5:6: can inline main
</span></span><span class=line><span class=cl>./test9.go:7:13: inlining call to fmt.Println
</span></span><span class=line><span class=cl>./test9.go:7:13: ... argument does not escape
</span></span><span class=line><span class=cl>./test9.go:7:14: <span class=s2>&#34;hello world&#34;</span> escapes to heap
</span></span></code></pre></td></tr></table></div></div><h3 id=闭包引用对象>闭包引用对象</h3><p>一个函数和对其周围状态的引用捆绑在一起，这样的组合就是闭包。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>test</span><span class=p>()</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>i</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>i</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>test</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>test()</code> 返回值是一个闭包函数，该闭包函数访问外部变量 <code>n</code>，<code>n</code> 会一直存在直到 <code>test()</code> 函数被销毁。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># command-line-arguments</span>
</span></span><span class=line><span class=cl>./test10.go:3:6: can inline <span class=nb>test</span>
</span></span><span class=line><span class=cl>./test10.go:5:9: can inline test.func1
</span></span><span class=line><span class=cl>./test10.go:11:6: can inline main
</span></span><span class=line><span class=cl>./test10.go:12:6: inlining call to <span class=nb>test</span>
</span></span><span class=line><span class=cl>./test10.go:4:6: moved to heap: i
</span></span><span class=line><span class=cl>./test10.go:5:9: func literal escapes to heap
</span></span><span class=line><span class=cl>./test10.go:12:6: func literal does not escape
</span></span></code></pre></td></tr></table></div></div><h3 id=小结>小结</h3><ol><li>栈上分配内存比在堆中分配内存效率更高</li><li>栈上分配的内存不需要 GC 处理，而堆需要</li><li>逃逸分析目的是决定内分配地址是栈还是堆</li><li>逃逸分析在编译阶段完成</li></ol><p>因为无论变量的大小，只要是指针变量都会在堆上分配，所以对于小变量我们还是使用传值效率更高一点。</p><h2 id=go-内存对齐机制>Go 内存对齐机制</h2><h3 id=内存对齐>内存对齐</h3><p>为了能让CPU可以更快的存取到各个字段，Go编译器会帮你把struct结构体做数据的对齐。<strong>所谓的数据对齐，是指内存地址是所存储数据大小（按字节为单位）的整数倍，以便CPU可以一次将该数据从内存中读取出来。</strong> 编译器通过在结构体的各个字段之间填充一些空白已达到对齐的目的。</p><h3 id=对齐系数>对齐系数</h3><p>不同硬件平台占用的大小和对齐值都可能是不一样的，32位系统对齐系数是4，64位系统对齐系数是8。</p><p>不同类型的对齐系数也可能不一样，使用Go 语言中的unsafe.Alignof函数可以返回相应类型的对齐系数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;unsafe&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;bool alignof is %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>bool</span><span class=p>(</span><span class=kc>true</span><span class=p>)))</span> <span class=c1>// bool alignof is 1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;string alignof is %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=s>&#34;a&#34;</span><span class=p>)))</span> <span class=c1>// string alignof is 8
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;int8 alignof is %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>int8</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span> <span class=c1>// int8 alignof is 1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;int16 alignof is %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>int16</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span> <span class=c1>// int16 alignof is 2
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;int32 alignof is %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>int32</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span> <span class=c1>// int32 alignof is 4
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;int64 alignof is %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>int64</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span> <span class=c1>// int64 alignof is 8
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;float32 alignof is %f\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>float32</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span> <span class=c1>// float32 alignof is 4
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;float alignof is %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>float64</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span> <span class=c1>// float alignof is 8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=对齐原则>对齐原则</h3><ul><li>结构体变量中成员的偏移量必须是成员变量大小和成员对齐系数两者最小值的整数倍</li><li>整个结构体的地址必须是最大字节和编译器默认对齐系数两者最小值的整数倍（结构体的内存占用是1/4/8/16 byte&mldr;）</li><li>struct{}放在结构体中间不进行对齐，放在结构体最后一个字段则要根据最大字节和编译器默认对齐系数两者最小值来进行字段对齐</li></ul><h3 id=优势>优势</h3><ul><li><p>提高可移植性，有些<code>CPU</code>可以访问任意地址上的任意数据，而有些<code>CPU</code>只能在特定地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有平台可以移植性了</p></li><li><p>提高内存的访问效率，32位CPU下一次可以从内存中读取32位（4个字节）的数据，64位CPU下一次可以从内存中读取64位（8个字节）的数据，这个长度也称为CPU的字长。CPU一次可以读取1个字长的数据到内存中，如果所需要读取的数据正好跨了1个字长，那就得花两个CPU周期的时间去读取了。因此在内存中存放数据时进行对齐，可以提高内存访问效率。</p></li></ul><h3 id=劣势>劣势</h3><ul><li>存在内存空间的浪费</li></ul><h2 id=make-和-new-的异同>make 和 new 的异同</h2><div class=table-wrapper><table><thead><tr><th style=text-align:center>make</th><th style=text-align:center>new</th></tr></thead><tbody><tr><td style=text-align:center>make 仅用来分配及初始化类型为 slice、map、chan 的数据。</td><td style=text-align:center>new 可分配任意类型的数据，根据传入的类型申请一块内存，返回指向这块内存的指针，即类型 *Type。</td></tr><tr><td style=text-align:center>make函数返回的是slice、map、chan类型本身</td><td style=text-align:center>new函数返回一个指向该类型内存地址的指针</td></tr></tbody></table></div></section><footer class=article-footer><section class=article-tags><a href=/tags/golang/>Golang</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/map/><div class=article-details><h2 class=article-title>Map</h2></div></a></article><article><a href=/p/slice/><div class=article-details><h2 class=article-title>Slice</h2></div></a></article><article><a href=/p/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-gc/><div class=article-details><h2 class=article-title>垃圾回收 GC</h2></div></a></article><article><a href=/p/gmp-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/><div class=article-details><h2 class=article-title>GMP 调度模型</h2></div></a></article><article><a href=/p/goroutine/><div class=article-details><h2 class=article-title>Goroutine</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2024 -
2025 Ting</section><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span>
<script language=javascript>var now=new Date;function createtime(){now.setTime(now.getTime()+250);var e=new Date("2024/12/02 00:00:00");days=(now-e)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-e)/1e3/60/60-24*dnum,hnum=Math.floor(hours),String(hnum).length==1&&(hnum="0"+hnum),minutes=(now-e)/1e3/60-24*60*dnum-60*hnum,mnum=Math.floor(minutes),String(mnum).length==1&&(mnum="0"+mnum),seconds=(now-e)/1e3-24*60*60*dnum-60*60*hnum-60*mnum,snum=Math.round(seconds),String(snum).length==1&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已稳定运行"+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.29.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script src=https://npm.elemecdn.com/nprogress@0.2.0/nprogress.js crossorigin=anonymous></script><link rel=stylesheet href=https://npm.elemecdn.com/nprogress@0.2.0/nprogress.css crossorigin=anonymous><script>NProgress.start(),document.addEventListener("readystatechange",()=>{document.readyState==="interactive"&&NProgress.inc(.8),document.readyState==="complete"&&NProgress.done()})</script></body></html>