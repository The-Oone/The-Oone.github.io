<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="String String 的底层数据结构是 int 和 SDS（Simple Dynamic String），相比 C 的原生字符串，增加了以下功能\n保存二进制文件 获取字符串长度的时间复杂度是 O(1) SDS API 内存安全，保证不会造成缓冲区溢出 内部编码 int，若字符串保存的是整数值，并且可以转换为 long，那么该字符串对象的编码被设置为 int。\n"><title>Redis 数据类型</title>
<link rel=canonical href=https://the-oone.github.io/p/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/><link rel=stylesheet href=/scss/style.min.fea7f37b24070ed4f78099890d7ce015a70f2a62c12e9f518424ae6c44435698.css><meta property='og:title' content="Redis 数据类型"><meta property='og:description' content="String String 的底层数据结构是 int 和 SDS（Simple Dynamic String），相比 C 的原生字符串，增加了以下功能\n保存二进制文件 获取字符串长度的时间复杂度是 O(1) SDS API 内存安全，保证不会造成缓冲区溢出 内部编码 int，若字符串保存的是整数值，并且可以转换为 long，那么该字符串对象的编码被设置为 int。\n"><meta property='og:url' content='https://the-oone.github.io/p/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/'><meta property='og:site_name' content='踩坑记录'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Redis'><meta property='article:published_time' content='2024-12-18T21:30:01+08:00'><meta property='article:modified_time' content='2024-12-18T21:30:01+08:00'><meta name=twitter:title content="Redis 数据类型"><meta name=twitter:description content="String String 的底层数据结构是 int 和 SDS（Simple Dynamic String），相比 C 的原生字符串，增加了以下功能\n保存二进制文件 获取字符串长度的时间复杂度是 O(1) SDS API 内存安全，保证不会造成缓冲区溢出 内部编码 int，若字符串保存的是整数值，并且可以转换为 long，那么该字符串对象的编码被设置为 int。\n"><link rel="shortcut icon" href=/%e5%a4%aa%e9%98%b3%e7%a5%9e%e9%b8%9f.svg><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/misans@3.1.1/lib/misans-400-regular.min.css></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu4167475236076061507.jpeg width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>📖</span></figure><div class=site-meta><h1 class=site-name><a href=/>踩坑记录</a></h1><h2 class=site-description>一个专注于踩坑的人的记录</h2></div></header><ol class=menu-social><li><a href='https://space.bilibili.com/432574165?spm_id_from=333.1007.0.0' target=_blank title=bilibili rel=me><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" width="24" height="24" stroke-width="2"><path d="M3 10a4 4 0 014-4h10a4 4 0 014 4v6a4 4 0 01-4 4H7a4 4 0 01-4-4v-6z"/><path d="M8 3l2 3"/><path d="M16 3l-2 3"/><path d="M9 13v-2"/><path d="M15 11v2"/></svg></a></li><li><a href=https://github.com/The-Oone target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/%E5%85%B3%E4%BA%8E/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/%E9%93%BE%E6%8E%A5/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>链接</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" width="24" height="24" stroke-width="2"><path d="M14.828 14.828A4 4 0 109.172 9.172a4 4 0 005.656 5.656z"/><path d="M6.343 17.657l-1.414 1.414"/><path d="M6.343 6.343 4.929 4.929"/><path d="M17.657 6.343l1.414-1.414"/><path d="M17.657 17.657l1.414 1.414"/><path d="M4 12H2"/><path d="M12 4V2"/><path d="M20 12h2"/><path d="M12 20v2"/></svg>
<svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" width="24" height="24" stroke-width="2"><path d="M12 3c.132.0.263.0.393.0a7.5 7.5.0 007.92 12.446A9 9 0 1112 2.992z"/><path d="M17 4a2 2 0 002 2 2 2 0 00-2 2 2 2 0 00-2-2 2 2 0 002-2"/><path d="M19 11h2m-1-1v2"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#string>String</a><ol><li><a href=#内部编码>内部编码</a></li><li><a href=#常用指令>常用指令</a></li><li><a href=#应用场景>应用场景</a></li></ol></li><li><a href=#list>List</a><ol><li><a href=#内部实现>内部实现</a></li><li><a href=#常用指令-1>常用指令</a></li><li><a href=#应用场景-1>应用场景</a></li></ol></li><li><a href=#hash>Hash</a><ol><li><a href=#内部实现-1>内部实现</a></li><li><a href=#常用命令>常用命令</a></li><li><a href=#应用场景-2>应用场景</a></li></ol></li><li><a href=#set>Set</a><ol><li><a href=#内部实现-2>内部实现</a></li><li><a href=#常用命令-1>常用命令</a></li><li><a href=#应用场景-3>应用场景</a></li></ol></li><li><a href=#zset>Zset</a><ol><li><a href=#内部实现-3>内部实现</a></li><li><a href=#常用命令-2>常用命令</a></li><li><a href=#应用场景-4>应用场景</a></li></ol></li><li><a href=#bitmap>BitMap</a><ol><li><a href=#内部实现-4>内部实现</a></li><li><a href=#常用命令-3>常用命令</a></li><li><a href=#应用场景-5>应用场景</a></li></ol></li><li><a href=#hyperloglog>HyperLogLog</a><ol><li><a href=#内部实现-5>内部实现</a></li><li><a href=#常见命令>常见命令</a></li><li><a href=#应用场景-6>应用场景</a></li></ol></li><li><a href=#geo>GEO</a><ol><li><a href=#内部实现-6>内部实现</a></li><li><a href=#常用命令-4>常用命令</a></li><li><a href=#应用场景-7>应用场景</a></li></ol></li><li><a href=#stream>Stream</a><ol><li><a href=#内部实现-7>内部实现</a></li><li><a href=#常见命令-1>常见命令</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E7%BC%96%E7%A8%8B/>编程</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/>Redis 数据类型</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2024/12/18</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 14 分钟</time></div></footer></div></header><section class=article-content><h2 id=string>String</h2><p>String 的底层数据结构是 int 和 SDS（Simple Dynamic String），相比 C 的原生字符串，增加了以下功能</p><ol><li>保存二进制文件</li><li>获取字符串长度的时间复杂度是 O(1)</li><li>SDS API 内存安全，保证不会造成缓冲区溢出</li></ol><h3 id=内部编码>内部编码</h3><ol><li><p><strong>int</strong>，若字符串保存的是整数值，并且可以转换为 long，那么该字符串对象的编码被设置为 <code>int</code>。</p><p><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412182154153.png loading=lazy alt=image-20241218215412113></p></li><li><p><strong>embstr</strong>，若字符串长度小于等于 44 字节（博主测试环境为 Redis 7.4.1），那么使用 <code>embstr</code> 编码，<strong>一次内存分配</strong>。只读，修改内容需先转换 <code>raw</code> 编码。</p><p><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412182150682.png loading=lazy alt=image-20241218215051546></p></li><li><p><strong>raw</strong>，若字符串长度大于 44 字节，那么使用 <code>raw</code> 编码，<strong>两次内存分配</strong>。</p><p><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412182151676.png loading=lazy alt=image-20241218215124643></p></li></ol><h3 id=常用指令>常用指令</h3><ol><li><p><a class=link href=https://redis.io/docs/latest/commands/set/ target=_blank rel=noopener>SET</a></p><p>设置 key 为字符串值。 如果 key 已有值，无论其类型如何，都会被覆盖。 在 SET 操作成功后，之前与键值相关的任何生存时间都将被丢弃。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SET key value [NX | XX] [GET] [EX seconds | PX milliseconds |
</span></span><span class=line><span class=cl>  EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL]
</span></span></code></pre></td></tr></table></div></div><ul><li><code>EX</code> &ndash; 设置指定的过期时间，以秒（正整数）为单位。</li><li><code>PX</code> &ndash; 设置指定的过期时间，以毫秒（正整数）为单位。</li><li><code>EXAT</code> &ndash; 设置指定的密钥过期时间，以秒（正整数）为单位。</li><li><code>PXAT</code> &ndash; 设置密钥过期的 Unix 时间，以毫秒为单位（正整数）。</li><li><code>NX</code> &ndash; 当且仅当 key 不存在时才设置。</li><li><code>XX</code> &ndash; 无论如何都会设置 key。</li><li><code>KEEPTTL</code> &ndash; 继承上一个 key 的有效时间。</li><li><code>GET</code> &ndash; 返回存储在密钥中的旧字符串，如果密钥不存在，则返回 nil。 如果键值不是字符串，会返回错误并中止 SET。</li></ul></li><li><p><a class=link href=https://redis.io/docs/latest/commands/mset/ target=_blank rel=noopener>MSET</a> / <a class=link href=https://redis.io/docs/latest/commands/msetnx/ target=_blank rel=noopener>MSETNX</a></p><p>将给定的键设置为各自的值。 两者都是原子式的，因此所有给定键都会被一次性设置。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>MSET key value [key value ...] 
</span></span><span class=line><span class=cl>MSETNX key value [key value ...]  # key 必须均不存在
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/incr/ target=_blank rel=noopener>INCR</a> / <a class=link href=https://redis.io/docs/latest/commands/incrby/ target=_blank rel=noopener>INCRBY</a></p><p>对 key 中存储数字进行加法操作，如果键不存在，则在执行操作前将其设置为 0。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>INCR key  # 将存储在键上的数字递增 1。 
</span></span><span class=line><span class=cl>INCRBY key increment  # 将存储在键上的数字递增 increment
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/decr/ target=_blank rel=noopener>DECR</a> / <a class=link href=https://redis.io/docs/latest/commands/decrby/ target=_blank rel=noopener>DECRBY</a></p><p>对 key 中存储数字进行减法操作，如果键不存在，则在执行操作前将其设置为 0。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>DECR key  # 将存储在键上的数字递减 1。 
</span></span><span class=line><span class=cl>DECRBY key increment  # 将存储在键上的数字递减 increment
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/get/ target=_blank rel=noopener>GET</a> / <a class=link href=https://redis.io/docs/latest/commands/mget/ target=_blank rel=noopener>MGET</a></p><p>获取 key 的值。 如果键不存在，则返回特殊值 nil。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GET key
</span></span><span class=line><span class=cl>MGET key [key ...]
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=应用场景>应用场景</h3><ul><li><p>缓存对象</p></li><li><p>计数器</p></li><li><p>分布式锁</p><ul><li><p>若 key 不存在，则显示插入成功，表示加锁成功</p></li><li><p>若 key 存在，则显示插入失败，表示加锁失败</p></li><li><p>需要配合 Lua 脚本实现原子性</p></li></ul></li><li><p>共享 Session 信息</p></li></ul><h2 id=list>List</h2><p>List 是简单的字符串列表（<strong>按照插入顺序排序</strong>），可以从头部或者尾部向 List 添加元素，链表最大长度为<code> $2^{32}-1$</code></p><h3 id=内部实现>内部实现</h3><ul><li>3.2 版本之前由双向链表或压缩链表实现。</li><li>3.2 版本之后由 QuickList 实现。其是多个节点（压缩列表）组成的双向链表，每个元素可以是一个整数或一个字节数组。</li></ul><h3 id=常用指令-1>常用指令</h3><ol><li><p><a class=link href=https://redis.io/docs/latest/commands/lpush/ target=_blank rel=noopener>LPUSH</a> / <a class=link href=https://redis.io/docs/latest/commands/rpush/ target=_blank rel=noopener>RPUSH</a></p><p>将所有指定值插入存储在 key 处的列表头部。 如果 key 不存在，则在执行推送操作前将其创建为空列表。 如果 key 持有的值不是 list，则会返回错误信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LPUSH/RPUSH key element [element ...]
</span></span></code></pre></td></tr></table></div></div></li></ol><div><table frame=void><tr><td><div><center><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271043542.png alt="LPUSH 命令" height=120><br>LPUSH 命令</center></div></td><td><div><center><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271044094.png alt="RPUSH 命令" height=120><br>RPUSH 命令</center></div></td></tr></table></div><ol start=2><li><p><a class=link href=https://redis.io/docs/latest/commands/lpushx/ target=_blank rel=noopener>LPUSHX</a> / <a class=link href=https://redis.io/docs/latest/commands/rpushx/ target=_blank rel=noopener>RPUSHX</a></p><p>仅在 key 已存在并持有一个列表的情况下，在 key 所在列表的首部插入指定值。 如果 key 不存在，则不会执行任何操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LPUSHX/RPUSHX key element [element ...]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/lpop/ target=_blank rel=noopener>LPOP</a> / <a class=link href=https://redis.io/docs/latest/commands/rpop/ target=_blank rel=noopener>RPOP</a></p><p>删除并返回存储在 key 处的列表的 <strong>最初/最后</strong> 一个元素。 默认情况下，该命令从列表 <strong>头部/尾部</strong> 弹出一个元素。 如果提供了可选的 count 参数，则根据列表的长度，回复最多包含 count 个元素。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LPOP/RPOP key [count]
</span></span></code></pre></td></tr></table></div></div><p><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271354782.png loading=lazy alt=image-20241227135404729></p></li><li><p><a class=link href=https://redis.io/docs/latest/commands/blpop/ target=_blank rel=noopener>BLPOP</a> / <a class=link href=https://redis.io/docs/latest/commands/brpop/ target=_blank rel=noopener>BRPOP</a></p><p><strong>BLPOP/BRPOP</strong> 是一种阻塞列表弹出原语。 它是 <strong>LPOP/RPOP</strong> 的阻塞版本，因为当没有元素从任何给定列表中弹出时，它会阻塞连接。 元素会从第一个非空列表的 <strong>头部/尾部</strong> 弹出，并按照给定键的顺序进行检查。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>BLPOP/RLPOP key [key ...] timeout
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/lindex/ target=_blank rel=noopener>LINDEX</a></p><p>返回存储在 key 中的列表中位于 index 索引处的元素。 索引以 0 为单位，因此 0 表示第一个元素，1 表示第二个元素，以此类推。 负指数可用于指定从列表尾部开始的元素。 这里，-1 表示最后一个元素，-2 表示倒数第二个元素，以此类推。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LINDEX key index
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/llen/ target=_blank rel=noopener>LLEN</a></p><p>返回存储在 key 处的 list 的长度。 如果 key 不存在，则将其解释为空列表，并返回 0。 如果 key 中存储的值不是 list，则会返回错误信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LLEN key
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/lrange/ target=_blank rel=noopener>LRANGE</a></p><p>返回存储在 key 处的列表的指定元素。 偏移量 start 和 stop 是基于 0 的索引，0 代表列表的第一个元素（列表的头），1 代表下一个元素，以此类推。 这些偏移量也可以是负数，表示从列表的末尾开始的偏移量。 例如，-1 是列表的最后一个元素，-2 是倒数第二个元素，以此类推。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LRANGE key start stop
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/lrem/ target=_blank rel=noopener>LREM</a></p><p>从存储在 key 处的列表中移除与元素相同的元素的第一个出现次数。 计数参数对操作的影响如下：count > 0：删除从头部移到尾部的与元素相同的元素。 count &lt; 0：删除从尾部移到头部的与元素相同的元素。 例如，LREM list -2 &ldquo;hello &ldquo;将删除存储在 list 中的 &ldquo;hello &ldquo;的最后两次出现。 请注意，不存在的键会被当作空 list 处理。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LREM key count element
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/ltrim/ target=_blank rel=noopener>LTRIM</a></p><p>裁剪现有列表，使其只包含指定范围的元素。 start 和 stop 都是基于 0 的索引，其中 0 代表列表的第一个元素（头部），1 代表下一个元素，依此类推。 例如，LTRIM foobar 0 2 将修改存储在 foobar 处的列表，使其只保留列表的前三个元素： start 和 end 也可以是负数，表示与列表末尾的偏移量，其中 -1 表示列表的最后一个元素，-2 表示倒数第二个元素，依此类推。 超出范围的索引不会产生错误：如果 start 大于列表末尾，或 start > end，结果将是一个空列表（导致键被移除）。 如果 end 大于列表末尾，Redis 会将其视为列表的最后一个元素。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LTRIM key start stop
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/lset/ target=_blank rel=noopener>LSET</a></p><p>将索引处的列表元素设置为指定值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LSET key index element
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/linsert/ target=_blank rel=noopener>LINSERT</a></p><p>将元素插入存储在 key 处的列表中的参考值 pivot 之前或之后。 如果 key 不存在，则视为空列表，不执行任何操作。 如果 key 存在但不包含列表值，则返回错误信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LINSERT key &lt;BEFORE | AFTER&gt; pivot element
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/brpoplpush/ target=_blank rel=noopener>BRPOPLPUSH</a></p><p>BRPOPLPUSH 是 RPOPLPUSH 的阻塞变体。 当源代码包含元素时，该命令的行为与 RPOPLPUSH 完全相同。 在 MULTI/EXEC 块内使用时，该命令的行为与 RPOPLPUSH 完全相同。 当源为空时，Redis 会阻塞连接，直到有其他客户端向其推送或超时。 如果超时为零，则会无限期阻塞。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>BRPOPLPUSH source destination timeout
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=应用场景-1>应用场景</h3><ul><li>消息队列<ul><li><strong>消息保存</strong>：LPUSH + RPOP / RPUSH+LPOP 实现消息队列（使用 BRPOP 命令进行阻塞式读取，减少消费者性能损失）</li><li><strong>重复消息处理</strong>：生产者实现全局唯一 ID</li><li><strong>消息可靠性</strong>：BRPOPLPUSH（使得消费者从一个 List 中读取消息，同时 Redis 还会把消息再插入到另一个 List 留存）</li><li><em>List 不支持多个消费者消费同一条信息</em></li></ul></li></ul><h2 id=hash>Hash</h2><p>Hash 是一个 key-value 集合，</p><h3 id=内部实现-1>内部实现</h3><div><table frame=void><tr><td><div><center><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271430099.png alt=压缩列表 height=130><br>listpack</center></div></td><td><div><center><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271431225.png alt=哈希表 height=130><br>hashtable</center></div></td></tr></table></div><ul><li>如果 Hash 元素小于 512（默认） 个，所有值小于 64 字节（默认）时，Redis 会使用 listpack 作为底层数据结构。</li><li>剩余情况，Redis 会使用 hashtable实现</li></ul><h3 id=常用命令>常用命令</h3><ol><li><p><a class=link href=https://redis.io/docs/latest/commands/hset/ target=_blank rel=noopener>HSET</a> / <a class=link href=https://redis.io/docs/latest/commands/hsetnx/ target=_blank rel=noopener>HSETNX</a></p><p>将指定字段的值设置为存储在 key 的哈希值中各自的值。 HSET 会覆盖哈希值中存在的指定字段的值，HSETNX 对于已存在的字段操作无效。 如果 key 不存在，则会创建一个新的散列键。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>HSET key field value [field value ...]
</span></span><span class=line><span class=cl>HSETNX key field value
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/hget/ target=_blank rel=noopener>HGET</a> / <a class=link href=https://redis.io/docs/latest/commands/hmget/ target=_blank rel=noopener>HMGET</a> / <a class=link href=https://redis.io/docs/latest/commands/hgetall/ target=_blank rel=noopener>HGETALL</a></p><p><em>HGET/HMGET</em> 返回键存储的哈希值中与字段相关的值。 对于散列中不存在的每个字段，都会返回一个 nil 值。 由于不存在的键被视为空哈希值，因此针对不存在的键运行 HMGET 将返回一个 nil 值列表。</p><p><em>HGETALL</em> 返回存储在 key 处的哈希值的所有字段和值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>HGET key field
</span></span><span class=line><span class=cl>HMGET key field [field ...]
</span></span><span class=line><span class=cl>HGETALL key
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/hdel/ target=_blank rel=noopener>HDEL</a></p><p>从存储在 key 中的哈希值中删除指定字段。 不存在于散列中的指定字段将被忽略。 如果没有字段，则删除散列。 如果键不存在，则将其视为空散列，此命令返回 0。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>HDEL key field [field ...]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/hlen/ target=_blank rel=noopener>HLEN</a></p><p>返回存储在 key 中的哈希值所包含字段的数量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>HLEN key
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/hexists/ target=_blank rel=noopener>HEXISTS</a></p><p>如果字段是存储在 key 处的哈希值中的现有字段，则返回 1，否则返回 0。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>HEXISTS key field
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/hkeys/ target=_blank rel=noopener>HKEYS</a> / <a class=link href=https://redis.io/docs/latest/commands/hvals/ target=_blank rel=noopener>HVALS</a></p><p><em>HKEYS</em> 返回存储在 key 处的哈希值中的所有字段名。</p><p><em>HVALS</em> 返回键存储的哈希值中的所有值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>HKEYS key
</span></span><span class=line><span class=cl>HVALS key
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/hincrby/ target=_blank rel=noopener>HINCRBY</a> / <a class=link href=https://redis.io/docs/latest/commands/hincrbyfloat/ target=_blank rel=noopener>HINCRBYFLOAT</a></p><p><em>HINCRBY</em> 按增量递增存储在 key 的哈希值中的字段数字。 如果 key 不存在，则会创建一个新的哈希值键。 如果字段不存在，则在执行操作前将其值设置为 0。</p><p><em>HINCRBYFLOAT</em> 按指定增量递增存储在键值处的散列指定字段，该字段代表一个浮点数。 如果增量为负值，结果是哈希字段值递减而不是递增。 如果字段不存在，则在执行操作前将其设置为 0。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>HINCRBY key field increment
</span></span><span class=line><span class=cl>HINCRBYFLOAT key field increment
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=应用场景-2>应用场景</h3><ul><li>缓存对象<ul><li>(key，field，value) 对应 (对象，属性，值)</li></ul></li><li>购物车<ul><li>添加商品：HSET cart:{user_id}{goods_id} 1</li><li>增加数量：HINCRBY cart:{user_id}{goods_id} 2</li><li>商品总数：HLEN cart:{user_id}</li><li>删除商品：HDEL cart:{user_id} {goods_id}</li><li>获取所有商品：HGETALL cart:{usert_id}</li></ul></li></ul><h2 id=set>Set</h2><p>Set 是一个集合（最多支持存储 $2^{32}-1$ 个元素），其中元素<strong>无序、唯一</strong>。除了支持集合内的增删改查，还支持多个集合交集、并集、差集。</p><h3 id=内部实现-2>内部实现</h3><ul><li>如果集合元素都是整数，并且元素个数小于 512（默认），Redis 会使用 整数集合作为底层数据结构。</li><li>其他情况，Redis 会使用 listpack 作为底层数据结构</li></ul><div><table frame=void><tr><td><div><center><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271556118.png alt=整数集合 height=130><br>intset</center></div></td><td><div><center><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271558737.png alt=哈希表 height=130><br>listpack</center></div></td></tr></table></div><h3 id=常用命令-1>常用命令</h3><ol><li><p><a class=link href=https://redis.io/docs/latest/commands/sadd/ target=_blank rel=noopener>SADD</a></p><p>将指定的成员添加到存储在 key 处的集合中。 如果指定的成员已经是这个集合的成员，则会被忽略。 如果 key 不存在，则会先创建一个新集合，然后再添加指定的成员。 如果存储在 key 中的值不是一个集合，则会返回错误信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SADD key member [member ...]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/srem/ target=_blank rel=noopener>SREM</a></p><p>从存储在 key 处的集合中删除指定的成员。 不属于此集合的指定成员将被忽略。 如果 key 不存在，则将其视为空集，此命令返回 0。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SREM key member [member ...]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/smembers/ target=_blank rel=noopener>SMEMBERS</a></p><p>返回存储在 key 处的集合值的所有成员。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SMEMBERS key
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/sismember/ target=_blank rel=noopener>SISMEMBER</a></p><p>返回成员是否是存储在 key 中的集合的成员。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SISMEMBER key member
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/scard/ target=_blank rel=noopener>SCARD</a></p><p>返回存储在 key 处的集合的元素个数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SCARD key
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/srandmember/ target=_blank rel=noopener>SRANDMEMBER</a> / <a class=link href=https://redis.io/docs/latest/commands/spop/ target=_blank rel=noopener>SPOP</a></p><p><em>SRANDMEMBER</em> 将从存储在 key 处的集合值中随机返回 count 个元素，元素不从 key 中删除。</p><p><em>SPOP</em> 将从存储在 key 处的集合值中随机返回 count 个元素，元素从 key 中删除。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SRANDMEMBER key [count]
</span></span><span class=line><span class=cl>SPOP key [count]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/smove/ target=_blank rel=noopener>SMOVE</a></p><p>将成员从源集合移动到目标集合。 该操作是原子操作。 如果源集合不存在或不包含指定元素，则不执行任何操作，并返回 0。 否则，该元素将从源集合中删除，并添加到目标集合中。 如果指定的元素已存在于目标集合中，则只会从源集合中移除。 如果源集合或目标集合中不存在集合值，则会返回错误信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SMOVE source destination member
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/sinter/ target=_blank rel=noopener>SINTER</a> / <a class=link href=https://redis.io/docs/latest/commands/sinterstore/ target=_blank rel=noopener>SINTERSTORE</a></p><p><em>SINTER</em> 返回所有给定集合的交集所产生的集合的成员。</p><p><em>SINTERSTORE</em> 该命令等同于 SINTER，但不是返回结果集，而是将其存储在目的地中。 如果目的地已经存在，则会被覆盖。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SINTER key [key ...]
</span></span><span class=line><span class=cl>SINTERSTORE destination key [key ...]
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=应用场景-3>应用场景</h3><ul><li>点赞（元素唯一）</li><li>共同好友（集合运算）<ul><li>数据量较大时，可以让从库进行集合运算，将结果返回给客户端，防止 Redis 阻塞。</li></ul></li><li>抽奖（元素唯一，去重）</li></ul><h2 id=zset>Zset</h2><p>Zset 相较于 Set 多了个排序属性 score，每个存储元素相当于两个值组成，一个是有序集合的元素值，一个是排序值。</p><h3 id=内部实现-3>内部实现</h3><ul><li>若 Zset 中元素小于 128 个，且每个元素小于 64 字节，Redis 使用 listpack 作为底层数据结构。</li><li>剩余情况，Redis 会使用</li></ul><div><table frame=void><tr><td><div><center><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271628134.png alt=listpack height=130><br>listpack</center></div></td><td><div><center><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271628892.png alt=跳表 height=130><br>skiplist</center></div></td></tr></table></div><h3 id=常用命令-2>常用命令</h3><ol><li><p><a class=link href=https://redis.io/docs/latest/commands/zadd/ target=_blank rel=noopener>ZADD</a></p><p>将具有指定分数的所有指定成员添加到存储在 key 处的排序集合中。 可以指定多个分数/成员对。 如果指定的成员已经是排序集合的成员，则会更新得分，并将元素重新插入正确的位置，以确保排序正确。 如果 key 不存在，则会创建一个新的排序集合，并将指定的成员作为唯一成员，就像排序集合为空一样。 如果键存在，但没有排序集，则会返回错误信息。 分数值应是双精度浮点数的字符串表示。 +inf 和 -inf 值也是有效值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member ...]
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>XX</strong>: 只更新已存在的元素，不添加新元素。</li><li><strong>NX</strong>: 只添加新元素，不更新已存在的元素。</li><li><strong>LT</strong>: 只在新分数小于当前分数时更新现有元素。此标记不会阻止添加新元素。</li><li><strong>GT</strong>: 仅在新分数大于当前分数时更新现有元素。 此标记不会阻止添加新元素。</li><li><strong>CH</strong>: 将返回值从增加的新元素数量修改为改变的元素总数（CH 是 changed 的缩写）。 更改的元素是指新增的元素和已存在的元素，这些元素的分值已被更新。 因此，命令行中指定的元素如果得分与过去相同，则不计算在内。 注意：通常情况下，ZADD 的返回值只计算新增元素的数量。</li><li><strong>INCR</strong>: 指定该选项时，ZADD 的作用与 ZINCRBY 类似。 在这种模式下，只能指定一个分数元素对。</li></ul></li><li><p><a class=link href=https://redis.io/docs/latest/commands/zrem/ target=_blank rel=noopener>ZREM</a></p><p>从存储在 key 中的排序集合中删除指定的成员。 如果 key 存在但没有排序集，则会返回错误信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ZREM key member [member ...]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/zscore/ target=_blank rel=noopener>ZSCORE</a></p><p>返回排序集合中 key 处成员的得分。 如果排序集合中不存在成员或 key 不存在，则返回 nil。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ZSCORE key member
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/zcard/ target=_blank rel=noopener>ZCARD</a></p><p>返回存储在 key 处的排序集的元素个数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ZCARD key
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/zincrby/ target=_blank rel=noopener>ZINCRBY</a></p><p>用增量递增键值存储的排序集合中成员的得分。 如果成员不存在于排序集合中，则会以增量作为其得分（就像它之前的得分是 0.0）。 如果 key 不存在，则会创建一个以指定成员为唯一成员的新排序集。 如果 key 存在但不包含排序集，则会返回错误信息。 分数值应是数值的字符串表示，并接受双精度浮点数。 可以提供一个负值来递减分数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ZINCRBY key increment member
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/zrange/ target=_blank rel=noopener>ZRANGE</a></p><p>返回存储在 key 中的排序集合中元素的指定范围。 ZRANGE 可以执行不同类型的范围查询：按索引（秩）、按分数或按词典顺序。</p><p>默认情况下，该命令执行索引范围查询。 start 和 stop 参数代表基于零的索引，其中 0 代表第一个元素。 这些参数指定了一个包含范围，例如，ZRANGE myzset 0 1 将同时返回排序集的第一个和第二个元素。 索引也可以是负数，表示从排序集末尾开始的偏移量，-1 表示排序集的最后一个元素。</p><p>当提供 BYSCORE 选项时，命令的行为与 ZRANGEBYSCORE 类似，返回排序集中分数等于或介于 start 和 stop 之间的元素范围。</p><p>使用 REV 选项会反转排序集，索引 0 将作为得分最高的元素。</p><p>当使用 BYLEX 选项时，命令的行为与 ZRANGEBYLEX 类似，并返回排序集合中 start 和 stop 之间的元素范围。 请注意，词典排序依赖于所有元素具有相同的分数。 有效的 start 和 stop 必须以 ( 或 [ 开头，以便分别指定范围区间是排他的还是包含的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/zunionstore/ target=_blank rel=noopener>ZUNIONSTORE</a> / <a class=link href=https://redis.io/docs/latest/commands/zdiffstore/ target=_blank rel=noopener>ZDIFFSTORE</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE &lt;SUM | MIN | MAX&gt;]  # 并集
</span></span><span class=line><span class=cl>ZDIFFSTORE destination numkeys key [key ...]  # 第一个集合和之后集合的差集
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=应用场景-4>应用场景</h3><ul><li><p>排行榜（有序唯一）</p></li><li><p>电话、姓名排序</p></li></ul><h2 id=bitmap>BitMap</h2><p>BitMap 是一串连续的二进制数组，可以通过偏移量定位元素，适合数据量大且使用二值统计的场景。</p><h3 id=内部实现-4>内部实现</h3><p>String 类型是会保存为二进制的字节数组</p><h3 id=常用命令-3>常用命令</h3><ol><li><p><a class=link href=https://redis.io/docs/latest/commands/setbit/ target=_blank rel=noopener>SETBIT</a></p><p>设置或清除存储在 key 处字符串值偏移量的位。 位的设置或清除取决于值，值可以是 0 或 1。当 key 不存在时，将创建一个新的字符串值。 字符串的增长是为了确保它能容纳偏移量处的位。 偏移参数必须大于或等于 0，且小于 2^32（这将位图限制在 512MB）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SETBIT key offset value
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/getbit/ target=_blank rel=noopener>GETBIT</a></p><p>返回存储在 key 处的字符串值中偏移量处的比特值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GETBIT key offset
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/bitcount/ target=_blank rel=noopener>BITCOUNT</a></p><p>获取指定范围内值为 1 的个数，默认以字节为单位。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>BITCOUNT key [start end [BYTE | BIT]]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/bitop/ target=_blank rel=noopener>BITOP</a></p><p>在多个键（包含字符串值）之间执行位操作，并将结果存储到目标键中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>BITOP &lt;AND | OR | XOR | NOT&gt; destkey key [key ...]
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=应用场景-5>应用场景</h3><ul><li><p>签到统计</p></li><li><p>判断用户登陆态</p></li></ul><h2 id=hyperloglog>HyperLogLog</h2><p>HyperLogLog 是一种用于统计基数的数据集合类型，基数统计就是指<strong>统计一个集合中不重复的元素个数</strong>。HyperLogLog 的<strong>统计规则基于概率完成，标准误算率为 0.81%</strong>。</p><h3 id=内部实现-5>内部实现</h3><p>^ - ^</p><h3 id=常见命令>常见命令</h3><ol><li><p><a class=link href=https://redis.io/docs/latest/commands/pfadd/ target=_blank rel=noopener>PFADD</a></p><p>将所有元素参数添加到存储在作为第一个参数指定的变量名下的 HyperLogLog 中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>PFADD key [element [element ...]]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/pfcount/ target=_blank rel=noopener>PFCOUNT</a></p><p>使用单键调用时，返回存储在指定变量中的 HyperLogLog 的基数估算值，如果变量不存在，则返回 0。 使用多键调用时，通过内部合并存储在所提供键中的 HyperLogLog 成一个临时的 HyperLogLog，返回所传递的 HyperLogLog 联合的基数估算值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>PFCOUNT key [key ...]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/pfmerge/ target=_blank rel=noopener>PFMERGE</a></p><p>将多个 HyperLogLog 值合并为一个 HyperLogLog 。如果目标 HyperLogLog 不存在（默认为空 HyperLogLog），则创建。 如果存在，则将其视为源集之一。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>PFMERGE destkey [sourcekey [sourcekey ...]]
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=应用场景-6>应用场景</h3><ul><li>网页用户访问(UV)计数</li></ul><h2 id=geo>GEO</h2><p>主要用于存储地理信息</p><h3 id=内部实现-6>内部实现</h3><p>底层复用 Zset，使用 GeoHash 实现了经纬度到 Zset 中元素的权重分数的转换，关键机制是 <em>二维地图区间划分</em> 和 <em>区间编码</em> 。地理位置转换为经纬度后，使用区间编码标识，并将编码值作为 Zset 的权重分数。</p><h3 id=常用命令-4>常用命令</h3><ol><li><p><a class=link href=https://redis.io/docs/latest/commands/geoadd/ target=_blank rel=noopener>GEOADD</a></p><p>存储指定的地理位置信息，将经度，纬度，位置名称添加到指定的 key 中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>XX</strong>: 只更新已存在的元素，从不添加元素。</li><li><strong>NX</strong>: 不更新已存在的元素。</li><li><strong>CH</strong>: 不更新已存在的元素。 总是添加新元素： 将返回值从添加的新元素数修改为更改的元素总数。 更改的元素是指新增的元素和坐标已更新的已有元素。</li></ul></li><li><p><a class=link href=https://redis.io/docs/latest/commands/geopos/ target=_blank rel=noopener>GEOPOS</a></p><p>返回关键字处排序集所代表的地理空间索引中所有指定成员的位置（经度、纬度）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GEOPOS key [member [member ...]]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/geodist/ target=_blank rel=noopener>GEODIST</a></p><p>返回排序集所代表的地理空间索引中两个成员之间的距离。 单位必须是以下之一，默认为米：m 表示米。 km 表示公里。 mi 表示英里。 ft 表示英尺。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GEODIST key member1 member2 [M | KM | FT | MI]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/georadius/ target=_blank rel=noopener>GEORADIUS</a></p><p>返回使用 GEOADD 填充了地理空间信息的排序集合的成员，这些成员位于以中心位置和距中心最大距离（半径）指定的区域边界内。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GEORADIUS key longitude latitude radius &lt;M | KM | FT | MI&gt;
</span></span><span class=line><span class=cl>  [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC | DESC]
</span></span><span class=line><span class=cl>  [STORE key | STOREDIST key]
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=应用场景-7>应用场景</h3><ul><li>位置信息服务</li></ul><h2 id=stream>Stream</h2><p>专为消息队列设计的数据类型，支持消息持久化、自动生成全局唯一 ID、支持 ACK 确认消息、支持消费组模式</p><h3 id=内部实现-7>内部实现</h3><p>^ - ^</p><h3 id=常见命令-1>常见命令</h3><ol><li><p><a class=link href=https://redis.io/docs/latest/commands/xadd/ target=_blank rel=noopener>XADD</a></p><p>将指定的数据流条目添加到指定键的数据流中。 如果键值不存在，则使用流的值创建键值。 可以使用 NOMKSTREAM 选项禁用创建数据流键。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>XADD key [NOMKSTREAM] [&lt;MAXLEN | MINID&gt; [= | ~] threshold
</span></span><span class=line><span class=cl>  [LIMIT count]] &lt;* | id&gt; field value [field value ...]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/xlen/ target=_blank rel=noopener>XLEN</a></p><p>返回数据流中的条目数。 如果指定的键不存在，命令将返回 0。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>XLEN key
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/xread/ target=_blank rel=noopener>XREAD</a> / <a class=link href=https://redis.io/docs/latest/commands/xreadgroup/ target=_blank rel=noopener>XREADGROUP</a></p><p><em>XREAD</em> 从一个或多个数据流中读取数据，只返回 ID 大于调用者报告的最后接收 ID 的条目。 该命令有一个选项，可在项目不可用时阻塞。</p><p><em>XREADGROUP</em> 命令是 XREAD 命令的一个特殊版本，支持消费者组。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]
</span></span><span class=line><span class=cl>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] id [id ...]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/xdel/ target=_blank rel=noopener>XDEL</a></p><p>从数据流中删除指定条目，并返回已删除条目的数量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>XDEL key id [id ...]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/xrange/ target=_blank rel=noopener>XRANGE</a></p><p>该命令返回与给定 ID 范围匹配的数据流条目。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>XRANGE key start end [COUNT count]
</span></span></code></pre></td></tr></table></div></div></li><li><p><a class=link href=https://redis.io/docs/latest/commands/xpending/ target=_blank rel=noopener>XPENDING</a> / <a class=link href=https://redis.io/docs/latest/commands/xack/ target=_blank rel=noopener>XACK</a></p><p><em>XPENDING</em> 查询每个消费组内所有消费者 <strong>已读取、尚未确认</strong> 的消息。</p><p><em>XACK</em> 向消息队列确认消息处理已完成</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>XPENDING key group [[IDLE min-idle-time] start end count [consumer]]
</span></span><span class=line><span class=cl>XACK key group id [id ...]
</span></span></code></pre></td></tr></table></div></div></li></ol></section><footer class=article-footer><section class=article-tags><a href=/tags/redis/>Redis</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/redis%E7%AE%80%E4%BB%8B/><div class=article-details><h2 class=article-title>Redis简介</h2></div></a></article><article><a href=/p/gmp-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/><div class=article-details><h2 class=article-title>GMP 调度模型</h2></div></a></article><article><a href=/p/goroutine/><div class=article-details><h2 class=article-title>Goroutine</h2></div></a></article><article><a href=/p/nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/><div class=article-details><h2 class=article-title>Nginx 反向代理</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2024 -
2025 Ting</section><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span>
<script language=javascript>var now=new Date;function createtime(){now.setTime(now.getTime()+250);var e=new Date("2024/12/02 00:00:00");days=(now-e)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-e)/1e3/60/60-24*dnum,hnum=Math.floor(hours),String(hnum).length==1&&(hnum="0"+hnum),minutes=(now-e)/1e3/60-24*60*dnum-60*hnum,mnum=Math.floor(minutes),String(mnum).length==1&&(mnum="0"+mnum),seconds=(now-e)/1e3-24*60*60*dnum-60*60*hnum-60*mnum,snum=Math.round(seconds),String(snum).length==1&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已稳定运行"+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.29.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script src=https://npm.elemecdn.com/nprogress@0.2.0/nprogress.js crossorigin=anonymous></script><link rel=stylesheet href=https://npm.elemecdn.com/nprogress@0.2.0/nprogress.css crossorigin=anonymous><script>NProgress.start(),document.addEventListener("readystatechange",()=>{document.readyState==="interactive"&&NProgress.inc(.8),document.readyState==="complete"&&NProgress.done()})</script></body></html>