<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="实现原理 Go 的 map 是一个指针，占用 8 个字节，指向 hmap 结构体，map 底层是基于哈希表+链地址法存储的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type hmap struct { count int // 当前 map 中元素个数 flags uint8 // 写入状态标志 B uint8 // buckets 的数量（2^B 个） noverflow uint16 // 溢出 buckets 的数量 hash0 uint32 // 生成 hash 的随机数种子 buckets unsafe.Pointer // 指向 buckets 数组的指针 oldbuckets unsafe.Pointer // 扩容时，指向扩容前的 buckets 数组的指针 nevacuate uintptr // 表示扩容进度，小于此地址的 buckets 已经迁移成功 extra *mapextra // 保存溢出桶的地址 } type mapextra struct { overflow *[]*bmap // overflow 包含的是 hmap.buckets 的 overflow 的 buckets oldoverflow *[]*bma // oldoverflow 包含扩容时 hmap.oldbuckets 的 overflow 的 bucket nextOverflow *bmap // 指向空闲的 overflow bucket 的指针 } bmap 就是我们常说的 bucket，一个 bucket 里面会最多装 8 个key，这些 key 哈希结果的低 B 位是相同的。在 bucket 内，又会根据 key 计算出来的hash值的高8位（一个桶内最多有8个位置）来决定 key 到底落入哪个位置。\n"><title>Go八股之Map</title>
<link rel=canonical href=https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bmap/><link rel=stylesheet href=/scss/style.min.4c95e9eba1df99fc729adf1fbbd70932e74a1463683ffb6ede4a153a51f6c6c3.css><meta property='og:title' content="Go八股之Map"><meta property='og:description' content="实现原理 Go 的 map 是一个指针，占用 8 个字节，指向 hmap 结构体，map 底层是基于哈希表+链地址法存储的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type hmap struct { count int // 当前 map 中元素个数 flags uint8 // 写入状态标志 B uint8 // buckets 的数量（2^B 个） noverflow uint16 // 溢出 buckets 的数量 hash0 uint32 // 生成 hash 的随机数种子 buckets unsafe.Pointer // 指向 buckets 数组的指针 oldbuckets unsafe.Pointer // 扩容时，指向扩容前的 buckets 数组的指针 nevacuate uintptr // 表示扩容进度，小于此地址的 buckets 已经迁移成功 extra *mapextra // 保存溢出桶的地址 } type mapextra struct { overflow *[]*bmap // overflow 包含的是 hmap.buckets 的 overflow 的 buckets oldoverflow *[]*bma // oldoverflow 包含扩容时 hmap.oldbuckets 的 overflow 的 bucket nextOverflow *bmap // 指向空闲的 overflow bucket 的指针 } bmap 就是我们常说的 bucket，一个 bucket 里面会最多装 8 个key，这些 key 哈希结果的低 B 位是相同的。在 bucket 内，又会根据 key 计算出来的hash值的高8位（一个桶内最多有8个位置）来决定 key 到底落入哪个位置。\n"><meta property='og:url' content='https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bmap/'><meta property='og:site_name' content='踩坑记录'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Golang'><meta property='article:published_time' content='2025-01-16T13:42:27+08:00'><meta property='article:modified_time' content='2025-01-16T13:42:27+08:00'><meta name=twitter:title content="Go八股之Map"><meta name=twitter:description content="实现原理 Go 的 map 是一个指针，占用 8 个字节，指向 hmap 结构体，map 底层是基于哈希表+链地址法存储的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type hmap struct { count int // 当前 map 中元素个数 flags uint8 // 写入状态标志 B uint8 // buckets 的数量（2^B 个） noverflow uint16 // 溢出 buckets 的数量 hash0 uint32 // 生成 hash 的随机数种子 buckets unsafe.Pointer // 指向 buckets 数组的指针 oldbuckets unsafe.Pointer // 扩容时，指向扩容前的 buckets 数组的指针 nevacuate uintptr // 表示扩容进度，小于此地址的 buckets 已经迁移成功 extra *mapextra // 保存溢出桶的地址 } type mapextra struct { overflow *[]*bmap // overflow 包含的是 hmap.buckets 的 overflow 的 buckets oldoverflow *[]*bma // oldoverflow 包含扩容时 hmap.oldbuckets 的 overflow 的 bucket nextOverflow *bmap // 指向空闲的 overflow bucket 的指针 } bmap 就是我们常说的 bucket，一个 bucket 里面会最多装 8 个key，这些 key 哈希结果的低 B 位是相同的。在 bucket 内，又会根据 key 计算出来的hash值的高8位（一个桶内最多有8个位置）来决定 key 到底落入哪个位置。\n"><link rel="shortcut icon" href=/%e5%a4%aa%e9%98%b3%e7%a5%9e%e9%b8%9f.svg><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/misans@3.1.1/lib/misans-400-regular.min.css></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><div id=article-toolbar style=position:sticky;top:5px;z-index:1000><a href=/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span></a></div><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#实现原理>实现原理</a></li><li><a href=#初始化-map>初始化 Map</a></li><li><a href=#扩容-map>扩容 Map</a><ol><li><a href=#触发时机>触发时机</a></li><li><a href=#扩容机制>扩容机制</a></li></ol></li><li><a href=#遍历-map>遍历 Map</a></li><li><a href=#查找-map>查找 Map</a></li><li><a href=#map-冲突解决方案>map 冲突解决方案</a></li><li><a href=#map-的负载因子>map 的负载因子</a></li><li><a href=#map-和-syncmap>Map 和 sync.Map</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E7%BC%96%E7%A8%8B/>编程</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bmap/>Go八股之Map</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2025/01/16</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 6 分钟</time></div></footer></div></header><section class=article-content><h2 id=实现原理>实现原理</h2><p>Go 的 map 是一个指针，占用 8 个字节，指向 hmap 结构体，map 底层是基于哈希表+链地址法存储的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>hmap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>count</span>     <span class=kt>int</span>    <span class=c1>// 当前 map 中元素个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>flags</span>     <span class=kt>uint8</span>  <span class=c1>// 写入状态标志
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>B</span>         <span class=kt>uint8</span>  <span class=c1>// buckets 的数量（2^B 个）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>noverflow</span> <span class=kt>uint16</span> <span class=c1>// 溢出 buckets 的数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>hash0</span>     <span class=kt>uint32</span> <span class=c1>// 生成 hash 的随机数种子
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>buckets</span>    <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>  <span class=c1>// 指向 buckets 数组的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>oldbuckets</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>  <span class=c1>// 扩容时，指向扩容前的 buckets 数组的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>nevacuate</span>  <span class=kt>uintptr</span>  <span class=c1>// 表示扩容进度，小于此地址的 buckets 已经迁移成功
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>extra</span> <span class=o>*</span><span class=nx>mapextra</span>  <span class=c1>// 保存溢出桶的地址
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>mapextra</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>overflow</span>    <span class=o>*</span><span class=p>[]</span><span class=o>*</span><span class=nx>bmap</span> <span class=c1>// overflow 包含的是 hmap.buckets 的 overflow 的 buckets
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>oldoverflow</span> <span class=o>*</span><span class=p>[]</span><span class=o>*</span><span class=nx>bma</span>  <span class=c1>// oldoverflow 包含扩容时 hmap.oldbuckets 的 overflow 的 bucket
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>nextOverflow</span> <span class=o>*</span><span class=nx>bmap</span>   <span class=c1>// 指向空闲的 overflow bucket 的指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>bmap </code>就是我们常说的 <code>bucket</code>，一个 <code>bucket</code> 里面会最多装 8 个key，这些 key 哈希结果的低 B 位是相同的。在 <code>bucket</code> 内，又会根据 key 计算出来的hash值的高8位（一个桶内最多有8个位置）来决定 key 到底落入哪个位置。</p><p>当 map 的 key 和 value 均不为指针类型时，bmap 将完全不包含指针，那么垃圾回收就不用扫描 bmap。bmap 指向溢出桶的字段 overflow 是 uintptr 类型，为了防止这些溢出桶被垃圾回收，所以需要 <code>mapextra.overflow</code> 将它保存起来。如果 bmap 的 overflow 是 *bmap 类型，那么垃圾回收需要扫描一个个拉链表，效率明显不如直接扫描一段内存（hmap.mapextra.overflow）效率高。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// bmap 静态结构
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>bmap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>tophash</span> <span class=p>[</span><span class=nx>bucketCnt</span><span class=p>]</span><span class=kt>uint8</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// bmap 动态结构
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>bmap</span> <span class=kd>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>tophash</span> <span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=kt>uint8</span>   <span class=c1>// 存储哈希值的高 8 位，用于快速比较和查找
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>keys</span> <span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=nx>keytype</span>    <span class=c1>// 存放 key，keytype 由编译器编译时候确定
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>values</span> <span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=nx>elemtype</span> <span class=c1>// 存放 value，elemtype 由编译器编译时候确定
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>overflow</span> <span class=kt>uintptr</span>   <span class=c1>// 指向下一个 bmap，overflow 是 uintptr 而不是 *bmap 类型，保证 bmap 完全不含指针，是为了减少 GC，溢出桶存储到 extra 字段中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>tophash 字段不仅存储 hash(key) 的高 8 位，还会存储一些状态值，用来表明当前 <code>bucket</code> 状态。/为了避免 hash(key) 高 8 位值和这些状态值相等，所以当 hash(key) &lt; minTopHash 时，自动将其值加上 minTopHash 作为该 key 的 tophash。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>emptyRest</span><span class=p>=</span> <span class=mi>0</span> <span class=c1>//表明此桶单元为空，且更高索引的单元也是空
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>emptyOne</span><span class=p>=</span><span class=mi>1</span> <span class=c1>//表明此桶单元为空
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>evacuatedX</span><span class=p>=</span> <span class=mi>2</span> <span class=c1>//用于表示扩容迁移到新桶前半段区间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>evacuatedY</span><span class=p>=</span> <span class=mi>3</span> <span class=c1>//用于表示扩容迁移到新桶后半段区间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>evacuatedEmpty</span> <span class=p>=</span> <span class=mi>4</span> <span class=c1>//用于表示此单元已迁移
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>minTopHash</span><span class=p>=</span> <span class=mi>5</span> <span class=c1>// key的tophash值与桶状态值分割线值，小于此值的一定代表着桶单元的状态，大于此值的一定是key对应的tophash值
</span></span></span></code></pre></td></tr></table></div></div><h2 id=初始化-map>初始化 Map</h2><ol><li>创建一个 hmap 结构体对象</li><li>生成一个哈希因子 hash0 并赋值到 hmap 对象中（用于后续为key创建哈希值）</li><li>根据 hint=10，并根据算法规则来创建B，此时的 B=1</li><li>根据 B 去创建 bucket 并存放在数组中。当前的 Bmap 的数量为 2<ul><li>B&lt;4时，创建桶的个数为：$2^B$（标准桶）</li><li>B≥4时，创建桶的个数为：$2^B+2^{B-4}$（标准桶+溢出桶）</li></ul></li></ol><h2 id=扩容-map>扩容 Map</h2><p>Go map 扩容，数据迁移不是一次性迁移，而是等到访问到具体某个 bucket 时才将数据从旧 bucket 中迁移到新bucket 中。</p><ul><li>一次性迁移会涉及到cpu资源和内存资源的占用，在数据量较大时，会有较大的延时，影响正常业务逻辑。因此 Go 采用渐进式的数据迁移，每次最多迁移两个bucket的数据到新的buckets中（一个是当前访问key所在的bucket，然后再多迁移一个bucket）</li></ul><h3 id=触发时机>触发时机</h3><ul><li><p>超过负载：<strong>map 元素个数 > 6.5 * bucket 数量</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>if</span> <span class=p>!</span><span class=nx>h</span><span class=p>.</span><span class=nf>growing</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nf>overLoadFactor</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>count</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=o>||</span> <span class=nf>tooManyOverflowBuckets</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>noverflow</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>hashGrow</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>goto</span> <span class=nx>again</span> <span class=c1>// Growing the table invalidates everything, so try again
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 判断是否在扩容
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>)</span> <span class=nf>growing</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>h</span><span class=p>.</span><span class=nx>oldbuckets</span> <span class=o>!=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>溢出桶太多：当 <strong>bucket 小于 $2^{15}$ 且溢出桶总大于等于桶总数</strong>，则认为溢出桶过多；当 <strong>bucket 大于等于 $2^{15}$时且溢出桶总数大于等于 $2^{15}$时</strong>，即认为溢出桶太多了。</p></li></ul><h3 id=扩容机制>扩容机制</h3><ul><li>双倍扩容：如果是因为超过负载扩容，新建一个 buckets 数组（大小为原先的 2 倍），然后旧的 buckets 数据搬到新的 buckets 中</li><li>等量扩容：如果是因为溢出桶太多，buckets 数量维持不变，重新做一遍类似双倍扩容的搬迁操作， 把松散的键值对重新排列一次，使得同一个bucket中的key排列地更紧密，提高buckets利用 率，进而保证更快的存取。</li></ul><h2 id=遍历-map>遍历 Map</h2><p>使用 range 多次遍历 map 时输出的 key 和 value 的顺序可能不同。这是 Go 语言的设计者们<strong>有意为之</strong>，旨在提示开发者们，Go 底层实现并不保证 map 遍历顺序稳定，请大家不要依赖 range 遍历结果顺序。</p><p>主要原因有一下两点：</p><ul><li>map在遍历时，并不是从固定的0号bucket开始遍历的，每次遍历，都会从一个<strong>随机值序号的bucket</strong>，再从其中<strong>随机的cell</strong>开始遍历</li><li>map遍历时，是按序遍历bucket，同时按需遍历bucket中和其overflow bucket中的cell。但是map在扩容后，会发生key的搬迁，这造成原来落在一个bucket中的key，搬迁后，有可能会落到其他bucket中了，从这个角度看，遍历map的结果就不可能是按照原来的顺序了</li></ul><p>map 本身是无序的，且遍历时顺序还会被随机化，如果想顺序遍历 map，需要对 map key 先排序，再按照 key 的顺序遍历 map。</p><h2 id=查找-map>查找 Map</h2><p>Go 语言中读取 map 有两种语法：带 comma 和 不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一个 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 不带 comma 用法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>value</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>[</span><span class=s>&#34;name&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;value:%s&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 带 comma 用法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>value</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>[</span><span class=s>&#34;name&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;value:%s&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>整个流程如下：</p><ol><li><strong>写保护监测</strong>：函数首先会检查标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行写操作，进而导致程序 panic（这也说明了 map 不是线程安全的）；</li><li><strong>计算hash值</strong>：<code>hash:=t.hasher(key,uintptr(h.hash0))</code>， 不同类型的key会有不同的hash函数</li><li><strong>找到hash对应的bucket</strong>：hash 的低 B 个 bit 位，用来定位 key 所存放的bucket。如果当前正在扩容中，并且定位到的旧bucket数据还未完成迁移，则使用旧的bucket（扩容前的bucket）</li><li><strong>遍历bucket查找</strong>：利用哈希值的高 8 个 bit 位快速判断 key 是否已在当前 bucket 中（如果不在的话，需要去 bucket 的 overflow 中查找）</li><li><strong>返回key对应的指针</strong>：如果通过上面的步骤找到了key对应的槽位下标 i，根据此得到对应 value 的值</li></ol><h2 id=map-冲突解决方案>map 冲突解决方案</h2><ul><li>链地址法</li><li>开放寻址法</li><li>线性探测法</li></ul><p>Go map采用链地址法解决冲突，具体就是<strong>插入key到map中时</strong>，当key定位的桶<strong>填满8个元素后</strong>（这里的单元就是桶，不是元素），将会创建一个溢出桶，并且将溢出桶插入当前桶所在链表尾部。</p><h2 id=map-的负载因子>map 的负载因子</h2><p>$负载因子=\frac{哈希表中存储元素}{桶数量}$，其是衡量当前哈希表中空间占用率的核心指标。</p><p>Go Map 的负载因子是 6.5，原因就是官方测试这个数值负载因子的性能较好，具体可看测试：</p><div class=table-wrapper><table><thead><tr><th style=text-align:center>负载因子</th><th style=text-align:center>溢出率</th><th style=text-align:center>耗费字节数/kv 对</th><th style=text-align:center>查找平均个数（k存在）</th><th style=text-align:center>查找平均个数（k不存在）</th></tr></thead><tbody><tr><td style=text-align:center>4.00</td><td style=text-align:center>2.13</td><td style=text-align:center>20.77</td><td style=text-align:center>3.00</td><td style=text-align:center>4.00</td></tr><tr><td style=text-align:center>4.50</td><td style=text-align:center>4.05</td><td style=text-align:center>17.30</td><td style=text-align:center>3.25</td><td style=text-align:center>4.50</td></tr><tr><td style=text-align:center>5.00</td><td style=text-align:center>6.85</td><td style=text-align:center>14.77</td><td style=text-align:center>3.50</td><td style=text-align:center>5.00</td></tr><tr><td style=text-align:center>5.50</td><td style=text-align:center>10.55</td><td style=text-align:center>12.94</td><td style=text-align:center>3.75</td><td style=text-align:center>5.50</td></tr><tr><td style=text-align:center>6.00</td><td style=text-align:center>15.27</td><td style=text-align:center>11.67</td><td style=text-align:center>4.00</td><td style=text-align:center>6.00</td></tr><tr><td style=text-align:center>6.50</td><td style=text-align:center>20.90</td><td style=text-align:center>10.79</td><td style=text-align:center>4.25</td><td style=text-align:center>6.50</td></tr><tr><td style=text-align:center>7.00</td><td style=text-align:center>27.14</td><td style=text-align:center>10.15</td><td style=text-align:center>4.50</td><td style=text-align:center>7.00</td></tr><tr><td style=text-align:center>7.50</td><td style=text-align:center>34.03</td><td style=text-align:center>9.73</td><td style=text-align:center>4.75</td><td style=text-align:center>7.50</td></tr><tr><td style=text-align:center>8.00</td><td style=text-align:center>41.10</td><td style=text-align:center>9.40</td><td style=text-align:center>5.00</td><td style=text-align:center>8.00</td></tr></tbody></table></div><h2 id=map-和-syncmap>Map 和 sync.Map</h2><p>Go 语言的 <code>sync.Map</code> 支持并发读写</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Map</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>mu</span> <span class=nx>Mutex</span>
</span></span><span class=line><span class=cl>   <span class=nx>read</span> <span class=nx>atomic</span><span class=p>.</span><span class=nx>Value</span> <span class=c1>// readOnly
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>dirty</span> <span class=kd>map</span><span class=p>[</span><span class=kd>interface</span><span class=p>{}]</span><span class=o>*</span><span class=nx>entry</span>
</span></span><span class=line><span class=cl>   <span class=nx>misses</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>map 在单个 goroutine 上的读写性能会很好，因为他在读写时没有额外的同步开销，但是他并不是并发安全的，如果多个 goroutine 同时读写一个 map 会导致数据竞争</li><li>sync.Map 通常在并发读写时性能较好，在多 goroutine 场景下会更加安全，适合读多写少场景（写多场景下会导致 read map 缓存失效，性能下降）</li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/golang/>Golang</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bmutex/><div class=article-details><h2 class=article-title>Go八股之Mutex</h2></div></a></article><article><a href=/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bchannel/><div class=article-details><h2 class=article-title>Go八股之Channel</h2></div></a></article><article><a href=/p/go%E5%85%AB%E8%82%A1%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/><div class=article-details><h2 class=article-title>Go八股之内存分配</h2></div></a></article><article><a href=/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bslice/><div class=article-details><h2 class=article-title>Go八股之Slice</h2></div></a></article><article><a href=/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bgc/><div class=article-details><h2 class=article-title>Go八股之GC</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2024 -
2025 Ting</section><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span>
<script language=javascript>var now=new Date;function createtime(){now.setTime(now.getTime()+250);var e=new Date("2024/12/02 00:00:00");days=(now-e)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-e)/1e3/60/60-24*dnum,hnum=Math.floor(hours),String(hnum).length==1&&(hnum="0"+hnum),minutes=(now-e)/1e3/60-24*60*dnum-60*hnum,mnum=Math.floor(minutes),String(mnum).length==1&&(mnum="0"+mnum),seconds=(now-e)/1e3-24*60*60*dnum-60*60*hnum-60*mnum,snum=Math.round(seconds),String(snum).length==1&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已稳定运行"+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.29.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script src=https://npm.elemecdn.com/nprogress@0.2.0/nprogress.js crossorigin=anonymous></script><link rel=stylesheet href=https://npm.elemecdn.com/nprogress@0.2.0/nprogress.css crossorigin=anonymous><script>NProgress.start(),document.addEventListener("readystatechange",()=>{document.readyState==="interactive"&&NProgress.inc(.8),document.readyState==="complete"&&NProgress.done()})</script></body></html>