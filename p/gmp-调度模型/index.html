<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="历史背景 含义 缺点 进程时代 一个程序就是一个进程，所有进程严格按照时间执行 进程阻塞十分损耗性能、只能串行执行任务 线程时代 一个进程阻塞，可以切换到其他进程 上下文切换成本高、协程内存占用较高 协程时代 协程绑定线程，CPU 调度线程执行 实现复杂，协程和线程的绑定依赖调度器算法 GMP 调度模型是什么 "><title>GMP 调度模型</title>
<link rel=canonical href=https://the-oone.github.io/p/gmp-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/><link rel=stylesheet href=/scss/style.min.4c95e9eba1df99fc729adf1fbbd70932e74a1463683ffb6ede4a153a51f6c6c3.css><meta property='og:title' content="GMP 调度模型"><meta property='og:description' content="历史背景 含义 缺点 进程时代 一个程序就是一个进程，所有进程严格按照时间执行 进程阻塞十分损耗性能、只能串行执行任务 线程时代 一个进程阻塞，可以切换到其他进程 上下文切换成本高、协程内存占用较高 协程时代 协程绑定线程，CPU 调度线程执行 实现复杂，协程和线程的绑定依赖调度器算法 GMP 调度模型是什么 "><meta property='og:url' content='https://the-oone.github.io/p/gmp-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/'><meta property='og:site_name' content='踩坑记录'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Golang'><meta property='article:published_time' content='2025-01-13T14:46:19+08:00'><meta property='article:modified_time' content='2025-01-13T14:46:19+08:00'><meta name=twitter:title content="GMP 调度模型"><meta name=twitter:description content="历史背景 含义 缺点 进程时代 一个程序就是一个进程，所有进程严格按照时间执行 进程阻塞十分损耗性能、只能串行执行任务 线程时代 一个进程阻塞，可以切换到其他进程 上下文切换成本高、协程内存占用较高 协程时代 协程绑定线程，CPU 调度线程执行 实现复杂，协程和线程的绑定依赖调度器算法 GMP 调度模型是什么 "><link rel="shortcut icon" href=/%e5%a4%aa%e9%98%b3%e7%a5%9e%e9%b8%9f.svg><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/misans@3.1.1/lib/misans-400-regular.min.css></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><div id=article-toolbar style=position:sticky;top:5px;z-index:1000><a href=/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span></a></div><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#历史背景>历史背景</a></li><li><a href=#gmp-调度模型是什么>GMP 调度模型是什么</a></li><li><a href=#go-调度原理>Go 调度原理</a><ol><li><a href=#调度对象>调度对象</a></li><li><a href=#goroutine-调度流程>Goroutine 调度流程</a></li><li><a href=#调度器生命周期>调度器生命周期</a></li><li><a href=#调度时机>调度时机</a></li><li><a href=#如何挑选下一个执行的-goroutine>如何挑选下一个执行的 Goroutine</a></li><li><a href=#goroutine-的调度方式>Goroutine 的调度方式</a><ol><li><a href=#基于协作的抢占式调度流程12-版本实现>基于协作的抢占式调度流程（1.2 版本实现）</a></li><li><a href=#基于信号的抢占式调度114版本实现>基于信号的抢占式调度（1.14版本实现）</a></li></ol></li></ol></li><li><a href=#work-staeling--hand-off>work staeling & hand off</a><ol><li><a href=#work-stealing-机制>work stealing 机制</a></li><li><a href=#hand-off-机制>hand off 机制</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E7%BC%96%E7%A8%8B/>编程</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/gmp-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/>GMP 调度模型</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2025/01/13</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 7 分钟</time></div></footer></div></header><section class=article-content><h2 id=历史背景>历史背景</h2><div class=table-wrapper><table><thead><tr><th style=text-align:center></th><th style=text-align:center>含义</th><th style=text-align:center>缺点</th></tr></thead><tbody><tr><td style=text-align:center>进程时代</td><td style=text-align:center>一个程序就是一个进程，所有进程严格按照时间执行</td><td style=text-align:center>进程阻塞十分损耗性能、只能串行执行任务</td></tr><tr><td style=text-align:center>线程时代</td><td style=text-align:center>一个进程阻塞，可以切换到其他进程</td><td style=text-align:center>上下文切换成本高、协程内存占用较高</td></tr><tr><td style=text-align:center>协程时代</td><td style=text-align:center>协程绑定线程，CPU 调度线程执行</td><td style=text-align:center>实现复杂，协程和线程的绑定依赖调度器算法</td></tr></tbody></table></div><h2 id=gmp-调度模型是什么>GMP 调度模型是什么</h2><p><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131539627.png loading=lazy alt=image-20250113153916514></p><p>G：<em>Goroutine</em>，是 Go 的用户级线程，每个 go 关键字都会创建一个 Goroutine。其数量理论上只受内存大小影响。</p><p>M：<em>Machine</em>，Go 对<strong>操作系统线程</strong>的封装，M在绑定有效的 P 后，进入一个调度循环，而调度循环的机制大致是从 P 的本地运行队列以及全局队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。<strong>M的数量有限制，默认数量限制是 10000</strong>，可以通过 debug.SetMaxThreads() 方法进行设置，如果有M空闲，那么就会回收或者睡眠。</p><p>P：<em>Processor</em>，<strong>虚拟处理器，M执行G所需要的资源和上下文，只有将 P 和 M 绑定，才能让 P 的 runq 中的 G 真正运行起来</strong>。P的数量受本机的CPU核数影响，可通过环境变量$GOMAXPROCS或在runtime.GOMAXPROCS()来设置，默认为CPU核心数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//src/runtime/runtime2.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>g</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>goid</span>  <span class=kt>int64</span> <span class=c1>// 唯一的goroutine的ID
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>sched</span> <span class=nx>gobuf</span> <span class=c1>// goroutine切换时，用于保存g的上下文
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>stack</span> <span class=nx>stack</span> <span class=c1>// 栈
</span></span></span><span class=line><span class=cl><span class=c1></span>  	<span class=nx>gopc</span>        <span class=c1>// pc of go statement that created this goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>startpc</span>    <span class=kt>uintptr</span> <span class=c1>// pc of goroutine function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>p</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>lock</span> <span class=nx>mutex</span>
</span></span><span class=line><span class=cl>    <span class=nx>id</span>          <span class=kt>int32</span>
</span></span><span class=line><span class=cl>    <span class=nx>status</span>      <span class=kt>uint32</span> <span class=c1>// one of pidle/prunning/...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Queue of runnable goroutines. Accessed without lock.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>runqhead</span> <span class=kt>uint32</span> <span class=c1>// 本地队列队头
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>runqtail</span> <span class=kt>uint32</span> <span class=c1>// 本地队列队尾
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>runq</span>     <span class=p>[</span><span class=mi>256</span><span class=p>]</span><span class=nx>guintptr</span> <span class=c1>// 本地队列，大小256的数组，数组往往会被都读入到缓存中，对缓存友好，效率较高
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>runnext</span> <span class=nx>guintptr</span> <span class=c1>// 下一个优先执行的goroutine（一定是最后生产出来的)，为了实现局部性原理，runnext中的G永远会被最先调度执行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>...</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>m</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>g0</span>            <span class=o>*</span><span class=nx>g</span>     
</span></span><span class=line><span class=cl>    <span class=c1>// 每个M都有一个自己的G0，不指向任何可执行的函数，在调度或系统调用时，M会切换到G0，使用G0的栈空间来调度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>curg</span>          <span class=o>*</span><span class=nx>g</span>    
</span></span><span class=line><span class=cl>    <span class=c1>// 当前正在执行的G
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>...</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>schedt</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=nx>runq</span>     <span class=nx>gQueue</span> <span class=c1>// 全局队列，链表（长度无限制）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>runqsize</span> <span class=kt>int32</span>  <span class=c1>// 全局队列长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=go-调度原理>Go 调度原理</h2><h3 id=调度对象>调度对象</h3><ul><li>G 的来源<ul><li>P 的 runnext（1 个 G）</li><li>P 的本地队列（数组，最多 256 个 G）</li><li>全局 G 队列（链表，G 数量无限制）</li><li>网络轮询器（存放网络调用阻塞的 G）</li></ul></li><li>P 的来源<ul><li>全局 P 队列（数组，GOMAXPROCS个P）</li></ul></li><li>M 的来源<ul><li>休眠线程队列（未绑定 P，长时间休眠会等待GC回收销毁）</li><li>运行线程（绑定 P，指向 P 中的 G）</li><li>自旋线程（绑定 P，指向 M 的 G0）</li></ul></li></ul><h3 id=goroutine-调度流程>Goroutine 调度流程</h3><p><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131542604.png loading=lazy alt=image-20250113154209545></p><p>上图是一个完整调度流程：</p><ol><li>通过 go func() 创建一个 <em>G</em></li><li>创建的 <em>G</em> 优先保存到本地队列 <em>P</em>，若本地 <em>P</em> 已满则进去全局队列</li><li>唤醒或者新建 <em>M</em> 执行任务，进入调度循环（4，5，6)</li><li><em>M</em> 依次会从本地队列 <em>P</em>，全局队列，其他本地队列 <em>P</em> 获取 <em>G</em></li><li><em>M</em> 调度和执行 <em>G</em><ul><li>如果 <em>M</em> 在执行 <em>G</em> 的过程发生<strong>系统调用阻塞</strong>（同步），会阻塞 <em>G</em> 和 <em>M</em>（操作系统限制），此时 <em>P</em> 会和当前 <em>M</em> 解绑，并寻找新的 <em>M</em>，如果没有空闲的 <em>M</em> 就会新建一个 <em>M</em> ，接管正在阻塞G所属的P，接着继续执行 P中其余的G，这种阻塞后释放P的方式称之为hand off。当<strong>系统调用结束</strong>后，这个G会尝试获取一个空闲的P执行，优先获取之前绑定的P，并放入到这个P的本地队列，如果获取不到P，那么这个线程M变成休眠状态，加入到空闲线程中，然后这个G会被放入到全局队列中。</li><li>如果M在执行G的过程发生网络IO等操作阻塞时（异步），阻塞G，<strong>不会阻塞M</strong>。M会寻找P中其它可执行的G继续执行，G会被网络轮询器network poller 接手，当阻塞的G恢复后，G1从network poller 被移回到P的 LRQ 中，重新进入可执行状态。异步情况下，通过调度，Go scheduler 成功地将 I/O 的任务转变成了 CPU 任务，或者说将内核级别的线程切换转变成了用户级别的 goroutine 切换，大大提高了效率。</li></ul></li><li><em>M</em> 执行完 <em>G</em> 后清理现场，重新进入调度循环（将 M 上运⾏的goroutine切换为G0，G0负责调度时协程的切换）</li></ol><h3 id=调度器生命周期>调度器生命周期</h3><p><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501132210897.png loading=lazy alt=image-20250113221048794></p><ul><li>M0：M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。</li><li>G0：G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</li></ul><h3 id=调度时机>调度时机</h3><ul><li>抢占式调度<ul><li>sysmon检测到协程运行过久(比如sleep，死循环)</li><li>切换到g0，进入调度循环</li></ul></li><li>主动调度<ul><li>新起一个协程和协程执行完毕触发调度循环</li><li>主动调用runtime.Gosched()切换到g0，进入调度循环</li><li>垃圾回收之后。stw之后，会重新选择g开始执行</li></ul></li><li>被动调度<ul><li>系统调用(比如文件IO)阻塞(同步)，阻塞G和M，P与M分离，将P交给其它M绑定，其它M执行P的剩余G</li><li>网络IO调用阻塞(异步) ，阻塞G，G移动到NetPoller，M执行P的剩余G</li><li>atomic/mutex/channel等阻塞(异步)，阻塞G，G移动到channel的等待队列中，M执行P的剩余G</li></ul></li></ul><h3 id=如何挑选下一个执行的-goroutine>如何挑选下一个执行的 Goroutine</h3><ol><li>每执行61次调度循环，从全局队列获取G，若有则直接返回</li><li>从P上的runnext看一下是否有G，若有则直接返回</li><li>从P上的本地队列看一下是否有G，若有则直接返回</li><li>上面都没查找到时，则去全局队列、网络轮询器查找或者从其他Р中窃取,t一直阻塞直到获取到一个可用 的G为止</li></ol><p>netpoller中拿到的G是 <code>_Gwaiting状态</code>（存放的是因为网络IO被阻塞的G)，从其它地方拿到的是<code>_Grunnable状态</code></p><h3 id=goroutine-的调度方式>Goroutine 的调度方式</h3><h4 id=基于协作的抢占式调度流程12-版本实现>基于协作的抢占式调度流程（1.2 版本实现）</h4><ol><li>编译器会在调用函数前插入runtime.morestack，让运行时有机会在这段代码中检查是否需要执行抢占
调度</li><li>Go语言运行时会在垃圾回收暂停程序、系统监控发现Goroutine运行超过10ms，那么会在这个协程设置
一个抢占标记</li><li>当发生函数调用时，可能会执行编译器插入的runtime.morestack，它调用的runtime.newstack会检查抢
占标记，如果有抢占标记就会触发抢占让出cpu，切到调度主协程里</li></ol><p>只能局部解决问题，只在有函数调用的地方才能插入“抢占”代码（埋点），对于没有函数调用而是纯算法循环计算的 G，Go 调度器依然无法抢占。</p><h4 id=基于信号的抢占式调度114版本实现>基于信号的抢占式调度（1.14版本实现）</h4><ol><li>M注册一个SIGURG信号的处理函数:sighandler</li><li>sysmon启动后会间隔性的进行监控，最长间隔10ms，最短间隔20us。如果发现某协程独占
P超过10ms，会给M发送抢占信号</li><li>M收到信号后，内核执行sighandler函数把当前协程的状态从_Grunning正在执行改成_Grunnable可执
行，把抢占的协程放到全局队列里，M继续寻找其他goroutine来运行</li><li>被抢占的G再次调度过来执行时，会继续原来的执行流</li></ol><p>抢占分为<code>_Prunning</code>和<code>_Psyscall</code></p><ul><li><code>_Psyscall</code>抢占通常是由于阻塞性系统调用引起的，比如磁盘io、cgo。</li><li><code>_Prunning</code>抢占通常是由于一些类似死循环的计算逻辑引起的。</li></ul><h2 id=work-staeling--hand-off>work staeling & hand off</h2><h3 id=work-stealing-机制>work stealing 机制</h3><p>当线程M⽆可运⾏的G时，尝试从其他M绑定的 P （每次选择的 P 不一定相同）偷取 G（当前 P 中一半的 G），减少空转，提高了线程利用率。</p><p><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131639460.png loading=lazy alt=image-20250113163923392></p><h3 id=hand-off-机制>hand off 机制</h3><p>也称为 P 分离机制，当线程 M 因为 G 进行的系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的 M 执行，也提高了线程利用率。</p><p><img src=https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131646778.png loading=lazy alt=image-20250113164624713></p></section><footer class=article-footer><section class=article-tags><a href=/tags/golang/>Golang</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/slice/><div class=article-details><h2 class=article-title>Slice</h2></div></a></article><article><a href=/p/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-gc/><div class=article-details><h2 class=article-title>垃圾回收 GC</h2></div></a></article><article><a href=/p/goroutine/><div class=article-details><h2 class=article-title>Goroutine</h2></div></a></article><article><a href=/p/redis%E6%8C%81%E4%B9%85%E5%8C%96/><div class=article-details><h2 class=article-title>Redis持久化</h2></div></a></article><article><a href=/p/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/><div class=article-details><h2 class=article-title>Redis 数据类型</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2024 -
2025 Ting</section><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span>
<script language=javascript>var now=new Date;function createtime(){now.setTime(now.getTime()+250);var e=new Date("2024/12/02 00:00:00");days=(now-e)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-e)/1e3/60/60-24*dnum,hnum=Math.floor(hours),String(hnum).length==1&&(hnum="0"+hnum),minutes=(now-e)/1e3/60-24*60*dnum-60*hnum,mnum=Math.floor(minutes),String(mnum).length==1&&(mnum="0"+mnum),seconds=(now-e)/1e3-24*60*60*dnum-60*60*hnum-60*mnum,snum=Math.round(seconds),String(snum).length==1&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已稳定运行"+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.29.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script src=https://npm.elemecdn.com/nprogress@0.2.0/nprogress.js crossorigin=anonymous></script><link rel=stylesheet href=https://npm.elemecdn.com/nprogress@0.2.0/nprogress.css crossorigin=anonymous><script>NProgress.start(),document.addEventListener("readystatechange",()=>{document.readyState==="interactive"&&NProgress.inc(.8),document.readyState==="complete"&&NProgress.done()})</script></body></html>