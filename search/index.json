[{"content":"为什么需要 Goroutine 简单一句话，Goroutine 相比线程拥有更优越的开销性能。\n这里先简单介绍下进程、线程、协程：\n进程：操作系统创建、资源分配的基本单位、同一个进程内的线程会共享资源。 线程：操作系统创建、CPU 调度的基本单位、有独立的堆栈空间 协程：可通过用户程序创建 有栈协程：golang 无栈协程：c++，rust 等 Goroutine 就是一个用户级线程，相比传统线程更加轻量（传统协程 1 MB，Goroutine 约 2 KB）。其不涉及内核态的切换，因此 golang 的并发性能很好。\n如何关闭 Goroutine 关闭 channel\n1 2 // 根据第二个参数进行判别，当关闭 channel 时，根据其返回结果跳出 msg, ok := \u0026lt;-ch 定期轮询 channel\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func main() { ch := make(chan string, 6) done := make(chan struct{}) go func() { for { select { case ch \u0026lt;- \u0026#34;hello world\u0026#34;: case \u0026lt;-done: close(ch) return } } }() go func() { time.Sleep(3 * time.Second) done \u0026lt;- struct{}{} }() for i := range ch { fmt.Println(\u0026#34;接收到的值：\u0026#34;, i) } fmt.Println(\u0026#34;over\u0026#34;) } 变量 done 作为 channel 类型，用作信号量处理 Goroutine 的关闭。for-loop 结合 select 进行监听，处理完业务之后才会调用 close 关闭 channel。\n使用 context\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func main() { ch := make(chan struct{}) ctx, cancel := context.WithCancel(context.Background()) go func(ctx context.Context) { for { select { case \u0026lt;-ctx.Done(): ch \u0026lt;- struct{}{} return default: fmt.Println(\u0026#34;hello world\u0026#34;) } time.Sleep(1 * time.Second) } }(ctx) go func() { time.Sleep(4 * time.Second) cancel() }() \u0026lt;-ch fmt.Println(\u0026#34;over\u0026#34;) } 在 context 中，可以借助 ctx.Done 获取一个只读的 channel，可用来识别当前 channel 是否已被关闭。context 对于跨 Goroutine 控制灵活，可以调动 context.WithTimeout 根据时间，或者主动调用 cancel 方法手动关闭。\n如何实现并行 Goroutine 通过设置最大的可同时使用的 CPU 核心数\n1 2 // 设置并行 Goroutine 数量为 2 runtime.GOMAXPROCS(2) 为什么不能大量使用 Goroutine 虽然 Goroutine 的初始栈（自动扩容）很小，但是大部分业务需要更多的栈空间，而频繁的扩容需要很大的成本。 Golang 的 GMP 调度模型中的 M 和 P 是有数量限制的，大量的 Goroutine 会导致过长的调度队列，从而影响性能。 过多的 Goroutine 还会导致频繁的 GC，影响性能。 Goroutine A 能否停止另一个 Goroutine 不能。Goroutine 只有自己主动退出，不能被外界的 Goroutine 关闭。\n父 Goroutine 退出，子 Goroutine 一定会退出嘛 当父 Goroutine 为 main 时，所有的子 Goroutine 都会跟着父 Goroutine 退出 若父 Goroutine 不为 main 时，子 Goroutine 不会跟着父 Goroutine 退出 多个协程交替打印奇偶数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { // 创建两个channel用于同步 even := make(chan struct{}) odd := make(chan struct{}) // 创建WaitGroup等待所有协程完成 var wg sync.WaitGroup wg.Add(2) // 打印偶数的协程 go func() { defer wg.Done() for i := 2; i \u0026lt;= 10; i += 2 { \u0026lt;-even // 等待偶数信号 fmt.Printf(\u0026#34;偶数: %d\\n\u0026#34;, i) odd \u0026lt;- struct{}{} // 发送奇数信号 } // 最后一次打印完需要再消费一次even channel,避免死锁 \u0026lt;-even }() // 打印奇数的协程 go func() { defer wg.Done() for i := 1; i \u0026lt;= 9; i += 2 { fmt.Printf(\u0026#34;奇数: %d\\n\u0026#34;, i) even \u0026lt;- struct{}{} // 发送偶数信号 \u0026lt;-odd // 等待奇数信号 } // 最后发送一次信号给偶数协程,让其能够退出 even \u0026lt;- struct{}{} }() // 等待所有协程完成 wg.Wait() // 关闭channel close(even) close(odd) } ","date":"2025-01-12T16:55:26+08:00","permalink":"https://the-oone.github.io/p/goroutine/","title":"Goroutine"},{"content":"String String 的底层数据结构是 int 和 SDS（Simple Dynamic String），相比 C 的原生字符串，增加了以下功能\n保存二进制文件 获取字符串长度的时间复杂度是 O(1) SDS API 内存安全，保证不会造成缓冲区溢出 内部编码 int，若字符串保存的是整数值，并且可以转换为 long，那么该字符串对象的编码被设置为 int。\nembstr，若字符串长度小于等于 44 字节（博主测试环境为 Redis 7.4.1），那么使用 embstr 编码，一次内存分配。只读，修改内容需先转换 raw 编码。\nraw，若字符串长度大于 44 字节，那么使用 raw 编码，两次内存分配。\n常用指令 SET\n设置 key 为字符串值。 如果 key 已有值，无论其类型如何，都会被覆盖。 在 SET 操作成功后，之前与键值相关的任何生存时间都将被丢弃。\n1 2 SET key value [NX | XX] [GET] [EX seconds | PX milliseconds | EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL] EX \u0026ndash; 设置指定的过期时间，以秒（正整数）为单位。 PX \u0026ndash; 设置指定的过期时间，以毫秒（正整数）为单位。 EXAT \u0026ndash; 设置指定的密钥过期时间，以秒（正整数）为单位。 PXAT \u0026ndash; 设置密钥过期的 Unix 时间，以毫秒为单位（正整数）。 NX \u0026ndash; 当且仅当 key 不存在时才设置。 XX \u0026ndash; 无论如何都会设置 key。 KEEPTTL \u0026ndash; 继承上一个 key 的有效时间。 GET \u0026ndash; 返回存储在密钥中的旧字符串，如果密钥不存在，则返回 nil。 如果键值不是字符串，会返回错误并中止 SET。 MSET / MSETNX\n将给定的键设置为各自的值。 两者都是原子式的，因此所有给定键都会被一次性设置。\n1 2 MSET key value [key value ...] MSETNX key value [key value ...] # key 必须均不存在 INCR / INCRBY\n对 key 中存储数字进行加法操作，如果键不存在，则在执行操作前将其设置为 0。\n1 2 INCR key # 将存储在键上的数字递增 1。 INCRBY key increment # 将存储在键上的数字递增 increment DECR / DECRBY\n对 key 中存储数字进行减法操作，如果键不存在，则在执行操作前将其设置为 0。\n1 2 DECR key # 将存储在键上的数字递减 1。 DECRBY key increment # 将存储在键上的数字递减 increment GET / MGET\n获取 key 的值。 如果键不存在，则返回特殊值 nil。\n1 2 GET key MGET key [key ...] 应用场景 缓存对象\n计数器\n分布式锁\n若 key 不存在，则显示插入成功，表示加锁成功\n若 key 存在，则显示插入失败，表示加锁失败\n需要配合 Lua 脚本实现原子性\n共享 Session 信息\nList List 是简单的字符串列表（按照插入顺序排序），可以从头部或者尾部向 List 添加元素，链表最大长度为 $2^{32}-1$\n内部实现 3.2 版本之前由双向链表或压缩链表实现。 3.2 版本之后由 QuickList 实现。其是多个节点（压缩列表）组成的双向链表，每个元素可以是一个整数或一个字节数组。 常用指令 LPUSH / RPUSH\n将所有指定值插入存储在 key 处的列表头部。 如果 key 不存在，则在执行推送操作前将其创建为空列表。 如果 key 持有的值不是 list，则会返回错误信息。\n1 LPUSH/RPUSH key element [element ...] LPUSH 命令\tRPUSH 命令 LPUSHX / RPUSHX\n仅在 key 已存在并持有一个列表的情况下，在 key 所在列表的首部插入指定值。 如果 key 不存在，则不会执行任何操作。\n1 LPUSHX/RPUSHX key element [element ...] LPOP / RPOP\n删除并返回存储在 key 处的列表的 最初/最后 一个元素。 默认情况下，该命令从列表 头部/尾部 弹出一个元素。 如果提供了可选的 count 参数，则根据列表的长度，回复最多包含 count 个元素。\n1 LPOP/RPOP key [count] BLPOP / BRPOP\nBLPOP/BRPOP 是一种阻塞列表弹出原语。 它是 LPOP/RPOP 的阻塞版本，因为当没有元素从任何给定列表中弹出时，它会阻塞连接。 元素会从第一个非空列表的 头部/尾部 弹出，并按照给定键的顺序进行检查。\n1 BLPOP/RLPOP key [key ...] timeout LINDEX\n返回存储在 key 中的列表中位于 index 索引处的元素。 索引以 0 为单位，因此 0 表示第一个元素，1 表示第二个元素，以此类推。 负指数可用于指定从列表尾部开始的元素。 这里，-1 表示最后一个元素，-2 表示倒数第二个元素，以此类推。\n1 LINDEX key index LLEN\n返回存储在 key 处的 list 的长度。 如果 key 不存在，则将其解释为空列表，并返回 0。 如果 key 中存储的值不是 list，则会返回错误信息。\n1 LLEN key LRANGE\n返回存储在 key 处的列表的指定元素。 偏移量 start 和 stop 是基于 0 的索引，0 代表列表的第一个元素（列表的头），1 代表下一个元素，以此类推。 这些偏移量也可以是负数，表示从列表的末尾开始的偏移量。 例如，-1 是列表的最后一个元素，-2 是倒数第二个元素，以此类推。\n1 LRANGE key start stop LREM\n从存储在 key 处的列表中移除与元素相同的元素的第一个出现次数。 计数参数对操作的影响如下：count \u0026gt; 0：删除从头部移到尾部的与元素相同的元素。 count \u0026lt; 0：删除从尾部移到头部的与元素相同的元素。 例如，LREM list -2 \u0026ldquo;hello \u0026ldquo;将删除存储在 list 中的 \u0026ldquo;hello \u0026ldquo;的最后两次出现。 请注意，不存在的键会被当作空 list 处理。\n1 LREM key count element LTRIM\n裁剪现有列表，使其只包含指定范围的元素。 start 和 stop 都是基于 0 的索引，其中 0 代表列表的第一个元素（头部），1 代表下一个元素，依此类推。 例如，LTRIM foobar 0 2 将修改存储在 foobar 处的列表，使其只保留列表的前三个元素： start 和 end 也可以是负数，表示与列表末尾的偏移量，其中 -1 表示列表的最后一个元素，-2 表示倒数第二个元素，依此类推。 超出范围的索引不会产生错误：如果 start 大于列表末尾，或 start \u0026gt; end，结果将是一个空列表（导致键被移除）。 如果 end 大于列表末尾，Redis 会将其视为列表的最后一个元素。\n1 LTRIM key start stop LSET\n将索引处的列表元素设置为指定值。\n1 LSET key index element LINSERT\n将元素插入存储在 key 处的列表中的参考值 pivot 之前或之后。 如果 key 不存在，则视为空列表，不执行任何操作。 如果 key 存在但不包含列表值，则返回错误信息。\n1 LINSERT key \u0026lt;BEFORE | AFTER\u0026gt; pivot element BRPOPLPUSH\nBRPOPLPUSH 是 RPOPLPUSH 的阻塞变体。 当源代码包含元素时，该命令的行为与 RPOPLPUSH 完全相同。 在 MULTI/EXEC 块内使用时，该命令的行为与 RPOPLPUSH 完全相同。 当源为空时，Redis 会阻塞连接，直到有其他客户端向其推送或超时。 如果超时为零，则会无限期阻塞。\n1 BRPOPLPUSH source destination timeout 应用场景 消息队列 消息保存：LPUSH + RPOP / RPUSH+LPOP 实现消息队列（使用 BRPOP 命令进行阻塞式读取，减少消费者性能损失） 重复消息处理：生产者实现全局唯一 ID 消息可靠性：BRPOPLPUSH（使得消费者从一个 List 中读取消息，同时 Redis 还会把消息再插入到另一个 List 留存） List 不支持多个消费者消费同一条信息 Hash Hash 是一个 key-value 集合，\n内部实现 listpack\thashtable 如果 Hash 元素小于 512（默认） 个，所有值小于 64 字节（默认）时，Redis 会使用 listpack 作为底层数据结构。 剩余情况，Redis 会使用 hashtable实现 常用命令 HSET / HSETNX\n将指定字段的值设置为存储在 key 的哈希值中各自的值。 HSET 会覆盖哈希值中存在的指定字段的值，HSETNX 对于已存在的字段操作无效。 如果 key 不存在，则会创建一个新的散列键。\n1 2 HSET key field value [field value ...] HSETNX key field value HGET / HMGET / HGETALL\nHGET/HMGET 返回键存储的哈希值中与字段相关的值。 对于散列中不存在的每个字段，都会返回一个 nil 值。 由于不存在的键被视为空哈希值，因此针对不存在的键运行 HMGET 将返回一个 nil 值列表。\nHGETALL 返回存储在 key 处的哈希值的所有字段和值。\n1 2 3 HGET key field HMGET key field [field ...] HGETALL key HDEL\n从存储在 key 中的哈希值中删除指定字段。 不存在于散列中的指定字段将被忽略。 如果没有字段，则删除散列。 如果键不存在，则将其视为空散列，此命令返回 0。\n1 HDEL key field [field ...] HLEN\n返回存储在 key 中的哈希值所包含字段的数量。\n1 HLEN key HEXISTS\n如果字段是存储在 key 处的哈希值中的现有字段，则返回 1，否则返回 0。\n1 HEXISTS key field HKEYS / HVALS\nHKEYS 返回存储在 key 处的哈希值中的所有字段名。\nHVALS 返回键存储的哈希值中的所有值。\n1 2 HKEYS key HVALS key HINCRBY / HINCRBYFLOAT\nHINCRBY 按增量递增存储在 key 的哈希值中的字段数字。 如果 key 不存在，则会创建一个新的哈希值键。 如果字段不存在，则在执行操作前将其值设置为 0。\nHINCRBYFLOAT 按指定增量递增存储在键值处的散列指定字段，该字段代表一个浮点数。 如果增量为负值，结果是哈希字段值递减而不是递增。 如果字段不存在，则在执行操作前将其设置为 0。\n1 2 HINCRBY key field increment HINCRBYFLOAT key field increment 应用场景 缓存对象 (key，field，value) 对应 (对象，属性，值) 购物车 添加商品：HSET cart:{user_id}{goods_id} 1 增加数量：HINCRBY cart:{user_id}{goods_id} 2 商品总数：HLEN cart:{user_id} 删除商品：HDEL cart:{user_id} {goods_id} 获取所有商品：HGETALL cart:{usert_id} Set Set 是一个集合（最多支持存储 $2^{32}-1$ 个元素），其中元素无序、唯一。除了支持集合内的增删改查，还支持多个集合交集、并集、差集。\n内部实现 如果集合元素都是整数，并且元素个数小于 512（默认），Redis 会使用 整数集合作为底层数据结构。 其他情况，Redis 会使用 listpack 作为底层数据结构 intset\tlistpack 常用命令 SADD\n将指定的成员添加到存储在 key 处的集合中。 如果指定的成员已经是这个集合的成员，则会被忽略。 如果 key 不存在，则会先创建一个新集合，然后再添加指定的成员。 如果存储在 key 中的值不是一个集合，则会返回错误信息。\n1 SADD key member [member ...] SREM\n从存储在 key 处的集合中删除指定的成员。 不属于此集合的指定成员将被忽略。 如果 key 不存在，则将其视为空集，此命令返回 0。\n1 SREM key member [member ...] SMEMBERS\n返回存储在 key 处的集合值的所有成员。\n1 SMEMBERS key SISMEMBER\n返回成员是否是存储在 key 中的集合的成员。\n1 SISMEMBER key member SCARD\n返回存储在 key 处的集合的元素个数。\n1 SCARD key SRANDMEMBER / SPOP\nSRANDMEMBER 将从存储在 key 处的集合值中随机返回 count 个元素，元素不从 key 中删除。\nSPOP 将从存储在 key 处的集合值中随机返回 count 个元素，元素从 key 中删除。\n1 2 SRANDMEMBER key [count] SPOP key [count] SMOVE\n将成员从源集合移动到目标集合。 该操作是原子操作。 如果源集合不存在或不包含指定元素，则不执行任何操作，并返回 0。 否则，该元素将从源集合中删除，并添加到目标集合中。 如果指定的元素已存在于目标集合中，则只会从源集合中移除。 如果源集合或目标集合中不存在集合值，则会返回错误信息。\n1 SMOVE source destination member SINTER / SINTERSTORE\nSINTER 返回所有给定集合的交集所产生的集合的成员。\nSINTERSTORE 该命令等同于 SINTER，但不是返回结果集，而是将其存储在目的地中。 如果目的地已经存在，则会被覆盖。\n1 2 SINTER key [key ...] SINTERSTORE destination key [key ...] 应用场景 点赞（元素唯一） 共同好友（集合运算） 数据量较大时，可以让从库进行集合运算，将结果返回给客户端，防止 Redis 阻塞。 抽奖（元素唯一，去重） Zset Zset 相较于 Set 多了个排序属性 score，每个存储元素相当于两个值组成，一个是有序集合的元素值，一个是排序值。\n内部实现 若 Zset 中元素小于 128 个，且每个元素小于 64 字节，Redis 使用 listpack 作为底层数据结构。 剩余情况，Redis 会使用 listpack\tskiplist 常用命令 ZADD\n将具有指定分数的所有指定成员添加到存储在 key 处的排序集合中。 可以指定多个分数/成员对。 如果指定的成员已经是排序集合的成员，则会更新得分，并将元素重新插入正确的位置，以确保排序正确。 如果 key 不存在，则会创建一个新的排序集合，并将指定的成员作为唯一成员，就像排序集合为空一样。 如果键存在，但没有排序集，则会返回错误信息。 分数值应是双精度浮点数的字符串表示。 +inf 和 -inf 值也是有效值。\n1 ZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member ...] XX: 只更新已存在的元素，不添加新元素。 NX: 只添加新元素，不更新已存在的元素。 LT: 只在新分数小于当前分数时更新现有元素。此标记不会阻止添加新元素。 GT: 仅在新分数大于当前分数时更新现有元素。 此标记不会阻止添加新元素。 CH: 将返回值从增加的新元素数量修改为改变的元素总数（CH 是 changed 的缩写）。 更改的元素是指新增的元素和已存在的元素，这些元素的分值已被更新。 因此，命令行中指定的元素如果得分与过去相同，则不计算在内。 注意：通常情况下，ZADD 的返回值只计算新增元素的数量。 INCR: 指定该选项时，ZADD 的作用与 ZINCRBY 类似。 在这种模式下，只能指定一个分数元素对。 ZREM\n从存储在 key 中的排序集合中删除指定的成员。 如果 key 存在但没有排序集，则会返回错误信息。\n1 ZREM key member [member ...] ZSCORE\n返回排序集合中 key 处成员的得分。 如果排序集合中不存在成员或 key 不存在，则返回 nil。\n1 ZSCORE key member ZCARD\n返回存储在 key 处的排序集的元素个数。\n1 ZCARD key ZINCRBY\n用增量递增键值存储的排序集合中成员的得分。 如果成员不存在于排序集合中，则会以增量作为其得分（就像它之前的得分是 0.0）。 如果 key 不存在，则会创建一个以指定成员为唯一成员的新排序集。 如果 key 存在但不包含排序集，则会返回错误信息。 分数值应是数值的字符串表示，并接受双精度浮点数。 可以提供一个负值来递减分数。\n1 ZINCRBY key increment member ZRANGE\n返回存储在 key 中的排序集合中元素的指定范围。 ZRANGE 可以执行不同类型的范围查询：按索引（秩）、按分数或按词典顺序。\n默认情况下，该命令执行索引范围查询。 start 和 stop 参数代表基于零的索引，其中 0 代表第一个元素。 这些参数指定了一个包含范围，例如，ZRANGE myzset 0 1 将同时返回排序集的第一个和第二个元素。 索引也可以是负数，表示从排序集末尾开始的偏移量，-1 表示排序集的最后一个元素。\n当提供 BYSCORE 选项时，命令的行为与 ZRANGEBYSCORE 类似，返回排序集中分数等于或介于 start 和 stop 之间的元素范围。\n使用 REV 选项会反转排序集，索引 0 将作为得分最高的元素。\n当使用 BYLEX 选项时，命令的行为与 ZRANGEBYLEX 类似，并返回排序集合中 start 和 stop 之间的元素范围。 请注意，词典排序依赖于所有元素具有相同的分数。 有效的 start 和 stop 必须以 ( 或 [ 开头，以便分别指定范围区间是排他的还是包含的。\n1 ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES] ZUNIONSTORE / ZDIFFSTORE\n1 2 ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE \u0026lt;SUM | MIN | MAX\u0026gt;] # 并集 ZDIFFSTORE destination numkeys key [key ...] # 第一个集合和之后集合的差集 应用场景 排行榜（有序唯一）\n电话、姓名排序\nBitMap BitMap 是一串连续的二进制数组，可以通过偏移量定位元素，适合数据量大且使用二值统计的场景。\n内部实现 String 类型是会保存为二进制的字节数组\n常用命令 SETBIT\n设置或清除存储在 key 处字符串值偏移量的位。 位的设置或清除取决于值，值可以是 0 或 1。当 key 不存在时，将创建一个新的字符串值。 字符串的增长是为了确保它能容纳偏移量处的位。 偏移参数必须大于或等于 0，且小于 2^32（这将位图限制在 512MB）。\n1 SETBIT key offset value GETBIT\n返回存储在 key 处的字符串值中偏移量处的比特值。\n1 GETBIT key offset BITCOUNT\n获取指定范围内值为 1 的个数，默认以字节为单位。\n1 BITCOUNT key [start end [BYTE | BIT]] BITOP\n在多个键（包含字符串值）之间执行位操作，并将结果存储到目标键中。\n1 BITOP \u0026lt;AND | OR | XOR | NOT\u0026gt; destkey key [key ...] 应用场景 签到统计\n判断用户登陆态\nHyperLogLog HyperLogLog 是一种用于统计基数的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。HyperLogLog 的统计规则基于概率完成，标准误算率为 0.81%。\n内部实现 ^ - ^\n常见命令 PFADD\n将所有元素参数添加到存储在作为第一个参数指定的变量名下的 HyperLogLog 中。\n1 PFADD key [element [element ...]] PFCOUNT\n使用单键调用时，返回存储在指定变量中的 HyperLogLog 的基数估算值，如果变量不存在，则返回 0。 使用多键调用时，通过内部合并存储在所提供键中的 HyperLogLog 成一个临时的 HyperLogLog，返回所传递的 HyperLogLog 联合的基数估算值。\n1 PFCOUNT key [key ...] PFMERGE\n将多个 HyperLogLog 值合并为一个 HyperLogLog 。如果目标 HyperLogLog 不存在（默认为空 HyperLogLog），则创建。 如果存在，则将其视为源集之一。\n1 PFMERGE destkey [sourcekey [sourcekey ...]] 应用场景 网页用户访问(UV)计数 GEO 主要用于存储地理信息\n内部实现 底层复用 Zset，使用 GeoHash 实现了经纬度到 Zset 中元素的权重分数的转换，关键机制是 二维地图区间划分 和 区间编码 。地理位置转换为经纬度后，使用区间编码标识，并将编码值作为 Zset 的权重分数。\n常用命令 GEOADD\n存储指定的地理位置信息，将经度，纬度，位置名称添加到指定的 key 中\n1 GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...] XX: 只更新已存在的元素，从不添加元素。 NX: 不更新已存在的元素。 CH: 不更新已存在的元素。 总是添加新元素： 将返回值从添加的新元素数修改为更改的元素总数。 更改的元素是指新增的元素和坐标已更新的已有元素。 GEOPOS\n返回关键字处排序集所代表的地理空间索引中所有指定成员的位置（经度、纬度）。\n1 GEOPOS key [member [member ...]] GEODIST\n返回排序集所代表的地理空间索引中两个成员之间的距离。 单位必须是以下之一，默认为米：m 表示米。 km 表示公里。 mi 表示英里。 ft 表示英尺。\n1 GEODIST key member1 member2 [M | KM | FT | MI] GEORADIUS\n返回使用 GEOADD 填充了地理空间信息的排序集合的成员，这些成员位于以中心位置和距中心最大距离（半径）指定的区域边界内。\n1 2 3 GEORADIUS key longitude latitude radius \u0026lt;M | KM | FT | MI\u0026gt; [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC | DESC] [STORE key | STOREDIST key] 应用场景 位置信息服务 Stream 专为消息队列设计的数据类型，支持消息持久化、自动生成全局唯一 ID、支持 ACK 确认消息、支持消费组模式\n内部实现 ^ - ^\n常见命令 XADD\n将指定的数据流条目添加到指定键的数据流中。 如果键值不存在，则使用流的值创建键值。 可以使用 NOMKSTREAM 选项禁用创建数据流键。\n1 2 XADD key [NOMKSTREAM] [\u0026lt;MAXLEN | MINID\u0026gt; [= | ~] threshold [LIMIT count]] \u0026lt;* | id\u0026gt; field value [field value ...] XLEN\n返回数据流中的条目数。 如果指定的键不存在，命令将返回 0。\n1 XLEN key XREAD / XREADGROUP\nXREAD 从一个或多个数据流中读取数据，只返回 ID 大于调用者报告的最后接收 ID 的条目。 该命令有一个选项，可在项目不可用时阻塞。\nXREADGROUP 命令是 XREAD 命令的一个特殊版本，支持消费者组。\n1 2 XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...] XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] id [id ...] XDEL\n从数据流中删除指定条目，并返回已删除条目的数量。\n1 XDEL key id [id ...] XRANGE\n该命令返回与给定 ID 范围匹配的数据流条目。\n1 XRANGE key start end [COUNT count] XPENDING / XACK\nXPENDING 查询每个消费组内所有消费者 已读取、尚未确认 的消息。\nXACK 向消息队列确认消息处理已完成\n1 2 XPENDING key group [[IDLE min-idle-time] start end count [consumer]] XACK key group id [id ...] ","date":"2024-12-18T21:30:01+08:00","permalink":"https://the-oone.github.io/p/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"Redis数据类型"},{"content":"Redis 简介 Redis（REmote DIctionary Serve）是一个开源的基于内存的 Key-Value 数据库，常常用于缓存、消息队列、分布式锁等场景。除此之外，Redis 还支持事务、持久化、Lua 脚本、集群（主从、哨兵、切片）、发布/订阅等等。\nRedis 对比 Memcached Redis Memcached 数据类型 String、Hash、Lits、Set、ZSet、Bitmap\nHyperLogLog、GEO、Stream String、Integer、ByteArray、List、Set 持久化 原生支持（AOF、RDB） 原生不支持 集群 原生支持（主从复制、哨兵、切片） 原生不支持 其他功能 发布/订阅、Lua 脚本、事务等等 —— Redis 使用场景 相关资料 Redis 官网\nRedis Github 地址\nRedis 在线服务\nRedis 中文文档\n","date":"2024-12-16T20:29:41+08:00","permalink":"https://the-oone.github.io/p/redis%E7%AE%80%E4%BB%8B/","title":"Redis简介"},{"content":"需求 目前负责一个 Web 项目，该项目前后端是分离的，但是只给了一个端口和服务器进行远程连接。所以问题就出现了，前端需要一个端口用于用户访问，而后端也需要一个端口来和前端进行数据传输，那么就需要至少两个端口才能开启这个 Web 服务。为了解决这个问题，在网上查找资料发现 nginx 可以通过反向代理来实现同一个端口访问不同的服务。话不多说，直接开搞！\n方案 Nginx 安装 博主的服务器是 Ubuntu 22.04.4 LTS ，首先更新一下系统软件包\n1 2 3 4 sudo apt update # 更新软件包列表 sudo apt upgrade # 更新软件包 sudo apt install nginx # 安装 nginx 输入 nginx -v 命令，如果能看到 nginx 的版本号，则安装成功\n安装好之后 Nginx一般会自动打开，如果没有可以使用命令手动打开。（注意如果你开启了防火墙，则需要配置防火墙允许 Nginx可以使用的端口的传输流量。）\n1 2 3 4 5 6 sudo systemctl status nginx # 查看 nginx 状态 sudo systemctl start nginx # 启动 nginx sudo systemctl stop nginx # 关闭 nginx sudo systemctl reload nginx # 重新加载配置文件（不中断服务） sudo systemctl restart nginx # 重启 nginx Nginx 配置 进入你的 Nginx 配置文件，博主是在 /etc/nginx/sites-available/default 文件中修改的配置。\n1 sudo vim /etc/nginx/sites-available/default 以下是博主的配置，前端服务配置在 / 根路径下，后端配置在 /api/ 路径下。这样我们就可以通过 http://127.0.0.1/ 访问前端服务，http://127.0.0.1/api/ 访问后端服务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 server { listen 80; # 监听端口 server_name 127.0.0.1; # 此处填写你的项目的域名或者 IP location / { # 默认访问路径 proxy_pass http://127.0.0.1:5173; # 该项目对外暴露的接口路径 proxy_set_header Host $host; proxy_set_header X-realIP $remote_addr; proxy_set_header X-Forwarded-for $proxy_add_x_forwarded_for; } location /api/ { proxy_pass http://127.0.0.1:5000; # 该项目对外暴露的接口路径 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } 最终实现效果如下：\n","date":"2024-12-07T20:20:34+08:00","permalink":"https://the-oone.github.io/p/nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/","title":"Nginx 反向代理"},{"content":"图床 博客除了文字之外还有图片，但是由于图片的位置是在本地上，因此当上传至网站上时是没办法访问到这些图片的。而图床就可以解决这个问题，其本质上就是一个可以被互联网访问的存放图片的空间。\n大致可以分为下面几类：\n公共图床：只需要上传图片即可，网站会返回给你图片的 URL，例如 Hello图床 。简单方便，但是不太稳定，并且有一些上传限制。\n代码托管平台：类似于 GitHub，Gitee 这种。\n云服务器：类似于阿里云、腾讯云、华为云这些。\n本来想省心直接使用阿里云服务器，看了眼价格之后，默默放弃了（学生党伤不起~）。最后还是选择了 GitHub 作为图床，除了在国内访问不便之外其他方面都还好。\nGitHub 搭建图床 首先需要一个 GitHub 仓库，仓库名随意，设置为 public，建议加上 README 文件，这样默认分支就会变成 main。\n之后需要申请 Token，前往 settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens 创建一个 token(classic)\n勾选上 repo，如果要考虑安全的话，Token 有效期不要设置永不过期。还有就是注意这个 Token 只有在刚申请的时候才能看到，注意保存，否则只能重新申请一个新的。\nPicGo 这时候我们就可以将图片上传到仓库了，但是每次都需要手动 Git 上传到仓库这样太麻烦了，可以使用 PicGo 这款图片上传和管理工具。点击进入其 GitHub 页面，点击下图位置进去下载页面，选择一个版本下载好。\n之后我们需要将我们的图床设置为 GitHub，图床设置 -\u0026gt; GitHub ，填写好你的配置点击确定即可。\n设定仓库名：你的 GitHub 用户名 / 你的图床仓库名 设定分支名：上传到仓库的那个分支 设定 Token：就是上面我们生成的那个 Token。 设定存储路径：你要将上传的文件放到仓库的那个文件夹下（例如存放在根目录下的 static 目录下，填写 static/）。若存储在根目录下，则不填。 设定自定义域名：https://cdn.jsdelivr.net/gh/user/repo@brach，如果是上传到默认分支，则去掉 @ 及其之后的内容。（这里博主使用了 jsDelivr 来进行加速优化网站打开速度） Typora 实现 CV 自动上传 博主使用的 Typora 支持 PicGo，可以实现在文章内插入图片自动上传至图床。前往 文件 -\u0026gt; 偏好设置\u0026hellip; -\u0026gt; 图像。\n按照图示全部设置完成之后，点击 验证图片上传选项 ，可以看到上传成功\n","date":"2024-12-07T08:45:20+08:00","permalink":"https://the-oone.github.io/p/github-picgo-%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE/","title":"GitHub ➕ PicGo 图床配置"},{"content":"准备工作 Hugo\n从 Hugo GitHub 仓库选择合适版本的下载，从下图中所指示位置即可进入下载页面\n选择与你机器对应的版本（我这里选择 0.139.3 版本，windows 系统，对应文件为 hugo_extended_withdeploy_0.139.3_windows-amd64.zip）\n将下载好的文件解压缩，在命令行敲击 hugo version，看到如下结果则表示安装成功。\nGit\n选择合适的版本下载，按照指引一路 next。（由于博主很早之前就已经下载了 Git，所以这块没有图片展示） 创建博客站点 使用 Hugo（建议将其加入环境变量） 创建你的站点，在命令行中输入 hugo new site sitename。出现下图所示，则表明创建好了站点，按照这上面的步骤来即可。\n进入你的站点文件夹，可以看到 Hugo 创建了以下文件\narchetypes 目录包含用于新内容的模板。\nassets 目录包含通常通过资源管道传递的全局资源。包括图片、CSS、Sass、JavaScript 等。\ncontent 目录包含组成站点内容的标记文件（通常是 markdown）和页面资源。\ndata 目录包含用于增强内容、配置、本地化和导航的数据文件（JSON、TOML、YAML 或 XML）。\nhugo.tomal 是 Hugo 的配置文件\ni18n 目录包含多语言站点的翻译表。\nlayouts 目录包含将内容、数据和资源转换为完整网站的模板。\nstatic 目录包含在构建站点时将复制到 public 目录的文件，例如 favicon.ico、robots.txt 和用于验证站点拥有权的文件。在引入页面包和资源管道之前，static 目录也用于存放图片、CSS 和 JavaScript 等资源。\nthemes 目录包含一个或多个主题，每个主题位于自己的子目录中。\nHugo 默认不带主题，因此你需要去 主题社区 下载主题，我这里选择 Stack 这款主题。首先将该文件夹初始为 Git 仓库，再增加主题作为子模块克隆到 theme 文件夹下。使用命令如下：\n初始化仓库：git init -b main\n添加主题：git submodule add https://GitHub.com/CaiJimmy/hugo-theme-stack.git themes/hugo-theme-stack\n将 themes\\hugo-theme-stack\\exampleSite 目录下的 content 文件夹和 hugo.yaml 复制到站点根目录（也就是你上面创建的那个文件夹下，我这里是 myblog），并且删除 hugo.toml 文件。\nNOTE：需要删除 content\\post\\rich-content ，该文件夹内存放的资源访问不了，会导致 Hugo 无法启动）\n使用命令：hugo server -D 启动网站，可以发现站点多了两个文件夹。\npublic 目录包含发布的网站，在运行 hugo 命令时生成。Hugo 根据需要重建此目录及其内容。\nresources 目录包含 Hugo 资源管道的缓存输出，在运行 hugo 或 hugo server 命令时生成。默认情况下，此缓存目录包括 CSS 和图片。Hugo 根据需要重建此目录及其内容。\n访问 http://localhost:1313/，看到如下结果表示你的博客已经在本地搭建好了\nGitHub 部署 搭建好本地环境之后，就需要将网站部署在 GitHub 上。这里有两种部署方式：\n一种是手动上传文件，只需要创建一个 GitHub Page仓库：\n存放网站的静态文件，设置为 Public； 仓库名必须是 \u0026lt;username.github.io\u0026gt;，username 是你 GitHub 的用户名。 创建好仓库之后，按照图示开启 GitHub Page。前往 setting -\u0026gt; Pages -\u0026gt; Branch 选择 main 分支，保存设置。\n将 public 文件夹上传至 GitHub 仓库，上传成功后访问 https://\u0026lt;GiuHub用户名\u0026gt;.github.io，就能看到自己的博客内容了。\n1 2 3 4 5 6 7 git init -b main git add . # git config user.name \u0026#34;your_user_name\u0026#34; # 第一次使用 Git 或者未配置全局变量需要加上此行 # git config user.email \u0026#34;your_user_email\u0026#34; # 第一次使用 Git 或者未配置全局变量需要加上此行 git commit -m \u0026#34;first commit\u0026#34; git remote add origin \u0026lt;your_github_repository_address\u0026gt; git push -u origin main 另一种是 GitHub Action 自动化部署，还需要创建一个博客源文件仓库：\n存放你的网站源文件，建议设置为 Private 防止源码文件泄露\n前往 settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens 创建一个 token(classic)\n如果要考虑安全的话，Token 有效期不要设置永不过期。还有就是注意勾选上 repo 和 workflow。\n将生成的 Token（注意保存，只有当刚生成时才能看见）加入博客源文件仓库的 secrets 中，前往 Settings -\u0026gt; Secrets and variables -\u0026gt; Actions 设置。\n在站点根目录下创建一个 .github/workflows/xxx.yaml 文件配置工作流\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 name: deploy on: push: branches: - main # 当 main 分支发生 push 的时候，运行下面的 jobs jobs: deploy: runs-on: ubuntu-latest # 运行环境 steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;0.139.3\u0026#34; # 建议和你下载的 hugo 版本一致 extended: true - name: Build Web run: hugo -D # 使用 hugo 构建静态网页 - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的Token变量名 }} # 发布到其他 repo 需要提供上面生成的 personal access token EXTERNAL_REPOSITORY: 你的GitHub名/你的仓库名 # 发布到哪个 repo PUBLISH_BRANCH: main # 发布到哪个branch PUBLISH_DIR: ./public # 要发布哪个文件夹的内容 commit_message: auto deploy 将站点根目录下的文件上传至博客源文件仓库，上传成功会出发 GitHub ACtion，自动部署静态页面，访问 https://\u0026lt;GiuHub用户名\u0026gt;.github.io，就能看到自己最新的博客内容了。\n","date":"2024-12-02T18:51:20+08:00","permalink":"https://the-oone.github.io/p/github-pages-hugo-%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"GitHub Pages ➕ Hugo 部署个人博客"}]