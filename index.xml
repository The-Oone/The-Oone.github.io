<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>踩坑记录</title><link>https://the-oone.github.io/</link><description>Recent content on 踩坑记录</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Ting</copyright><lastBuildDate>Sat, 18 Jan 2025 12:17:11 +0800</lastBuildDate><atom:link href="https://the-oone.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Go八股之Mutex</title><link>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bmutex/</link><pubDate>Sat, 18 Jan 2025 12:17:11 +0800</pubDate><guid>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bmutex/</guid><description>&lt;h2 id="锁">锁
&lt;/h2>&lt;p>&lt;strong>锁是多线程编程中的一种同步机制，用于控制对共享资源的访问。&lt;/strong>&lt;/p>
&lt;h3 id="悲观锁">悲观锁
&lt;/h3>&lt;p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，&lt;strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程&lt;/strong>。&lt;/p>
&lt;h3 id="乐观锁">乐观锁
&lt;/h3>&lt;p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改。&lt;/p>
&lt;h2 id="go-mutex">Go Mutex
&lt;/h2>&lt;p>Go sync 包提供了两种锁类型：互斥锁 &lt;code>sync.Mutex&lt;/code> 、读写互斥锁 &lt;code>sync.RWMutex&lt;/code>。二者都属于悲观锁&lt;/p>
&lt;h3 id="底层数据结构">底层数据结构
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Mutex&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">state&lt;/span> &lt;span class="kt">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sema&lt;/span> &lt;span class="kt">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>state 表示互斥锁的状态&lt;/p>
&lt;ul>
&lt;li>
&lt;p>低 1 bit 是mutexLocked，表示互斥锁是否已经被加锁&lt;/p>
&lt;/li>
&lt;li>
&lt;p>低 2 bit 是 mutexWoken，表示互斥锁是否有被唤醒的 Goroutine&lt;/p>
&lt;/li>
&lt;li>
&lt;p>低 3 bit 是 mutexStarving，表示互斥锁是否处于饥饿状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>剩下 29 bit 表示在这个互斥锁上等待队列的 Goroutine 数量&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>sema 表示信号量，mutex 阻塞队列的定位是通过这个变量来实现的，从而实现 goroutine 的阻塞和唤醒。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="加锁">加锁
&lt;/h3>&lt;ol>
&lt;li>首先尝试使用原子操作快速获取锁，如果锁处于初始状态（未被锁定且无等待队列），则直接获取锁并返回，这是快速路径。&lt;/li>
&lt;li>如果快速获取失败，则进入慢路径。在慢路径中，会判断锁是否已被锁定且可自旋。如果是，则尝试设置唤醒标志并进行自旋等待，即执行空循环一段时间，期望锁能够快速释放。&lt;/li>
&lt;li>如果自旋等待后仍未获取锁，或者锁不满足自旋条件，则将当前 Goroutine 加入等待队列。根据锁的当前状态（正常模式或饥饿模式），设置相应的队列信息。&lt;/li>
&lt;li>如果锁处于饥饿模式，当前 Goroutine 会直接阻塞，直到被唤醒并获取锁。如果处于正常模式，被唤醒的 Goroutine 需要与新到达的 Goroutine 竞争锁。&lt;/li>
&lt;/ol>
&lt;h3 id="解锁">解锁
&lt;/h3>&lt;ol>
&lt;li>解锁时，首先使用原子操作更新锁的状态，将锁标记为未锁定，并根据需要更新等待队列信息。&lt;/li>
&lt;li>如果有等待的 Goroutine，并且满足饥饿模式切换条件（如等待队列中只有一个等待者或等待时间较短），则将锁切换到正常模式。&lt;/li>
&lt;li>唤醒等待队列中的一个 Goroutine，使其有机会获取锁。&lt;/li>
&lt;/ol>
&lt;h3 id="自旋和阻塞">自旋和阻塞
&lt;/h3>&lt;p>Goroutine 在没有获取到锁时有以下两种处理方式：&lt;/p>
&lt;ul>
&lt;li>一种是没有获取到锁的线程就&lt;strong>一直循环等待判断该资源是否已经释放锁，这种锁也叫做自旋锁&lt;/strong>，它不用将线程阻塞起来， 适用于并发低且程序执行时间短的场景，缺点是cpu占用较高&lt;/li>
&lt;li>另外一种处理方式就是&lt;strong>把自己阻塞起来，会释放CPU给其他线程，内核会将线程置为睡眠状态&lt;/strong>，等到锁被释放后，内核会在合适的时机唤醒该线程，适用于高并发场景，缺点是有线程上下文切换的开销&lt;/li>
&lt;/ul>
&lt;p>而进入自选态需要满足以下条件：&lt;/p>
&lt;ul>
&lt;li>锁已被占用，并且锁不处于饥饿模式。&lt;/li>
&lt;li>积累的自旋次数小于最大自旋次数（active_spin=4）。&lt;/li>
&lt;li>cpu 核数大于 1。&lt;/li>
&lt;li>有空闲的 P。&lt;/li>
&lt;li>当前 goroutine 所挂载的 P 下，本地待运行队列为空。&lt;/li>
&lt;/ul>
&lt;h3 id="小结">小结
&lt;/h3>&lt;ul>
&lt;li>在 Lock() 之前使用 Unlock() 会导致 panic 异常&lt;/li>
&lt;li>使用 Lock() 加锁后，再次 Lock() 会导致死锁（不支持重入），需Unlock()解锁后才能再加锁&lt;/li>
&lt;li>锁定状态与 goroutine 没有关联，一个 goroutine 可以 Lock，另一个 goroutine 可以 &lt;strong>Unlock&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="goroutine-抢锁模式">Goroutine 抢锁模式
&lt;/h2>&lt;h3 id="正常模式非公平锁">正常模式（非公平锁）
&lt;/h3>&lt;p>在刚开始的时候，是处于正常模式（Barging），也就是，当一个G1持有着一个锁的时候，G2会自旋的去尝试获取这个锁&lt;/p>
&lt;p>当&lt;strong>自旋超过4次&lt;/strong>还没有能获取到锁的时候，这个G2就会被加入到获取锁的等待队列里面，并阻塞等待唤醒&lt;/p>
&lt;p>正常模式下，所有等待锁的 goroutine 按照 FIFO(先进先出)顺序等待。唤醒的goroutine 不会直接拥有锁，而是会和新请求锁的 goroutine 竞争锁。新请求锁的 goroutine 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败，长时间获取不到锁，就会切换到饥饿模式&lt;/p>
&lt;h3 id="饥饿模式公平锁">饥饿模式（公平锁）
&lt;/h3>&lt;p>当一个 goroutine 等待锁时间超过 1 毫秒时，它可能会遇到饥饿问题。 在版本1.9中，这种场景下Go Mutex 切换到饥饿模式（handoff），解决饥饿问题。回归正常模式满足两个条件任何一个：&lt;/p>
&lt;ul>
&lt;li>Goutine 的执行时间小于 1ms&lt;/li>
&lt;li>等待队列已经清空&lt;/li>
&lt;/ul>
&lt;h3 id="小结-1">小结
&lt;/h3>&lt;p>对于两种模式，正常模式下的性能是最好的，goroutine 可以连续多次获取锁，饥饿模式解决了取锁公平的问题，但是性能会下降，其实是性能和公平的 一个平衡模式。&lt;/p>
&lt;h2 id="syncrwmutex">sync.RWMutex
&lt;/h2>&lt;h3 id="底层数据结构-1">底层数据结构
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">RWMutex&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">w&lt;/span> &lt;span class="nx">Mutex&lt;/span> &lt;span class="c1">// 互斥锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">writerSem&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// 信号量，用于写等待读
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">readerSem&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// 信号量，用于读等待写
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">readerCount&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">// 当前执行读的 goroutine 数量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">readerWait&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">// 被阻塞的准备读的 goroutine 的数量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="读锁">读锁
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">rw&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">RWMutex&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">RLock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 加读锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">rw&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">RWMutex&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">RUnlock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 释放读锁
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>先通过原子操作将readerCount加1&lt;/li>
&lt;li>如果readerCount&amp;gt;=0就直接返回，所以如果只有获取读取锁的操作，那么其成本只有一个原子操作&lt;/li>
&lt;li>当readerCount&amp;lt;0时，说明当前有写锁，当前协程将借助信号量陷入等待状态，如果获取到信号量则直接退出，没有获取到信号量时的逻辑与互斥锁的逻辑相似&lt;/li>
&lt;li>读锁解锁时，如果当前没有写锁，则其成本只有一个原子操作并直接退出&lt;/li>
&lt;li>如果当前有写锁正在等待，则调用rUnlockSlow判断当前是否为最后一个被释放的读锁，如果是则需要
增加信号量并唤醒写锁&lt;/li>
&lt;/ol>
&lt;h3 id="写锁">写锁
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">rw&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">RWMutex&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 加写锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">rw&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">RWMutex&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 释放写锁
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>写锁申请时必须先获取互斥锁，因为它复用了互斥锁的功能。接着readerCount减去
rwmutexMaxReaders阻止后续读操作&lt;/li>
&lt;li>获取到互斥锁并不一定能直接获取写锁，如果当前已经有其它Goroutine持有互斥锁的读锁，那么当前
协程会加入全局等待队列并进入休眠状态，当最后一个读锁被释放时，会唤醒该协程&lt;/li>
&lt;li>解锁时，调用Unlock方法，将readerCount加上rwmutexMaxReader，表示不会阻塞后序的读锁，依次
唤醒所有等待中的读锁，当所有的读锁唤醒完毕后会释放互斥锁&lt;/li>
&lt;/ol>
&lt;h3 id="小结-2">小结
&lt;/h3>&lt;ul>
&lt;li>读锁或写锁在 Lock() 之前使用 Unlock() 会导致 panic 异常&lt;/li>
&lt;li>使用 Lock() 加锁后，再次 Lock() 会导致死锁（不支持重入），需Unlock()解锁后才能再加锁&lt;/li>
&lt;li>锁定状态与 goroutine 没有关联，一个 goroutine 可以 RLock（Lock），另一个 goroutine 可以 RUnlock（Unlock）&lt;/li>
&lt;/ul>
&lt;h2 id="递归锁">递归锁
&lt;/h2>&lt;p>可重入锁又称为递归锁，是指在&lt;strong>同一个线程在外层方法获取锁的时候，在进入该线程的内层方法时会自动获取锁，不会因为之前已经获取过还没释放再次加锁导致死锁&lt;/strong>。&lt;/p>
&lt;p>Go 里面的 Mutex 不是可重入的锁。Mutex 的实现中没有记录哪个 goroutine 拥有这把锁，理论上，任何 goroutine 都可以随意地 Unlock 这把锁，所以没办法计算重入条件，并且 Mutex 重复 Lock 会导致死锁。&lt;/p>
&lt;p>如果要实现递归锁，需要以下两个条件：&lt;/p>
&lt;ul>
&lt;li>记住持有锁的线程&lt;/li>
&lt;li>计算冲入次数&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;span class="lnt">72
&lt;/span>&lt;span class="lnt">73
&lt;/span>&lt;span class="lnt">74
&lt;/span>&lt;span class="lnt">75
&lt;/span>&lt;span class="lnt">76
&lt;/span>&lt;span class="lnt">77
&lt;/span>&lt;span class="lnt">78
&lt;/span>&lt;span class="lnt">79
&lt;/span>&lt;span class="lnt">80
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;bytes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;runtime&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;strconv&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;sync&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;sync/atomic&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">ReentrantLock&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Mutex&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">recursion&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">// 这个goroutine 重入的次数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">owner&lt;/span> &lt;span class="kt">int64&lt;/span> &lt;span class="c1">// 当前持有锁的goroutine id
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Get returns the id of the current goroutine.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">GetGoroutineID&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">int64&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">buf&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">buf&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Stack&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">buf&lt;/span>&lt;span class="p">[:],&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;goroutine &amp;#34;&lt;/span>&lt;span class="p">):]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="nx">bytes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">IndexByte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gid&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">strconv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ParseInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">64&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">gid&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewReentrantLock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Locker&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">res&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">ReentrantLock&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">Mutex&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Mutex&lt;/span>&lt;span class="p">{},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">recursion&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">owner&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">res&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// ReentrantMutex 包装一个Mutex,实现可重入
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">ReentrantMutex&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Mutex&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">owner&lt;/span> &lt;span class="kt">int64&lt;/span> &lt;span class="c1">// 当前持有锁的goroutine id
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">recursion&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">// 这个goroutine 重入的次数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ReentrantMutex&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gid&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">GetGoroutineID&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果当前持有锁的goroutine就是这次调用的goroutine,说明是重入
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">LoadInt64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">owner&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">gid&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">recursion&lt;/span>&lt;span class="o">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 获得锁的goroutine第一次调用，记录下它的goroutine id,调用次数加1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">StoreInt64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">owner&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">gid&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">recursion&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ReentrantMutex&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gid&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">GetGoroutineID&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 非持有锁的goroutine尝试释放锁，错误的使用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">LoadInt64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">owner&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">gid&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">panic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;wrong the owner(%d): %d!&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">owner&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">gid&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 调用次数减1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">recursion&lt;/span>&lt;span class="o">--&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">recursion&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 如果这个goroutine还没有完全释放，则直接返回
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 此goroutine最后一次调用，需要释放锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">StoreInt64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">owner&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">mutex&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">ReentrantMutex&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">111&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="go-原子操作">Go 原子操作
&lt;/h2>&lt;p>Go atomic 包是最轻量级的锁（也称无锁结构），可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，支持 &lt;code>int32/int64/uint32/uint64/uintptr&lt;/code> 的基础操作（增减、交换、载入、存储等）。&lt;/p>
&lt;h3 id="add-操作">Add 操作
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">AddInt32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int32&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">delta&lt;/span> &lt;span class="kt">int32&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">new&lt;/span> &lt;span class="kt">int32&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">AddInt64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">delta&lt;/span> &lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">new&lt;/span> &lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">AddUint32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uint32&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">delta&lt;/span> &lt;span class="kt">uint32&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">new&lt;/span> &lt;span class="kt">uint32&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">AddUint64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uint64&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">delta&lt;/span> &lt;span class="kt">uint64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">new&lt;/span> &lt;span class="kt">uint64&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">AddUintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uintptr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">delta&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">new&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="load-操作">Load 操作
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">LoadInt32&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int32&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="nx">val&lt;/span> &lt;span class="kt">int32&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">LoadInt64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="nx">val&lt;/span> &lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">LoadPointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">val&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">LoadUint32&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uint32&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="nx">val&lt;/span> &lt;span class="kt">uint32&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">LoadUint64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uint64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">val&lt;/span> &lt;span class="kt">uint64&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">LoadUintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uintptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">val&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//特殊类型:Value类型，常用于配置变更
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">v&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Value&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Load&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{}){}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="cas-操作">CAS 操作
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">CompareAndSwapInt32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">old&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">new&lt;/span> &lt;span class="kt">int32&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="nx">swapped&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">CompareAndSwapInt64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">old&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">new&lt;/span> &lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">swapped&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">CompareAndSwapPointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="nx">old&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">new&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">swapped&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">CompareAndSwapUint32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uint32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">old&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">new&lt;/span> &lt;span class="kt">uint32&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="nx">swapped&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">CompareAndSwapUint64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uint64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">old&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">new&lt;/span> &lt;span class="kt">uint64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">swapped&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">CompareAndSwapUintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uintptr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">old&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">new&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">swapped&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="swap-操作">Swap 操作
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">SwapInt32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int32&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">new&lt;/span> &lt;span class="kt">int32&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">old&lt;/span> &lt;span class="kt">int32&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">SwapInt64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">new&lt;/span> &lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">old&lt;/span> &lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">SwapPointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">new&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">old&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">SwapUint32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uint32&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">new&lt;/span> &lt;span class="kt">uint32&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">old&lt;/span> &lt;span class="kt">uint32&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">SwapUint64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uint64&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">new&lt;/span> &lt;span class="kt">uint64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">old&lt;/span> &lt;span class="kt">uint64&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">SwapUintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uintptr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">new&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">old&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="store-操作">Store 操作
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">StoreInt32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int32&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="kt">int32&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">StoreInt64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">StorePointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">StoreUint32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uint32&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="kt">uint32&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">StoreUint64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uint64&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="kt">uint64&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">StoreUintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">uintptr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 特殊类型： Value类型，常用于配置变更
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">v&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Value&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Store&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="原子操作-vs-锁">原子操作 VS 锁
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">&lt;/th>
&lt;th style="text-align: center">原子操作&lt;/th>
&lt;th style="text-align: center">锁&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">实现原理&lt;/td>
&lt;td style="text-align: center">底层硬件支持&lt;/td>
&lt;td style="text-align: center">原子操作 + 信号量&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">范围&lt;/td>
&lt;td style="text-align: center">单个指令&lt;/td>
&lt;td style="text-align: center">临界区（多条指令）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">性能&lt;/td>
&lt;td style="text-align: center">性能较高&lt;/td>
&lt;td style="text-align: center">性能较低&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">类别&lt;/td>
&lt;td style="text-align: center">乐观锁&lt;/td>
&lt;td style="text-align: center">悲观锁&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Go八股之Channel</title><link>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bchannel/</link><pubDate>Fri, 17 Jan 2025 13:59:42 +0800</pubDate><guid>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bchannel/</guid><description>&lt;h2 id="底层实现原理">底层实现原理
&lt;/h2>&lt;p>Go中 的 channel 是一个队列，遵循先进先出的原则，负责协程之间的通信（Go 语言提倡不要通过共享内存来通信，而要通过通信来实现内存共享，CSP(Communicating Sequential Process)并发模型，就是通过 goroutine 和 channel 来实现的）。&lt;/p>
&lt;h3 id="底层数据结构">底层数据结构
&lt;/h3>&lt;p>通过 var 声明或者 make 函数创建的 channel 是一个&lt;strong>存储在函数栈帧上的指针&lt;/strong>，占用8个字节，指向堆上
的 hchan 结构体：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">hchan&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">qcount&lt;/span> &lt;span class="kt">uint&lt;/span> &lt;span class="c1">// 循环数组中的数据个数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">dataqsiz&lt;/span> &lt;span class="kt">uint&lt;/span> &lt;span class="c1">// 循环数组的长度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">buf&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span> &lt;span class="c1">// 指向循环数组的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">elemsize&lt;/span> &lt;span class="kt">uint16&lt;/span> &lt;span class="c1">// 元素的大小
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">closed&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// channel 关闭标志
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">timer&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">timer&lt;/span> &lt;span class="c1">// timer feeding this chan
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">elemtype&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">_type&lt;/span> &lt;span class="c1">// 元素类型
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sendx&lt;/span> &lt;span class="kt">uint&lt;/span> &lt;span class="c1">// 下一次写下标的位置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">recvx&lt;/span> &lt;span class="kt">uint&lt;/span> &lt;span class="c1">// 下一次读下标的位置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">recvq&lt;/span> &lt;span class="nx">waitq&lt;/span> &lt;span class="c1">// 读等待队列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">sendq&lt;/span> &lt;span class="nx">waitq&lt;/span> &lt;span class="c1">// 写等待队列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">lock&lt;/span> &lt;span class="nx">mutex&lt;/span> &lt;span class="c1">// 互斥锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>等待队列是一个双向链表，包含一个头节点和一个尾节点。每个节点是一个sudog结构体变量，记录哪个协程在等待，等待的是哪个channel，等待发送/接收的数据在哪里。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">waitq&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">first&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">sudog&lt;/span> &lt;span class="c1">// 队列头
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">last&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">sudog&lt;/span> &lt;span class="c1">// 队列尾
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">sudog&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">g&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span> &lt;span class="c1">// 等待的 Goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">next&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">sudog&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">prev&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">sudog&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">elem&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span> &lt;span class="c1">// 发送/读取数据的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">c&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">hchan&lt;/span> &lt;span class="c1">// 等待的 Channel
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="channel-使用操作">Channel 使用操作
&lt;/h2>&lt;h3 id="创建">创建
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 创建有缓冲 channel，缓冲大小为 3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 创建无缓冲 channel
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>如果是无缓冲的 channel，会直接给 hchan 分配内存&lt;/li>
&lt;li>如果是有缓冲的 channel，并且元素不包含指针，那么会为 hchan 和底层数组分配一段连续的地址&lt;/li>
&lt;li>如果是有缓冲的 channel，并且元素包含指针，那么会为 hchan 和底层数组分别分配地址&lt;/li>
&lt;/ul>
&lt;h3 id="发送">发送
&lt;/h3>&lt;ul>
&lt;li>若 channel 的读等待队列存在接收者 goroutine，那么将数据直接发送给第一个等待的 goroutine，唤醒接收的 goroutine&lt;/li>
&lt;li>若 channel 的读等待队列不存在接收者 goroutine
&lt;ul>
&lt;li>若循环数组 buf 未满，那么将会把数据发送到循环数组buf的队尾&lt;/li>
&lt;li>如果循环数组buf已满，这个时候就会走阻塞发送的流程，将当前goroutine加入写等待队列，并挂起等待唤醒&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="接收">接收
&lt;/h3>&lt;ul>
&lt;li>如果 channel 的写等待队列存在发送者 goroutine
&lt;ul>
&lt;li>如果是无缓冲 channel，直接从第一个发送者 goroutine 那里把数据拷贝给接收变量，唤醒发送的 goroutine&lt;/li>
&lt;li>如果是有缓冲 channel（已满），将循环数组 buf 的队首元素拷贝给接收变量，将第一个发送者goroutine 的数据拷贝到 buf循环数组队尾，唤醒发送的 goroutine&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果 channel 的写等待队列不存在发送者goroutine
&lt;ul>
&lt;li>如果循环数组 buf 非空，将循环数组buf的队首元素拷贝给接收变量&lt;/li>
&lt;li>如果循环数组 buf 为空，这个时候就会走阻塞接收的流程，将当前 goroutine 加入读等待队列，并挂起等待唤醒&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="channel-使用场景">Channel 使用场景
&lt;/h2>&lt;h3 id="循环读取-channel-数据">循环读取 Channel 数据
&lt;/h3>&lt;p>使用&lt;code>for-range&lt;/code>读取channel，这样既安全又便利，当channel关闭时，for循环会自动退出，无需主动监测channel是否关闭，可以防止读取已经关闭的channel，造成读到数据为通道所存储的数据类型的零值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="nx">x&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">ch&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="多重返回判断-channel-关闭状态">多重返回判断 Channel 关闭状态
&lt;/h3>&lt;p>读已关闭的channel会得到零值，如果不确定channel，需要使用&lt;code>ok&lt;/code>进行检测。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="nx">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">ch&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// ok 会接收到 channel 的状态，true 表示未关闭
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">v&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="使用-select-处理多-channel">使用 select 处理多 Channel
&lt;/h3>&lt;p>&lt;code>select&lt;/code>可以同时监控多个通道的情况，只处理未阻塞的case。&lt;strong>当通道为nil时，对应的case永远为阻塞，无论读写。特殊关注：普通情况下，对nil的通道写操作是要panic的&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch1&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch2&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch1&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch2&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Selected ch1&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch2&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Selected ch2&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="使用channel的声明控制读写权限">使用channel的声明控制读写权限
&lt;/h3>&lt;p>如果协程对某个channel只有写操作，则这个channel声明为只写。&lt;/p>
&lt;p>如果协程对某个channel只有读操作，则这个channe声明为只读。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 只有 generator 进行对 outCh 进行写操作，返回声明
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// &amp;lt;-chan int，可以防止其他协程乱用此通道，造成隐藏 bug
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">generator&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nx">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">outCh&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">:=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">outCh&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">outCh&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// consumer只读inCh的数据，声明为&amp;lt;-chan int
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 可以防止它向inCh写数据
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">consumer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">inCh&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">x&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">inCh&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="使用缓冲channel增强并发">使用缓冲channel增强并发
&lt;/h3>&lt;p>有缓冲通道可供多个协程同时处理，在一定程度可提高并发性。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 无缓冲
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">ch1&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">ch2&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 有缓冲
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">ch3&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">test&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">inCh&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">generator&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">outCh&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 使用5个 do 协程同时处理输入数据
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">wg&lt;/span> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">WaitGroup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="nf">do&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">inCh&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">outCh&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">wg&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">outCh&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">outCh&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">r&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">generator&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">outCh&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">outCh&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">outCh&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">outCh&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">do&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">inCh&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">outCh&lt;/span> &lt;span class="kd">chan&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">wg&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">WaitGroup&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">v&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">inCh&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">outCh&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">v&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">v&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="为操作加上超时">为操作加上超时
&lt;/h3>&lt;p>使用&lt;code>select&lt;/code>和&lt;code>time.After&lt;/code>，看操作和定时器哪个先返回，处理先完成的，就达到了超时控制的效果&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">doWithTimeOut&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">timeout&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">ret&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nf">do&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">ret&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">After&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">timeout&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">New&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;timeout&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">do&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">outCh&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// do work
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">outCh&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="使用time实现channel无阻塞读写">使用time实现channel无阻塞读写
&lt;/h3>&lt;p>为操作加上超时的扩展，这里的操作是channel的读或写&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">unBlockRead&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ch&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">After&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Microsecond&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">New&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;read time out&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">unBlockWrite&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ch&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">x&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">After&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Microsecond&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">New&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;read time out&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="closech-关闭所有下游协程">&lt;code>close(ch)&lt;/code> 关闭所有下游协程
&lt;/h3>&lt;p>退出时，显示通知所有协程退出。所有读 &lt;code>ch&lt;/code> 的协程都会收到&lt;code>close(ch)&lt;/code>的信号&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">h&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Handler&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Stop&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">h&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stopCh&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 可以使用WaitGroup等待所有协程退出
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 收到停止后，不再处理请求
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">h&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Handler&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">loop&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">req&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">h&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">reqCh&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="nf">handle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">req&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">h&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stopCh&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="使用chan-struct作为信号-channel">使用&lt;code>chan struct{}&lt;/code>作为信号 channel
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 只是要给所有协程发送退出的信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">Handler&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">stopCh&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">reqCh&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Request&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="使用-channel-传递结构体的指针">使用 channel 传递结构体的指针
&lt;/h2>&lt;p>channel &lt;strong>本质上传递的是数据的拷贝&lt;/strong>，拷贝的数据越小传输效率越高，传递结构体指针，比传递结构体更高效&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">reqCh&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Request&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 好过
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">reqCh&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="nx">Request&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="使用channel传递channel">使用channel传递channel
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;math/rand&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;sync&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">reqs&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 存放结果的channel的channel
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">outs&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">reqs&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">wg&lt;/span> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">WaitGroup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">reqs&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">x&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">reqs&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">o&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">handle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">wg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">outs&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">o&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">outs&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 读取结果，结果有序
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">o&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">outs&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">o&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// handle 处理请求，耗时随机模拟
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">handle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">wg&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">WaitGroup&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">out&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Duration&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">rand&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Intn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">out&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">a&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">out&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="控制-goroutine-并发执行顺序">控制 Goroutine 并发执行顺序
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">wg&lt;/span> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">WaitGroup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch1&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch2&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch3&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch1&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">start&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Now&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">Unix&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;gorouine1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ch1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ch2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;gorouine2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ch2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ch3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;gorouine3&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ch3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ch1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">end&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Now&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">Unix&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;duration:%d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">end&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="nx">start&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gorouine&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">inputchan&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">outchan&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 模拟内部操作耗时
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">inputchan&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">gorouine&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">outchan&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="channel-特点">Channel 特点
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>三种模式&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">&lt;/th>
&lt;th style="text-align: center">单向通道的写操作&lt;/th>
&lt;th style="text-align: center">单向通道的读操作&lt;/th>
&lt;th style="text-align: center">双向通道的读写操作&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">创建&lt;/td>
&lt;td style="text-align: center">make(chan&amp;lt;-int)&lt;/td>
&lt;td style="text-align: center">make(&amp;lt;- chan int)&lt;/td>
&lt;td style="text-align: center">make(chan int)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>三种状态&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">&lt;/th>
&lt;th style="text-align: center">未初始化（nil）&lt;/th>
&lt;th style="text-align: center">关闭（closed）&lt;/th>
&lt;th style="text-align: center">正常（active）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">关闭 channel&lt;/td>
&lt;td style="text-align: center">panic&lt;/td>
&lt;td style="text-align: center">panic&lt;/td>
&lt;td style="text-align: center">正常关闭&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">发送数据&lt;/td>
&lt;td style="text-align: center">死锁，永远阻塞&lt;/td>
&lt;td style="text-align: center">panic&lt;/td>
&lt;td style="text-align: center">阻塞或成功发送&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">接收数据&lt;/td>
&lt;td style="text-align: center">死锁，永远阻塞&lt;/td>
&lt;td style="text-align: center">缓冲区为空为零值，否则继续读&lt;/td>
&lt;td style="text-align: center">阻塞或者成功接收&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>有1个特殊场景&lt;/strong>：当&lt;code>nil&lt;/code>的通道在&lt;code>select&lt;/code>的某个&lt;code>case&lt;/code>中时，这个case会阻塞，但不会造成死锁。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个 channel不能多次关闭，会导致painc&lt;/p>
&lt;p>如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都&lt;strong>可能随机被某一个 goroutine 取走进行消费&lt;/strong>&lt;/p>
&lt;p>如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine &lt;strong>都能收到退出信号&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="channel-死锁">Channel 死锁
&lt;/h2>&lt;h3 id="无缓存-channel-只写不读">无缓存 Channel 只写不读
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">deadlock&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="c1">// 程序会一直阻塞在这里
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="无缓存-channel-读在写后">无缓存 Channel 读在写后
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">deadlock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span>&lt;span class="o">:=&lt;/span>&lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="c1">// 程序会一直阻塞在这里
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">num&lt;/span>&lt;span class="o">:=&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;num=&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">num&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="有缓存-channel-写入超过缓冲区大小">有缓存 Channel 写入超过缓冲区大小
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">deadlock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="mi">3&lt;/span> &lt;span class="c1">// 这里会发生一直阻塞的情况
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="空读">空读
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">deadlock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="多个协程相互等待">多个协程相互等待
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">deadlock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch1&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch2&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 互相等对方造成死锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">num&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;num=&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">num&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch2&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="mi">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">num&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch2&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;num=&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">num&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch1&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="mi">300&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Go八股之Map</title><link>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bmap/</link><pubDate>Thu, 16 Jan 2025 13:42:27 +0800</pubDate><guid>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bmap/</guid><description>&lt;h2 id="实现原理">实现原理
&lt;/h2>&lt;p>Go 的 map 是一个指针，占用 8 个字节，指向 hmap 结构体，map 底层是基于哈希表+链地址法存储的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">hmap&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">count&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="c1">// 当前 map 中元素个数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">flags&lt;/span> &lt;span class="kt">uint8&lt;/span> &lt;span class="c1">// 写入状态标志
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">B&lt;/span> &lt;span class="kt">uint8&lt;/span> &lt;span class="c1">// buckets 的数量（2^B 个）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">noverflow&lt;/span> &lt;span class="kt">uint16&lt;/span> &lt;span class="c1">// 溢出 buckets 的数量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">hash0&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// 生成 hash 的随机数种子
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">buckets&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span> &lt;span class="c1">// 指向 buckets 数组的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">oldbuckets&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span> &lt;span class="c1">// 扩容时，指向扩容前的 buckets 数组的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">nevacuate&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// 表示扩容进度，小于此地址的 buckets 已经迁移成功
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">extra&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">mapextra&lt;/span> &lt;span class="c1">// 保存溢出桶的地址
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">mapextra&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">overflow&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">bmap&lt;/span> &lt;span class="c1">// overflow 包含的是 hmap.buckets 的 overflow 的 buckets
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">oldoverflow&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">bma&lt;/span> &lt;span class="c1">// oldoverflow 包含扩容时 hmap.oldbuckets 的 overflow 的 bucket
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">nextOverflow&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">bmap&lt;/span> &lt;span class="c1">// 指向空闲的 overflow bucket 的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>bmap &lt;/code>就是我们常说的 &lt;code>bucket&lt;/code>，一个 &lt;code>bucket&lt;/code> 里面会最多装 8 个key，这些 key 哈希结果的低 B 位是相同的。在 &lt;code>bucket&lt;/code> 内，又会根据 key 计算出来的hash值的高8位（一个桶内最多有8个位置）来决定 key 到底落入哪个位置。&lt;/p>
&lt;p>当 map 的 key 和 value 均不为指针类型时，bmap 将完全不包含指针，那么垃圾回收就不用扫描 bmap。bmap 指向溢出桶的字段 overflow 是 uintptr 类型，为了防止这些溢出桶被垃圾回收，所以需要 &lt;code>mapextra.overflow&lt;/code> 将它保存起来。如果 bmap 的 overflow 是 *bmap 类型，那么垃圾回收需要扫描一个个拉链表，效率明显不如直接扫描一段内存（hmap.mapextra.overflow）效率高。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// bmap 静态结构
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">bmap&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">tophash&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">bucketCnt&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">uint8&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// bmap 动态结构
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">bmap&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">tophash&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">uint8&lt;/span> &lt;span class="c1">// 存储哈希值的高 8 位，用于快速比较和查找
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">keys&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">keytype&lt;/span> &lt;span class="c1">// 存放 key，keytype 由编译器编译时候确定
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">values&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">elemtype&lt;/span> &lt;span class="c1">// 存放 value，elemtype 由编译器编译时候确定
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">overflow&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// 指向下一个 bmap，overflow 是 uintptr 而不是 *bmap 类型，保证 bmap 完全不含指针，是为了减少 GC，溢出桶存储到 extra 字段中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>tophash 字段不仅存储 hash(key) 的高 8 位，还会存储一些状态值，用来表明当前 &lt;code>bucket&lt;/code> 状态。/为了避免 hash(key) 高 8 位值和这些状态值相等，所以当 hash(key) &amp;lt; minTopHash 时，自动将其值加上 minTopHash 作为该 key 的 tophash。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">emptyRest&lt;/span>&lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">//表明此桶单元为空，且更高索引的单元也是空
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">emptyOne&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="c1">//表明此桶单元为空
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">evacuatedX&lt;/span>&lt;span class="p">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="c1">//用于表示扩容迁移到新桶前半段区间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">evacuatedY&lt;/span>&lt;span class="p">=&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="c1">//用于表示扩容迁移到新桶后半段区间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">evacuatedEmpty&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="c1">//用于表示此单元已迁移
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">minTopHash&lt;/span>&lt;span class="p">=&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="c1">// key的tophash值与桶状态值分割线值，小于此值的一定代表着桶单元的状态，大于此值的一定是key对应的tophash值
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="初始化-map">初始化 Map
&lt;/h2>&lt;ol>
&lt;li>创建一个 hmap 结构体对象&lt;/li>
&lt;li>生成一个哈希因子 hash0 并赋值到 hmap 对象中（用于后续为key创建哈希值）&lt;/li>
&lt;li>根据 hint=10，并根据算法规则来创建B，此时的 B=1&lt;/li>
&lt;li>根据 B 去创建 bucket 并存放在数组中。当前的 Bmap 的数量为 2
&lt;ul>
&lt;li>B&amp;lt;4时，创建桶的个数为：$2^B$（标准桶）&lt;/li>
&lt;li>B≥4时，创建桶的个数为：$2^B+2^{B-4}$（标准桶+溢出桶）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="扩容-map">扩容 Map
&lt;/h2>&lt;p>Go map 扩容，数据迁移不是一次性迁移，而是等到访问到具体某个 bucket 时才将数据从旧 bucket 中迁移到新bucket 中。&lt;/p>
&lt;ul>
&lt;li>一次性迁移会涉及到cpu资源和内存资源的占用，在数据量较大时，会有较大的延时，影响正常业务逻辑。因此 Go 采用渐进式的数据迁移，每次最多迁移两个bucket的数据到新的buckets中（一个是当前访问key所在的bucket，然后再多迁移一个bucket）&lt;/li>
&lt;/ul>
&lt;h3 id="触发时机">触发时机
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>超过负载：&lt;strong>map 元素个数 &amp;gt; 6.5 * bucket 数量&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">h&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">growing&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">overLoadFactor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">h&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">count&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">h&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">B&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="nf">tooManyOverflowBuckets&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">h&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">noverflow&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">h&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">B&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">hashGrow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">t&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">h&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">goto&lt;/span> &lt;span class="nx">again&lt;/span> &lt;span class="c1">// Growing the table invalidates everything, so try again
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 判断是否在扩容
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">h&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">hmap&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">growing&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">h&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">oldbuckets&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>溢出桶太多：当 &lt;strong>bucket 小于 $2^{15}$ 且溢出桶总大于等于桶总数&lt;/strong>，则认为溢出桶过多；当 &lt;strong>bucket 大于等于 $2^{15}$时且溢出桶总数大于等于 $2^{15}$时&lt;/strong>，即认为溢出桶太多了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="扩容机制">扩容机制
&lt;/h3>&lt;ul>
&lt;li>双倍扩容：如果是因为超过负载扩容，新建一个 buckets 数组（大小为原先的 2 倍），然后旧的 buckets 数据搬到新的 buckets 中&lt;/li>
&lt;li>等量扩容：如果是因为溢出桶太多，buckets 数量维持不变，重新做一遍类似双倍扩容的搬迁操作， 把松散的键值对重新排列一次，使得同一个bucket中的key排列地更紧密，提高buckets利用 率，进而保证更快的存取。&lt;/li>
&lt;/ul>
&lt;h2 id="遍历-map">遍历 Map
&lt;/h2>&lt;p>使用 range 多次遍历 map 时输出的 key 和 value 的顺序可能不同。这是 Go 语言的设计者们&lt;strong>有意为之&lt;/strong>，旨在提示开发者们，Go 底层实现并不保证 map 遍历顺序稳定，请大家不要依赖 range 遍历结果顺序。&lt;/p>
&lt;p>主要原因有一下两点：&lt;/p>
&lt;ul>
&lt;li>map在遍历时，并不是从固定的0号bucket开始遍历的，每次遍历，都会从一个&lt;strong>随机值序号的bucket&lt;/strong>，再从其中&lt;strong>随机的cell&lt;/strong>开始遍历&lt;/li>
&lt;li>map遍历时，是按序遍历bucket，同时按需遍历bucket中和其overflow bucket中的cell。但是map在扩容后，会发生key的搬迁，这造成原来落在一个bucket中的key，搬迁后，有可能会落到其他bucket中了，从这个角度看，遍历map的结果就不可能是按照原来的顺序了&lt;/li>
&lt;/ul>
&lt;p>map 本身是无序的，且遍历时顺序还会被随机化，如果想顺序遍历 map，需要对 map key 先排序，再按照 key 的顺序遍历 map。&lt;/p>
&lt;h2 id="查找-map">查找 Map
&lt;/h2>&lt;p>Go 语言中读取 map 有两种语法：带 comma 和 不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一个 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 不带 comma 用法
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">value&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;value:%s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">value&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 带 comma 用法
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;value:%s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">value&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>整个流程如下：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>写保护监测&lt;/strong>：函数首先会检查标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行写操作，进而导致程序 panic（这也说明了 map 不是线程安全的）；&lt;/li>
&lt;li>&lt;strong>计算hash值&lt;/strong>：&lt;code>hash:=t.hasher(key,uintptr(h.hash0))&lt;/code>， 不同类型的key会有不同的hash函数&lt;/li>
&lt;li>&lt;strong>找到hash对应的bucket&lt;/strong>：hash 的低 B 个 bit 位，用来定位 key 所存放的bucket。如果当前正在扩容中，并且定位到的旧bucket数据还未完成迁移，则使用旧的bucket（扩容前的bucket）&lt;/li>
&lt;li>&lt;strong>遍历bucket查找&lt;/strong>：利用哈希值的高 8 个 bit 位快速判断 key 是否已在当前 bucket 中（如果不在的话，需要去 bucket 的 overflow 中查找）&lt;/li>
&lt;li>&lt;strong>返回key对应的指针&lt;/strong>：如果通过上面的步骤找到了key对应的槽位下标 i，根据此得到对应 value 的值&lt;/li>
&lt;/ol>
&lt;h2 id="map-冲突解决方案">map 冲突解决方案
&lt;/h2>&lt;ul>
&lt;li>链地址法&lt;/li>
&lt;li>开放寻址法&lt;/li>
&lt;li>线性探测法&lt;/li>
&lt;/ul>
&lt;p>Go map采用链地址法解决冲突，具体就是&lt;strong>插入key到map中时&lt;/strong>，当key定位的桶&lt;strong>填满8个元素后&lt;/strong>（这里的单元就是桶，不是元素），将会创建一个溢出桶，并且将溢出桶插入当前桶所在链表尾部。&lt;/p>
&lt;h2 id="map-的负载因子">map 的负载因子
&lt;/h2>&lt;p>$负载因子=\frac{哈希表中存储元素}{桶数量}$，其是衡量当前哈希表中空间占用率的核心指标。&lt;/p>
&lt;p>Go Map 的负载因子是 6.5，原因就是官方测试这个数值负载因子的性能较好，具体可看测试：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">负载因子&lt;/th>
&lt;th style="text-align: center">溢出率&lt;/th>
&lt;th style="text-align: center">耗费字节数/kv 对&lt;/th>
&lt;th style="text-align: center">查找平均个数（k存在）&lt;/th>
&lt;th style="text-align: center">查找平均个数（k不存在）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">4.00&lt;/td>
&lt;td style="text-align: center">2.13&lt;/td>
&lt;td style="text-align: center">20.77&lt;/td>
&lt;td style="text-align: center">3.00&lt;/td>
&lt;td style="text-align: center">4.00&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">4.50&lt;/td>
&lt;td style="text-align: center">4.05&lt;/td>
&lt;td style="text-align: center">17.30&lt;/td>
&lt;td style="text-align: center">3.25&lt;/td>
&lt;td style="text-align: center">4.50&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">5.00&lt;/td>
&lt;td style="text-align: center">6.85&lt;/td>
&lt;td style="text-align: center">14.77&lt;/td>
&lt;td style="text-align: center">3.50&lt;/td>
&lt;td style="text-align: center">5.00&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">5.50&lt;/td>
&lt;td style="text-align: center">10.55&lt;/td>
&lt;td style="text-align: center">12.94&lt;/td>
&lt;td style="text-align: center">3.75&lt;/td>
&lt;td style="text-align: center">5.50&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">6.00&lt;/td>
&lt;td style="text-align: center">15.27&lt;/td>
&lt;td style="text-align: center">11.67&lt;/td>
&lt;td style="text-align: center">4.00&lt;/td>
&lt;td style="text-align: center">6.00&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">6.50&lt;/td>
&lt;td style="text-align: center">20.90&lt;/td>
&lt;td style="text-align: center">10.79&lt;/td>
&lt;td style="text-align: center">4.25&lt;/td>
&lt;td style="text-align: center">6.50&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">7.00&lt;/td>
&lt;td style="text-align: center">27.14&lt;/td>
&lt;td style="text-align: center">10.15&lt;/td>
&lt;td style="text-align: center">4.50&lt;/td>
&lt;td style="text-align: center">7.00&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">7.50&lt;/td>
&lt;td style="text-align: center">34.03&lt;/td>
&lt;td style="text-align: center">9.73&lt;/td>
&lt;td style="text-align: center">4.75&lt;/td>
&lt;td style="text-align: center">7.50&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">8.00&lt;/td>
&lt;td style="text-align: center">41.10&lt;/td>
&lt;td style="text-align: center">9.40&lt;/td>
&lt;td style="text-align: center">5.00&lt;/td>
&lt;td style="text-align: center">8.00&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="map-和-syncmap">Map 和 sync.Map
&lt;/h2>&lt;p>Go 语言的 &lt;code>sync.Map&lt;/code> 支持并发读写&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Map&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mu&lt;/span> &lt;span class="nx">Mutex&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">read&lt;/span> &lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Value&lt;/span> &lt;span class="c1">// readOnly
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">dirty&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kd">interface&lt;/span>&lt;span class="p">{}]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">entry&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">misses&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>map 在单个 goroutine 上的读写性能会很好，因为他在读写时没有额外的同步开销，但是他并不是并发安全的，如果多个 goroutine 同时读写一个 map 会导致数据竞争&lt;/li>
&lt;li>sync.Map 通常在并发读写时性能较好，在多 goroutine 场景下会更加安全，适合读多写少场景（写多场景下会导致 read map 缓存失效，性能下降）&lt;/li>
&lt;/ul></description></item><item><title>Go八股之内存分配</title><link>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link><pubDate>Wed, 15 Jan 2025 14:44:36 +0800</pubDate><guid>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid><description>&lt;h2 id="go-的内存分配机制">Go 的内存分配机制
&lt;/h2>&lt;p>Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。&lt;/p>
&lt;h3 id="设计思想">设计思想
&lt;/h3>&lt;ul>
&lt;li>内存分配算法采用&lt;code>TCMalloc算法&lt;/code>，每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向加锁向全局内存池申请，减少系统调用并且避免不同线程对全局内存池的锁竞争&lt;/li>
&lt;li>把内存切分的非常的细小，分为多级管理，以降低锁的粒度&lt;/li>
&lt;li>回收对象内存时，并没有将其真正释放掉，只是放回预先分配的大块内存中，以便复用。只有内存闲置过多的时候，才会尝试归还部分内存给操作系统，降低整体开销&lt;/li>
&lt;/ul>
&lt;h3 id="分配组件">分配组件
&lt;/h3>&lt;p>Go 的内存管理组件主要有：&lt;code>mspan&lt;/code>、&lt;code>mcache&lt;/code>、&lt;code>mcentral&lt;/code>、&lt;code>mheap&lt;/code>&lt;/p>
&lt;h4 id="mspan内存管理单元">mspan：内存管理单元
&lt;/h4>&lt;p>mspan是内存管理的基本单元，该结构体中包含next和 prev两个字段，它们分别指向了前一个和后一个mspan，每个mspan都管理npages个大小为8KB的页，一个span是由多个page组成的，这里的页不是操作系统中的内存页，它们是操作系统内存页的整数倍。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">mspan&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">next&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">mspan&lt;/span> &lt;span class="c1">//后指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">prev&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">mspan&lt;/span> &lt;span class="c1">//前指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">startAddr&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">//管理页的起始地址，指向page
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">npages&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">//页数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">spanclass&lt;/span> &lt;span class="nx">spanClass&lt;/span> &lt;span class="c1">//规格，字节数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">spanclass&lt;/span> &lt;span class="kt">uint8&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="mcache线程缓存">mcache：线程缓存
&lt;/h4>&lt;p>mcache 管理线程在本地缓存的 mspan，每个 goroutine 绑定的P都有一个 &lt;code>mcache&lt;/code> 字段&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">mcache&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">alloc&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">numSpanClasses&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">mspan&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">_NumSizeClasses&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="mi">68&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">numSpanClassed&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">_NumSizeClassed&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>mcache&lt;/code> 用 &lt;code>Span Classes &lt;/code> 作为索引管理多个用于分配的 &lt;code>mspan&lt;/code>，它包含所有规格的 &lt;code>mspan&lt;/code>。它是&lt;code>_NumSizeClasses&lt;/code> 的2倍，也就是 &lt;code>68*2=136&lt;/code>，其中 &lt;code>*2&lt;/code> 是将spanClass分成了有指针和没有指针两种,方便与垃圾回收。对于每种规格，有2个mspan，一个mspan不包含指针，另一个mspan则包含指针。对于无指针对象的&lt;code>mspan&lt;/code>在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。&lt;/p>
&lt;p>&lt;code>mcache&lt;/code>在初始化的时候是没有任何&lt;code>mspan&lt;/code>资源的，在使用过程中会动态地从&lt;code>mcentral&lt;/code>申请，之后会缓存下来。当对象小于等于32KB大小时，使用&lt;code>mcache&lt;/code>的相应规格的&lt;code>mspan&lt;/code>进行分配。&lt;/p>
&lt;h4 id="mcentral中心缓存">mcentral：中心缓存
&lt;/h4>&lt;p>mcentral管理全局的mspan供所有线程使用，全局mheap变量包含central字段，每个 mcentral 结构都维护在&lt;strong>mheap&lt;/strong>结构内&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">mcentral&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">spanclass&lt;/span> &lt;span class="nx">spanClass&lt;/span> &lt;span class="c1">// 指当前规格大小
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">partial&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">spanSet&lt;/span> &lt;span class="c1">// 有空闲object的mspan列表
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">full&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">spanSet&lt;/span> &lt;span class="c1">// 没有空闲object的mspan列表
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>每个mcentral管理一种spanClass的mspan，并将有空闲空间和没有空闲空间的mspan分开管理。partial和 full&lt;code>的数据类型为&lt;/code>spanSet，表示 &lt;code>mspans&lt;/code>集，可以通过pop、push来获得mspans&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">spanSet&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">spineLock&lt;/span> &lt;span class="nx">mutex&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">spine&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span> &lt;span class="c1">// 指向[]span的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">spineLen&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// Spine array length, accessed atomically
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">spineCap&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// Spine array cap, accessed under lock
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">index&lt;/span> &lt;span class="nx">headTailIndex&lt;/span> &lt;span class="c1">// 前32位是头指针，后32位是尾指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>简单说下&lt;code>mcache&lt;/code>从&lt;code>mcentral&lt;/code>获取和归还&lt;code>mspan&lt;/code>的流程：&lt;/p>
&lt;ul>
&lt;li>获取； 加锁，从&lt;code>partial&lt;/code>链表找到一个可用的&lt;code>mspan&lt;/code>；并将其从&lt;code>partial&lt;/code>链表删除；将取出的&lt;code>mspan&lt;/code>加入到&lt;code>full&lt;/code>链表；将&lt;code>mspan&lt;/code>返回给工作线程，解锁。&lt;/li>
&lt;li>归还； 加锁，将&lt;code>mspan&lt;/code>从&lt;code>full&lt;/code>链表删除；将&lt;code>mspan&lt;/code>加入到&lt;code>partial&lt;/code>链表，解锁。&lt;/li>
&lt;/ul>
&lt;h4 id="mheap页堆">mheap：页堆
&lt;/h4>&lt;p>mheap管理Go的所有动态分配内存，可以认为是Go程序持有的整个堆空间，全局唯一&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">mheap_&lt;/span> &lt;span class="nx">mheap&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">mheap&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">lock&lt;/span> &lt;span class="nx">mutex&lt;/span> &lt;span class="c1">// 全局锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">pages&lt;/span> &lt;span class="nx">pageAlloc&lt;/span> &lt;span class="c1">// 页面分配的数据结构
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">allspans&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">mspan&lt;/span> &lt;span class="c1">// 所有通过 mheap_ 申请的mspans
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 堆
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">arenas&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="nx">arenaL1Bits&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="nx">arenaL2Bits&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">heapArena&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 所有中心缓存mcentral
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">central&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">numSpanClasses&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mcentral&lt;/span> &lt;span class="nx">mcentral&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pad&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">cpu&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">CacheLinePadSize&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mcentral&lt;/span>&lt;span class="p">{})&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nx">cpu&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">CacheLinePadSize&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>所有&lt;code>mcentral&lt;/code>的集合则是存放于&lt;code>mheap&lt;/code>中的。&lt;code>mheap&lt;/code>里的&lt;code>arena&lt;/code> 区域是堆内存的抽象，运行时会将 &lt;code>8KB&lt;/code> 看做一页，这些内存页中存储了所有在堆上初始化的对象。运行时使用二维的 runtime.heapArena 数组管理所有的内存，每个 runtime.heapArena 都会管理 64MB 的内存。&lt;/p>
&lt;p>当申请内存时，依次经过 &lt;code>mcache&lt;/code> 和 &lt;code>mcentral&lt;/code> 都没有可用合适规格的大小内存，这时候会向 &lt;code>mheap&lt;/code> 申请一块内存。然后按指定规格划分为一些列表，并将其添加到相同规格大小的 &lt;code>mcentral&lt;/code> 的 &lt;code>非空闲列表&lt;/code> 后面&lt;/p>
&lt;h4 id="分配流程">分配流程
&lt;/h4>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501151526696.png"
loading="lazy"
alt="image-20250115152613550"
>&lt;/p>
&lt;ul>
&lt;li>首先通过计算使用的大小规格&lt;/li>
&lt;li>然后使用&lt;code>mcache&lt;/code>中对应大小规格的块分配。&lt;/li>
&lt;li>如果&lt;code>mcentral&lt;/code>中没有可用的块，则向&lt;code>mheap&lt;/code>申请，并根据算法找到最合适的&lt;code>mspan&lt;/code>。&lt;/li>
&lt;li>如果申请到的&lt;code>mspan&lt;/code> 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。&lt;/li>
&lt;li>如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）&lt;/li>
&lt;/ul>
&lt;h2 id="内存逃逸">内存逃逸
&lt;/h2>&lt;p>内存逃逸指的是在函数内部分配的变量在函数结束后仍然被其他部分引用，导致其生命周期延长到函数外部。这种情况下，变量将不再局限于函数栈中，而是被分配到堆上。内存逃逸会导致额外的内存分配和垃圾回收的开销，影响程序的性能。&lt;/p>
&lt;h3 id="指针逃逸">指针逃逸
&lt;/h3>&lt;p>在函数中创建了一个对象，返回了这个对象的指针。这种情况下，函数虽然退出了，但是因为指针的存在，对象的内存不能随着函数结束而回收，因此只能分配在堆上。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">float64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">float64&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">res&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">y&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">res&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">1.0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码中 &lt;code>res&lt;/code> 变量发生了逃逸。使用 &lt;code>go build -gcflags=-m&lt;/code> 指令可以看到：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># command-line-arguments&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test6.go:3:6: can inline add
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test6.go:8:6: can inline main
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test6.go:9:5: inlining call to add
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test6.go:4:2: moved to heap: res
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="栈空间不足">栈空间不足
&lt;/h3>&lt;p>当栈空间足够时，不会发生逃逸，但是当变量过大时，已经完全超过栈空间的大小时，将会发生逃逸到堆上分配内存。局部变量s占用内存过大，编译器会将其分配到堆上&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;math/rand&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">f1&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">nums&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8192&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 64KB
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="mi">8191&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">rand&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Int&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">f2&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">nums&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8193&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 64KB + 8B
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="mi">8192&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">rand&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Int&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">f1&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">f2&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上述代码中，&lt;code>f1&lt;/code> 函数发生未内存逃逸，&lt;code>f2&lt;/code> 函数发生内存逃逸。（博主环境为 Windows 10，Go 1.23.0）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="err">#&lt;/span> &lt;span class="nx">command&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="nx">line&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="nx">arguments&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">.&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nx">test7&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">go&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">14&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8192&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nx">does&lt;/span> &lt;span class="nx">not&lt;/span> &lt;span class="nx">escape&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">.&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nx">test7&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">go&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">15&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">14&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8193&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nx">escapes&lt;/span> &lt;span class="nx">to&lt;/span> &lt;span class="nx">heap&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="变量大小不确定">变量大小不确定
&lt;/h3>&lt;p>编译期间无法确定slice的长度，这种情况为了保证内存的安全，编译器也会触发逃逸，在堆上进行分配内存。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;math/rand&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">nums&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">rand&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Int&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># command-line-arguments&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test8.go:12:6: can inline main
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test8.go:6:14: make&lt;span class="o">([]&lt;/span>int, n&lt;span class="o">)&lt;/span> escapes to heap
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="interface-动态类型逃逸">interface{} 动态类型逃逸
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>hello world&lt;/code> 字符串作为实参传递给 &lt;code>fmt.Println()&lt;/code>，但是因为 &lt;code>fmt.Println()&lt;/code> 的参数类型定义为 &lt;code>interface{}&lt;/code> 因此也会发生内存逃逸。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># command-line-arguments&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test9.go:5:6: can inline main
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test9.go:7:13: inlining call to fmt.Println
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test9.go:7:13: ... argument does not escape
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test9.go:7:14: &lt;span class="s2">&amp;#34;hello world&amp;#34;&lt;/span> escapes to heap
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="闭包引用对象">闭包引用对象
&lt;/h3>&lt;p>一个函数和对其周围状态的引用捆绑在一起，这样的组合就是闭包。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">test&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">test&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>test()&lt;/code> 返回值是一个闭包函数，该闭包函数访问外部变量 &lt;code>n&lt;/code>，&lt;code>n&lt;/code> 会一直存在直到 &lt;code>test()&lt;/code> 函数被销毁。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># command-line-arguments&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test10.go:3:6: can inline &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test10.go:5:9: can inline test.func1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test10.go:11:6: can inline main
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test10.go:12:6: inlining call to &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test10.go:4:6: moved to heap: i
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test10.go:5:9: func literal escapes to heap
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./test10.go:12:6: func literal does not escape
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="小结">小结
&lt;/h3>&lt;ol>
&lt;li>栈上分配内存比在堆中分配内存效率更高&lt;/li>
&lt;li>栈上分配的内存不需要 GC 处理，而堆需要&lt;/li>
&lt;li>逃逸分析目的是决定内分配地址是栈还是堆&lt;/li>
&lt;li>逃逸分析在编译阶段完成&lt;/li>
&lt;/ol>
&lt;p>因为无论变量的大小，只要是指针变量都会在堆上分配，所以对于小变量我们还是使用传值效率更高一点。&lt;/p>
&lt;h2 id="go-内存对齐机制">Go 内存对齐机制
&lt;/h2>&lt;h3 id="内存对齐">内存对齐
&lt;/h3>&lt;p>为了能让CPU可以更快的存取到各个字段，Go编译器会帮你把struct结构体做数据的对齐。&lt;strong>所谓的数据对齐，是指内存地址是所存储数据大小（按字节为单位）的整数倍，以便CPU可以一次将该数据从内存中读取出来。&lt;/strong> 编译器通过在结构体的各个字段之间填充一些空白已达到对齐的目的。&lt;/p>
&lt;h3 id="对齐系数">对齐系数
&lt;/h3>&lt;p>不同硬件平台占用的大小和对齐值都可能是不一样的，32位系统对齐系数是4，64位系统对齐系数是8。&lt;/p>
&lt;p>不同类型的对齐系数也可能不一样，使用Go 语言中的unsafe.Alignof函数可以返回相应类型的对齐系数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;unsafe&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;bool alignof is %d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Alignof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">bool&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">)))&lt;/span> &lt;span class="c1">// bool alignof is 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;string alignof is %d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Alignof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;a&amp;#34;&lt;/span>&lt;span class="p">)))&lt;/span> &lt;span class="c1">// string alignof is 8
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;int8 alignof is %d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Alignof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int8&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)))&lt;/span> &lt;span class="c1">// int8 alignof is 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;int16 alignof is %d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Alignof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int16&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)))&lt;/span> &lt;span class="c1">// int16 alignof is 2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;int32 alignof is %d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Alignof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)))&lt;/span> &lt;span class="c1">// int32 alignof is 4
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;int64 alignof is %d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Alignof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)))&lt;/span> &lt;span class="c1">// int64 alignof is 8
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;float32 alignof is %f\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Alignof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">float32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)))&lt;/span> &lt;span class="c1">// float32 alignof is 4
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;float alignof is %d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Alignof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">float64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)))&lt;/span> &lt;span class="c1">// float alignof is 8
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="对齐原则">对齐原则
&lt;/h3>&lt;ul>
&lt;li>结构体变量中成员的偏移量必须是成员变量大小和成员对齐系数两者最小值的整数倍&lt;/li>
&lt;li>整个结构体的地址必须是最大字节和编译器默认对齐系数两者最小值的整数倍（结构体的内存占用是1/4/8/16 byte&amp;hellip;）&lt;/li>
&lt;li>struct{}放在结构体中间不进行对齐，放在结构体最后一个字段则要根据最大字节和编译器默认对齐系数两者最小值来进行字段对齐&lt;/li>
&lt;/ul>
&lt;h3 id="优势">优势
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>提高可移植性，有些&lt;code>CPU&lt;/code>可以访问任意地址上的任意数据，而有些&lt;code>CPU&lt;/code>只能在特定地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有平台可以移植性了&lt;/p>
&lt;/li>
&lt;li>
&lt;p>提高内存的访问效率，32位CPU下一次可以从内存中读取32位（4个字节）的数据，64位CPU下一次可以从内存中读取64位（8个字节）的数据，这个长度也称为CPU的字长。CPU一次可以读取1个字长的数据到内存中，如果所需要读取的数据正好跨了1个字长，那就得花两个CPU周期的时间去读取了。因此在内存中存放数据时进行对齐，可以提高内存访问效率。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="劣势">劣势
&lt;/h3>&lt;ul>
&lt;li>存在内存空间的浪费&lt;/li>
&lt;/ul>
&lt;h2 id="make-和-new-的异同">make 和 new 的异同
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">make&lt;/th>
&lt;th style="text-align: center">new&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">make 仅用来分配及初始化类型为 slice、map、chan 的数据。&lt;/td>
&lt;td style="text-align: center">new 可分配任意类型的数据，根据传入的类型申请一块内存，返回指向这块内存的指针，即类型 *Type。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">make函数返回的是slice、map、chan类型本身&lt;/td>
&lt;td style="text-align: center">new函数返回一个指向该类型内存地址的指针&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Go八股之Slice</title><link>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bslice/</link><pubDate>Wed, 15 Jan 2025 13:12:33 +0800</pubDate><guid>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bslice/</guid><description>&lt;h2 id="什么是-slice">什么是 Slice
&lt;/h2>&lt;p>切片是基于数组实现的，底层是数组，可以理解为对底层数组的抽象&lt;/p>
&lt;h3 id="数据结构">数据结构
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">slice&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">array&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span> &lt;span class="c1">// 指向底层数组的指针，占 8 字节
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">len&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="c1">// 切片长度，占 8 字节
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">cap&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="c1">// 切片容量，占 8 字节
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="初始化">初始化
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 直接声明
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">s1&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 使用字面量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">s2&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 使用 make
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">s3&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 指定长度为1.容量为4
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">s4&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 指定长度为 1，容量默认为1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 从其他切片或数组中截取
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">arr&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s5&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>基于切片和数组创建的切片会和原数组或切片共享底层空间，修改切片会影响原数组或切片&lt;/strong>&lt;/p>
&lt;h3 id="扩容">扩容
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 追加元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// [1 2]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 追加切片
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// [1 2 3 4]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>V1.18 版本之前
&lt;ul>
&lt;li>如果所需容量大于原容量的二倍，则新容量为所需容量。&lt;/li>
&lt;li>如果原slice容量小于1024，则新slice容量将扩大为原来的二倍。&lt;/li>
&lt;li>如果原slice容量大于或等于1024，则新slice容量将扩大为原来的1.25倍。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>V1.18 版本
&lt;ul>
&lt;li>如果所需容量大于原容量的二倍，则新容量为所需容量。&lt;/li>
&lt;li>如果原slice容量小于256，则新slice容量将扩大为原来的二倍。&lt;/li>
&lt;li>如果原容量大于或等于256，进入一个循环，每次容量增加（旧容量 + 3 * threshold）/ 4 。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>而每次扩容后，切片将会开辟一块新的空间，将原切片中的数据拷贝到新地址中，而原先的那片空间就会被抛弃（仅限于没有其他指针指向原先的老空间）&lt;/p>
&lt;h2 id="array-和-slice-的区别">Array 和 Slice 的区别
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>数组是固定长度，其大小在定义阶段就必须确定，函数传递中数组传递值。它的物理空间连续，性能相对较高，适合存储已知数量元素的场景。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>切片是动态的序列，其是一个引用类型，指向了底层数组，大小可变，函数传递中传递引用。性能较低，但是灵活性高，适合数量未知或者频繁需要增删的场景&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="slice-线程安全嘛">Slice 线程安全嘛
&lt;/h2>&lt;p>slice 底层结构并没有使用加锁等方式，不支持并发读写，所以&lt;strong>并不是线程安全&lt;/strong>的，使用多个 goroutine 对类型为 slice 的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; &lt;strong>slice在并发执行中不会报错，但是数据会丢失&lt;/strong>&lt;/p>
&lt;h2 id="slice-深拷贝和浅拷贝">Slice 深拷贝和浅拷贝
&lt;/h2>&lt;h3 id="深拷贝">深拷贝
&lt;/h3>&lt;p>拷贝的是数据本身，创造一个新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s1&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s2&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;s1: %v, %p\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// s1: [1 2 3 4 5], 0xc00000e420
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nb">copy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;s2: %v, %p\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// s2: [1 2 3 4 5], 0xc00000e450
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">s3&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">v&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">s1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s3&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">v&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;s3: %v, %p\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// s3: [1 2 3 4 5], 0xc00000e480
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="浅拷贝">浅拷贝
&lt;/h3>&lt;p>拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s1&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;s1: %v, %p\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// s1: [1 2 3 4 5], 0xc00000e420
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">s2&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;s2: %v, %p\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// s2: [1 2 3 4 5], 0xc00000e420
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="nil-slice-和-空slilce">nil slice 和 空slilce
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>nil slice 表示未初始化的切片，不分配任何内存，其值为 nil&lt;/p>
&lt;/li>
&lt;li>
&lt;p>空 slice 表示已初始化但长度为零，分配内存&lt;/p>
&lt;/li>
&lt;li>
&lt;p>二者并不相等，但是对这两个都可以进行 append 操作&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="c1">// nil slice
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">b&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{}&lt;/span> &lt;span class="c1">// empty slice
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// false
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">// 0 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">// 0 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// a现在是包含一个元素的切片 [1]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">// [1] 1 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">b&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// b现在也是包含一个元素的切片 [1]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">// [1] 1 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul></description></item><item><title>Redis持久化</title><link>https://the-oone.github.io/p/redis%E6%8C%81%E4%B9%85%E5%8C%96/</link><pubDate>Tue, 14 Jan 2025 21:04:32 +0800</pubDate><guid>https://the-oone.github.io/p/redis%E6%8C%81%E4%B9%85%E5%8C%96/</guid><description>&lt;h2 id="redis-为什么需要持久化">Redis 为什么需要持久化
&lt;/h2>&lt;h2 id="rdbredis-database">RDB（Redis Database）
&lt;/h2>&lt;p>RDB 持久化以指定的时间间隔对数据集执行时间点快照（实际上就是记录某一个时间节点的&lt;strong>内存数据&lt;/strong>）。&lt;/p>
&lt;h3 id="配置操作">配置操作
&lt;/h3>&lt;p>Redis 7.4.2 默认 RDB 参数&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 1p/1h 或 100p/5m 或 10000p/60s &lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">save &lt;span class="m">3600&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">300&lt;/span> &lt;span class="m">100&lt;/span> &lt;span class="m">60&lt;/span> &lt;span class="m">10000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># RDB 快照保存文件名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">dbfilename dump.rdb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># RDB 快照保存目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">dir ./
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 在快照写入失败时是否停止写请求&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">stop-writes-on-bgsave-error yes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 是否开启 RDB 压缩（LZF压缩算法）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rdbcompression yes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 是否开启 RDB 数据校验（CRC64算法）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rdbchecksum yes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 是否删除未启用持久性的实例中复制使用的 RDB 文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rdb-del-sync-files no
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>默认情况下，Redis 会将数据集的快照保存在磁盘上一个名为 dump.rdb 的二进制文件中。 你也可以手动调用 SAVE 或 BGSAVE 命令。&lt;/p>
&lt;ul>
&lt;li>执行 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，&lt;strong>会阻塞主线程&lt;/strong>。&lt;strong>线上禁止使用&lt;/strong>&lt;/li>
&lt;li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以&lt;strong>避免主线程的阻塞&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>执行 flushall/flushdb 命令也会产生 &lt;code>.rdb&lt;/code> 文件，但是该文件中&lt;strong>没有任何数据&lt;/strong>（因为他是在清盘之后才保存的）。在恢复数据时，一定要将服务和备份分机隔离（防止备份的 .&lt;code>rdb&lt;/code> 文件被覆盖）。&lt;/p>
&lt;h3 id="触发时机">触发时机
&lt;/h3>&lt;ul>
&lt;li>配置文件中默认的快照配置&lt;/li>
&lt;li>手动 sava/bgsave 命令&lt;/li>
&lt;li>执行 flushall/flushdb 命令&lt;/li>
&lt;li>执行 shutdown 且没有设置 AOF 持久化&lt;/li>
&lt;li>主从复制，主节点自动触发&lt;/li>
&lt;/ul>
&lt;h3 id="优势">优势
&lt;/h3>&lt;ul>
&lt;li>适合大规模的数据恢复&lt;/li>
&lt;li>按照业务定时备份&lt;/li>
&lt;li>对数据完整性和一致性要求不高&lt;/li>
&lt;li>RDB 文件在内存中加载速度比 AOF 快得多&lt;/li>
&lt;/ul>
&lt;h3 id="劣势">劣势
&lt;/h3>&lt;ul>
&lt;li>RDB 会丢失备份间隔时间内的所有数据，也就是说距离上一次备份期间内的所有数据都会被丢失&lt;/li>
&lt;li>RDB 是全量快照，每次执行都会把所有的数据记录到磁盘中，频繁的磁盘 I/O 可能影响服务器性能&lt;/li>
&lt;li>RDB 依赖主进程的 fork，在极端形况下内存占用会变为原先的 2 倍。&lt;/li>
&lt;/ul>
&lt;h3 id="执行-rdb-快照时能否修改数据">执行 RDB 快照时能否修改数据
&lt;/h3>&lt;p>可以，使用&lt;strong>写时复制技术&lt;/strong>。&lt;/p>
&lt;p>执行 bgsave 命令时，通过 fork() 创建子进程，因此父进程、子进程共享同一片内存数据（两份页表，一份物理内存）。只有当发生数据修改时，才会复制一份新的物理内存（注意此时&lt;strong>子进程会将旧的物理内存写入 RDB 文件&lt;/strong>，而&lt;strong>主进程会在新的物理内存中修改数据&lt;/strong>）。这样就可以避免主线程阻塞。&lt;/p>
&lt;h2 id="aofappend-only-file">AOF（Append Only File）
&lt;/h2>&lt;p>AOF 持久性&lt;strong>记录服务器收到的每个写入操作&lt;/strong>。 这些操作可以在服务器启动时再次重放，重建原始数据集。 命令记录格式与 Redis 协议本身相同。&lt;/p>
&lt;h3 id="配置操作-1">配置操作
&lt;/h3>&lt;p>Redis 7.4.2 默认 AOF 参数&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># AOF 默认关闭&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">appendonly no
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># AOF 文件名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">appendfilename &lt;span class="s2">&amp;#34;appendonly.aof&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># AOF 保存目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">appenddirname &lt;span class="s2">&amp;#34;appendonlydir&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 回写策略（三种，默认 everysec）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># appendfsync always&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">appendfsync everysec
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># appendfsync no&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>默认情况下，Redis 会将记录到的命令文件保存在磁盘上一个名为 appendonly.aof 的文件中。 Redis 6 之前只有一个 AOF 文件。Redis 7 之后有三个文件（合并在一个文件中）：&lt;/p>
&lt;ul>
&lt;li>appendonly.aof.1.base.rdb：基础 AOF，最多只有一个，一般由子进程通过重写产生&lt;/li>
&lt;li>appendonly.aof.1.incr.aof：增量 AOF，可能存在多个，一般会在 AOF 重写时创建&lt;/li>
&lt;li>历史 AOF，每次 AOF 重写完成时，之前的基础 AOF 和增量 AOF 都会编程历史 AOF。Redis 配置里没有，因为它会被自动删除&lt;/li>
&lt;li>appendonly.aof.manifest：跟踪管理 AOF 文件&lt;/li>
&lt;/ul>
&lt;h3 id="工作流程">工作流程
&lt;/h3>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501172208398.png"
loading="lazy"
alt="image-20250117220833281"
>&lt;/p>
&lt;ol>
&lt;li>Client 向 Redis 发送操作命令&lt;/li>
&lt;li>这些命令首先进入 AOF 缓冲区保存（避免频繁的磁盘 I/O 操作）&lt;/li>
&lt;li>AOF 根据写回策略将缓冲区命令写入磁盘中&lt;/li>
&lt;li>为了 AOF 文件的膨胀，会进行 AOF 重写压缩文件&lt;/li>
&lt;li>Redis 会在服务启动时加载磁盘中的 AOF 文件再次执行这些命令&lt;/li>
&lt;/ol>
&lt;h4 id="执行优势">执行优势
&lt;/h4>&lt;p>Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。&lt;/p>
&lt;ul>
&lt;li>避免额外的检查开销，因为能执行的命令必然是正确的命令&lt;/li>
&lt;li>不会阻塞当前写操作命令的执行，因为只有写命令直接成功后才会记录&lt;/li>
&lt;/ul>
&lt;h4 id="执行劣势">执行劣势
&lt;/h4>&lt;ul>
&lt;li>当 Redis 执行命令后，记录命令前，这个时刻 Redis 服务宕机，那么这个数据就会有丢失的风险&lt;/li>
&lt;li>由于 Redis 执行命令和 AOF 写入这两个操作均是在一个线程中完成，那么可能导致下一个命令阻塞&lt;/li>
&lt;/ul>
&lt;h3 id="写回策略">写回策略
&lt;/h3>&lt;p>上图中第二步和第三步可以再细化为以下几步：&lt;/p>
&lt;ol>
&lt;li>Redis 执行完写命令后，将该命令追加到 &lt;code>server.aoof_buf&lt;/code> 缓冲区中&lt;/li>
&lt;li>通过调用系统函数 &lt;code>write()&lt;/code>，将缓冲区内数据写入到 AOF 文件中，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 &lt;code>page cache&lt;/code>&lt;/li>
&lt;li>内核缓冲区将数据写入硬盘&lt;/li>
&lt;/ol>
&lt;p>Redis 提供了三种写回策略&lt;/p>
&lt;ul>
&lt;li>Always
&lt;ul>
&lt;li>策略含义：每次写命令执行完后，将 AOF 写回硬盘&lt;/li>
&lt;li>实际操作：每次写命令执行完之后立刻执行 &lt;code>fsync()&lt;/code> 函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Everysec
&lt;ul>
&lt;li>策略含义：每次写命令执行完后，先将其写入 AOF 缓冲区，之后每隔一秒将缓冲区写入磁盘&lt;/li>
&lt;li>实际操作：每次写命令执行完之后，会创建一个异步进程执行 &lt;code>fsync()&lt;/code> 函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>No
&lt;ul>
&lt;li>策略含义：每次写命令执行完后，先将其写入 AOF 缓冲区，之后将缓冲区写入磁盘（由操作系统决定间隔时间）&lt;/li>
&lt;li>实际操作：永远不执行 &lt;code>fsync()&lt;/code> 函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="小结">小结
&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">写回策略&lt;/th>
&lt;th style="text-align: center">写回时机&lt;/th>
&lt;th style="text-align: center">优点&lt;/th>
&lt;th style="text-align: center">缺点&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">Always&lt;/td>
&lt;td style="text-align: center">同步写回&lt;/td>
&lt;td style="text-align: center">可靠性高&lt;/td>
&lt;td style="text-align: center">性能开销大&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">Everysec&lt;/td>
&lt;td style="text-align: center">每秒写回&lt;/td>
&lt;td style="text-align: center">性能、可靠性均衡&lt;/td>
&lt;td style="text-align: center">宕机丢失 1 秒内数据&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">No&lt;/td>
&lt;td style="text-align: center">由操作系统决定&lt;/td>
&lt;td style="text-align: center">性能高&lt;/td>
&lt;td style="text-align: center">宕机丢失数据多&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="重写机制">重写机制
&lt;/h3>&lt;p>当 AOF 文件的大小（默认64MB）超过所设定的阈值后，Redis 启动 重写机制。由于重写操作十分耗时，所以该过程是由子进程 &lt;code>bgrewriteaof&lt;/code> 完成的，有以下两点好处&lt;/p>
&lt;ul>
&lt;li>重写期间避免阻塞主进程&lt;/li>
&lt;li>子进程带有主进程的数据副本，如果父子进程任何一方修改内存会触发写时复制机制，确保数据安全。&lt;/li>
&lt;/ul>
&lt;p>触发重写机制后，主进程就会创建重写的 AOF 子进程，此时父子进程共享物理内存，重写子进程只会对该内存读取，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换为一条命令，再将命令记录到重回日志（新的 AOF 文件）。&lt;/p>
&lt;p>子进程完成 AOF 重写工作后，会向主进程发送一条异步信号。主进程收到信号后首先将 AOF 缓冲区中所有内容追加到新的 AOF 文件中，然后将新的 AOF 文件改名，覆盖掉旧的 AOF 文件。&lt;/p></description></item><item><title>Go八股之GC</title><link>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bgc/</link><pubDate>Tue, 14 Jan 2025 13:19:36 +0800</pubDate><guid>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bgc/</guid><description>&lt;h2 id="什么是-gc">什么是 GC
&lt;/h2>&lt;p>垃圾回收（Garbage Collection，GC）是一种自动内存管理机制。&lt;/p>
&lt;p>现代高级编程语言管理内存有两种方式：&lt;/p>
&lt;ul>
&lt;li>手动：C/C++，Rust等，需要主动申请或者释放内存&lt;/li>
&lt;li>自动：Java，Golang等，有内存分配器和垃圾收集器自动分配和回收内存&lt;/li>
&lt;/ul>
&lt;p>程序中会使用两种内存：&lt;/p>
&lt;ul>
&lt;li>堆内存：程序共享的内存，由 GC 进行回收&lt;/li>
&lt;li>栈内存：线程专用的内存，存储函数的参数值、局部变量等，由操作系统自动分配释放&lt;/li>
&lt;/ul>
&lt;h2 id="go-的垃圾回收">Go 的垃圾回收
&lt;/h2>&lt;h3 id="gc-相关术语">GC 相关术语
&lt;/h3>&lt;ul>
&lt;li>STW：全称 stop the word，GC 期间某个阶段会停止所有的赋值器，中断程序逻辑，以确定引用关系。&lt;/li>
&lt;li>root 对象：根对象是指赋值器不需要通过其他对象就可以直接访问到的对象&lt;/li>
&lt;/ul>
&lt;h3 id="gc-v13">GC V1.3
&lt;/h3>&lt;p>1.3 版本 Go 使用&lt;strong>标记-清除&lt;/strong>作为垃圾回收算法：&lt;/p>
&lt;ol>
&lt;li>开启STW，停止程序的运行&lt;/li>
&lt;li>从根节点遍历，标记找出的所有可达对象&lt;/li>
&lt;li>清理未标记的对象&lt;/li>
&lt;li>继续运行程序&lt;/li>
&lt;/ol>
&lt;p>重复循环上述 1-4 步，直到 process 程序生命周期结束。标记清除法的&lt;strong>最大弊端就是在整个GC期间需要STW&lt;/strong>，将整个程序暂停。因为如果不进行STW的话，会出现已经被标记的对象A，引用了新的未被标记的对象B，但由于对象A已经标记过了，不会再重新扫描A对B的可达性，从而将B对象当做垃圾回收掉。&lt;/p>
&lt;h3 id="gc-v15">GC V1.5
&lt;/h3>&lt;p>1.5 版本使用&lt;strong>标记-清除算法，结合三色标记，插入写屏障&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>创建白、灰、黑三个集合&lt;/li>
&lt;li>将所有对象先放入白色集合中&lt;/li>
&lt;li>遍历所有 root 对象，把遍历到的对象从白色集合放入灰色集合（这里放入灰色集合的都是根节点直接可达的对象）&lt;/li>
&lt;li>遍历灰色集合，将灰色对象直接可达的对象从白色集合放入灰色集合，自身标记为黑色&lt;/li>
&lt;li>重复第四步，直至灰色集合中没有任何对象&lt;/li>
&lt;li>回收白色集合内的所有对象&lt;/li>
&lt;/ol>
&lt;p>对于上述的算法来讲,仍然需要依赖STW的。因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。&lt;/p>
&lt;p>在三色标记法过程中对象丢失需要同时满足两个条件：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>条件一&lt;/strong>：白色对象被黑色对象引用&lt;/li>
&lt;li>&lt;strong>条件二&lt;/strong>：灰色对象和白色对象之间的可达关系遭到破坏&lt;/li>
&lt;/ul>
&lt;p>Go 团队提出两个解决方案&lt;/p>
&lt;ul>
&lt;li>&lt;strong>强三色不变式&lt;/strong>：不允许黑色对象引用白色对象，破坏条件一&lt;/li>
&lt;li>&lt;strong>弱三色不变式&lt;/strong>：黑色对象可以引用白色对象，但是白色对象的上游必须存在灰色对象，破坏条件二&lt;/li>
&lt;/ul>
&lt;p>Go 团队基于上述不变式提出两种实现机制：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>插入写屏障&lt;/strong>（满足强三色不变式）
&lt;ul>
&lt;li>规则：当一个对象引用另一个对象时，将另一个对象标记为灰色&lt;/li>
&lt;li>劣势：无法管理栈操作，需要 STW 重新扫描栈&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>删除写屏障&lt;/strong>（满足弱三色不变式）
&lt;ul>
&lt;li>规则：在删除引用时，如果被删除引用的对象自身为灰色或者白色，那么会标记为灰色&lt;/li>
&lt;li>劣势：冗余扫描成本高，回收精度低&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="gc-v18">GC V1.8
&lt;/h3>&lt;p>1.8 版本使用&lt;strong>标记-清除算法，结合三色标记法和混合写屏障&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>GC 开始将栈上的所有可达对象均标记为黑色&lt;/li>
&lt;li>GC 期间，任何在栈上创建的新对象，均为黑色&lt;/li>
&lt;li>堆上被删除对象标记为灰色&lt;/li>
&lt;li>堆上被添加的对象标记为灰色&lt;/li>
&lt;/ol>
&lt;h2 id="gc-的触发时间">GC 的触发时间
&lt;/h2>&lt;ul>
&lt;li>主动触发：调用 &lt;code>runtime.GC()&lt;/code> 方法&lt;/li>
&lt;li>被动触发：
&lt;ul>
&lt;li>定时触发，该触发条件由 &lt;code>runtime.forcegcperiod&lt;/code> 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，触发 GC&lt;/li>
&lt;li>根据内存分配阈值触发，该触发条件由环境变量 GOGC 控制，默认值为100（100%），当前堆内存占用是上次 GC 结束后占用内存的 2 倍时，触发 GC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="gc-调优">GC 调优
&lt;/h2>&lt;ul>
&lt;li>控制内存分配的速度，限制&lt;code>Goroutine&lt;/code>的数量，提高赋值器&lt;code>mutator&lt;/code>的CPU利用率(降低GC的CPU利用率)&lt;/li>
&lt;li>少量使用&lt;code>+&lt;/code>连接&lt;code>string&lt;/code>&lt;/li>
&lt;li>&lt;code>slice&lt;/code>提前分配足够的内存来降低扩容带来的拷贝&lt;/li>
&lt;li>避免&lt;code>map key&lt;/code>对象过多，导致扫描时间增加&lt;/li>
&lt;li>变量复用，减少对象分配，例如使用&lt;code>sync.Pool&lt;/code>来复用需要频繁创建临时对象，使用全局变量&lt;/li>
&lt;li>增大&lt;code>GOGC&lt;/code>的值，降低GC的运行频率&lt;/li>
&lt;/ul></description></item><item><title>Go八股之GMP调度模型</title><link>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bgmp%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 13 Jan 2025 14:46:19 +0800</pubDate><guid>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bgmp%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h2 id="历史背景">历史背景
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">&lt;/th>
&lt;th style="text-align: center">含义&lt;/th>
&lt;th style="text-align: center">缺点&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">进程时代&lt;/td>
&lt;td style="text-align: center">一个程序就是一个进程，所有进程严格按照时间执行&lt;/td>
&lt;td style="text-align: center">进程阻塞十分损耗性能、只能串行执行任务&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">线程时代&lt;/td>
&lt;td style="text-align: center">一个进程阻塞，可以切换到其他进程&lt;/td>
&lt;td style="text-align: center">上下文切换成本高、协程内存占用较高&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">协程时代&lt;/td>
&lt;td style="text-align: center">协程绑定线程，CPU 调度线程执行&lt;/td>
&lt;td style="text-align: center">实现复杂，协程和线程的绑定依赖调度器算法&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="gmp-调度模型是什么">GMP 调度模型是什么
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131539627.png"
loading="lazy"
alt="image-20250113153916514"
>&lt;/p>
&lt;p>G：&lt;em>Goroutine&lt;/em>，是 Go 的用户级线程，每个 go 关键字都会创建一个 Goroutine。其数量理论上只受内存大小影响。&lt;/p>
&lt;p>M：&lt;em>Machine&lt;/em>，Go 对&lt;strong>操作系统线程&lt;/strong>的封装，M在绑定有效的 P 后，进入一个调度循环，而调度循环的机制大致是从 P 的本地运行队列以及全局队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。&lt;strong>M的数量有限制，默认数量限制是 10000&lt;/strong>，可以通过 debug.SetMaxThreads() 方法进行设置，如果有M空闲，那么就会回收或者睡眠。&lt;/p>
&lt;p>P：&lt;em>Processor&lt;/em>，&lt;strong>虚拟处理器，M执行G所需要的资源和上下文，只有将 P 和 M 绑定，才能让 P 的 runq 中的 G 真正运行起来&lt;/strong>。P的数量受本机的CPU核数影响，可通过环境变量$GOMAXPROCS或在runtime.GOMAXPROCS()来设置，默认为CPU核心数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//src/runtime/runtime2.go
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">g&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">goid&lt;/span> &lt;span class="kt">int64&lt;/span> &lt;span class="c1">// 唯一的goroutine的ID
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">sched&lt;/span> &lt;span class="nx">gobuf&lt;/span> &lt;span class="c1">// goroutine切换时，用于保存g的上下文
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">stack&lt;/span> &lt;span class="nx">stack&lt;/span> &lt;span class="c1">// 栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gopc&lt;/span> &lt;span class="c1">// pc of go statement that created this goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">startpc&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// pc of goroutine function
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">lock&lt;/span> &lt;span class="nx">mutex&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">id&lt;/span> &lt;span class="kt">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">status&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// one of pidle/prunning/...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Queue of runnable goroutines. Accessed without lock.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runqhead&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// 本地队列队头
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runqtail&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// 本地队列队尾
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runq&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">256&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">guintptr&lt;/span> &lt;span class="c1">// 本地队列，大小256的数组，数组往往会被都读入到缓存中，对缓存友好，效率较高
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runnext&lt;/span> &lt;span class="nx">guintptr&lt;/span> &lt;span class="c1">// 下一个优先执行的goroutine（一定是最后生产出来的)，为了实现局部性原理，runnext中的G永远会被最先调度执行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">m&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">g0&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 每个M都有一个自己的G0，不指向任何可执行的函数，在调度或系统调用时，M会切换到G0，使用G0的栈空间来调度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">curg&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 当前正在执行的G
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">schedt&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">runq&lt;/span> &lt;span class="nx">gQueue&lt;/span> &lt;span class="c1">// 全局队列，链表（长度无限制）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runqsize&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">// 全局队列长度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="go-调度原理">Go 调度原理
&lt;/h2>&lt;h3 id="调度对象">调度对象
&lt;/h3>&lt;ul>
&lt;li>G 的来源
&lt;ul>
&lt;li>P 的 runnext（1 个 G）&lt;/li>
&lt;li>P 的本地队列（数组，最多 256 个 G）&lt;/li>
&lt;li>全局 G 队列（链表，G 数量无限制）&lt;/li>
&lt;li>网络轮询器（存放网络调用阻塞的 G）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>P 的来源
&lt;ul>
&lt;li>全局 P 队列（数组，GOMAXPROCS个P）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>M 的来源
&lt;ul>
&lt;li>休眠线程队列（未绑定 P，长时间休眠会等待GC回收销毁）&lt;/li>
&lt;li>运行线程（绑定 P，指向 P 中的 G）&lt;/li>
&lt;li>自旋线程（绑定 P，指向 M 的 G0）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="goroutine-调度流程">Goroutine 调度流程
&lt;/h3>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131542604.png"
loading="lazy"
alt="image-20250113154209545"
>&lt;/p>
&lt;p>上图是一个完整调度流程：&lt;/p>
&lt;ol>
&lt;li>通过 go func() 创建一个 &lt;em>G&lt;/em>&lt;/li>
&lt;li>创建的 &lt;em>G&lt;/em> 优先保存到本地队列 &lt;em>P&lt;/em>，若本地 &lt;em>P&lt;/em> 已满则进去全局队列&lt;/li>
&lt;li>唤醒或者新建 &lt;em>M&lt;/em> 执行任务，进入调度循环（4，5，6)&lt;/li>
&lt;li>&lt;em>M&lt;/em> 依次会从本地队列 &lt;em>P&lt;/em>，全局队列，其他本地队列 &lt;em>P&lt;/em> 获取 &lt;em>G&lt;/em>&lt;/li>
&lt;li>&lt;em>M&lt;/em> 调度和执行 &lt;em>G&lt;/em>
&lt;ul>
&lt;li>如果 &lt;em>M&lt;/em> 在执行 &lt;em>G&lt;/em> 的过程发生&lt;strong>系统调用阻塞&lt;/strong>（同步），会阻塞 &lt;em>G&lt;/em> 和 &lt;em>M&lt;/em>（操作系统限制），此时 &lt;em>P&lt;/em> 会和当前 &lt;em>M&lt;/em> 解绑，并寻找新的 &lt;em>M&lt;/em>，如果没有空闲的 &lt;em>M&lt;/em> 就会新建一个 &lt;em>M&lt;/em> ，接管正在阻塞G所属的P，接着继续执行 P中其余的G，这种阻塞后释放P的方式称之为hand off。当&lt;strong>系统调用结束&lt;/strong>后，这个G会尝试获取一个空闲的P执行，优先获取之前绑定的P，并放入到这个P的本地队列，如果获取不到P，那么这个线程M变成休眠状态，加入到空闲线程中，然后这个G会被放入到全局队列中。&lt;/li>
&lt;li>如果M在执行G的过程发生网络IO等操作阻塞时（异步），阻塞G，&lt;strong>不会阻塞M&lt;/strong>。M会寻找P中其它可执行的G继续执行，G会被网络轮询器network poller 接手，当阻塞的G恢复后，G1从network poller 被移回到P的 LRQ 中，重新进入可执行状态。异步情况下，通过调度，Go scheduler 成功地将 I/O 的任务转变成了 CPU 任务，或者说将内核级别的线程切换转变成了用户级别的 goroutine 切换，大大提高了效率。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;em>M&lt;/em> 执行完 &lt;em>G&lt;/em> 后清理现场，重新进入调度循环（将 M 上运⾏的goroutine切换为G0，G0负责调度时协程的切换）&lt;/li>
&lt;/ol>
&lt;h3 id="调度器生命周期">调度器生命周期
&lt;/h3>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501132210897.png"
loading="lazy"
alt="image-20250113221048794"
>&lt;/p>
&lt;ul>
&lt;li>M0：M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。&lt;/li>
&lt;li>G0：G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。&lt;/li>
&lt;/ul>
&lt;h3 id="调度时机">调度时机
&lt;/h3>&lt;ul>
&lt;li>抢占式调度
&lt;ul>
&lt;li>sysmon检测到协程运行过久(比如sleep，死循环)&lt;/li>
&lt;li>切换到g0，进入调度循环&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>主动调度
&lt;ul>
&lt;li>新起一个协程和协程执行完毕触发调度循环&lt;/li>
&lt;li>主动调用runtime.Gosched()切换到g0，进入调度循环&lt;/li>
&lt;li>垃圾回收之后。stw之后，会重新选择g开始执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>被动调度
&lt;ul>
&lt;li>系统调用(比如文件IO)阻塞(同步)，阻塞G和M，P与M分离，将P交给其它M绑定，其它M执行P的剩余G&lt;/li>
&lt;li>网络IO调用阻塞(异步) ，阻塞G，G移动到NetPoller，M执行P的剩余G&lt;/li>
&lt;li>atomic/mutex/channel等阻塞(异步)，阻塞G，G移动到channel的等待队列中，M执行P的剩余G&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="如何挑选下一个执行的-goroutine">如何挑选下一个执行的 Goroutine
&lt;/h3>&lt;ol>
&lt;li>每执行61次调度循环，从全局队列获取G，若有则直接返回&lt;/li>
&lt;li>从P上的runnext看一下是否有G，若有则直接返回&lt;/li>
&lt;li>从P上的本地队列看一下是否有G，若有则直接返回&lt;/li>
&lt;li>上面都没查找到时，则去全局队列、网络轮询器查找或者从其他Р中窃取,t一直阻塞直到获取到一个可用 的G为止&lt;/li>
&lt;/ol>
&lt;p>netpoller中拿到的G是 &lt;code>_Gwaiting状态&lt;/code>（存放的是因为网络IO被阻塞的G)，从其它地方拿到的是&lt;code>_Grunnable状态&lt;/code>&lt;/p>
&lt;h3 id="goroutine-的调度方式">Goroutine 的调度方式
&lt;/h3>&lt;h4 id="基于协作的抢占式调度流程12-版本实现">基于协作的抢占式调度流程（1.2 版本实现）
&lt;/h4>&lt;ol>
&lt;li>编译器会在调用函数前插入runtime.morestack，让运行时有机会在这段代码中检查是否需要执行抢占
调度&lt;/li>
&lt;li>Go语言运行时会在垃圾回收暂停程序、系统监控发现Goroutine运行超过10ms，那么会在这个协程设置
一个抢占标记&lt;/li>
&lt;li>当发生函数调用时，可能会执行编译器插入的runtime.morestack，它调用的runtime.newstack会检查抢
占标记，如果有抢占标记就会触发抢占让出cpu，切到调度主协程里&lt;/li>
&lt;/ol>
&lt;p>只能局部解决问题，只在有函数调用的地方才能插入“抢占”代码（埋点），对于没有函数调用而是纯算法循环计算的 G，Go 调度器依然无法抢占。&lt;/p>
&lt;h4 id="基于信号的抢占式调度114版本实现">基于信号的抢占式调度（1.14版本实现）
&lt;/h4>&lt;ol>
&lt;li>M注册一个SIGURG信号的处理函数:sighandler&lt;/li>
&lt;li>sysmon启动后会间隔性的进行监控，最长间隔10ms，最短间隔20us。如果发现某协程独占
P超过10ms，会给M发送抢占信号&lt;/li>
&lt;li>M收到信号后，内核执行sighandler函数把当前协程的状态从_Grunning正在执行改成_Grunnable可执
行，把抢占的协程放到全局队列里，M继续寻找其他goroutine来运行&lt;/li>
&lt;li>被抢占的G再次调度过来执行时，会继续原来的执行流&lt;/li>
&lt;/ol>
&lt;p>抢占分为&lt;code>_Prunning&lt;/code>和&lt;code>_Psyscall&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>_Psyscall&lt;/code>抢占通常是由于阻塞性系统调用引起的，比如磁盘io、cgo。&lt;/li>
&lt;li>&lt;code>_Prunning&lt;/code>抢占通常是由于一些类似死循环的计算逻辑引起的。&lt;/li>
&lt;/ul>
&lt;h2 id="work-staeling--hand-off">work staeling &amp;amp; hand off
&lt;/h2>&lt;h3 id="work-stealing-机制">work stealing 机制
&lt;/h3>&lt;p>当线程M⽆可运⾏的G时，尝试从其他M绑定的 P （每次选择的 P 不一定相同）偷取 G（当前 P 中一半的 G），减少空转，提高了线程利用率。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131639460.png"
loading="lazy"
alt="image-20250113163923392"
>&lt;/p>
&lt;h3 id="hand-off-机制">hand off 机制
&lt;/h3>&lt;p>也称为 P 分离机制，当线程 M 因为 G 进行的系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的 M 执行，也提高了线程利用率。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131646778.png"
loading="lazy"
alt="image-20250113164624713"
>&lt;/p></description></item><item><title>Go八股之Goroutine</title><link>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bgoroutine/</link><pubDate>Sun, 12 Jan 2025 16:55:26 +0800</pubDate><guid>https://the-oone.github.io/p/go%E5%85%AB%E8%82%A1%E4%B9%8Bgoroutine/</guid><description>&lt;h2 id="为什么需要-goroutine">为什么需要 Goroutine
&lt;/h2>&lt;p>简单一句话，Goroutine 相比线程拥有更优越的开销性能。&lt;/p>
&lt;p>这里先简单介绍下进程、线程、协程：&lt;/p>
&lt;ul>
&lt;li>进程：操作系统创建、资源分配的基本单位、同一个进程内的线程会共享资源。&lt;/li>
&lt;li>线程：操作系统创建、CPU 调度的基本单位、有独立的堆栈空间&lt;/li>
&lt;li>协程：可通过用户程序创建
&lt;ul>
&lt;li>有栈协程：golang&lt;/li>
&lt;li>无栈协程：c++，rust 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Goroutine 就是一个用户级线程，相比传统线程更加轻量（传统协程 1 MB，Goroutine 约 2 KB）。其不涉及内核态的切换，因此 golang 的并发性能很好。&lt;/p>
&lt;h2 id="如何关闭-goroutine">如何关闭 Goroutine
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>关闭 channel&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 根据第二个参数进行判别，当关闭 channel 时，根据其返回结果跳出
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>定期轮询 channel&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">done&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="s">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">done&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ch&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">done&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;接收到的值：&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;over&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>变量 done 作为 channel 类型，用作信号量处理 Goroutine 的关闭。for-loop 结合 select 进行监听，处理完业务之后才会调用 close 关闭 channel。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 context&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">cancel&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WithCancel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Background&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">default&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">cancel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;over&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 context 中，可以借助 ctx.Done 获取一个只读的 channel，可用来识别当前 channel 是否已被关闭。context 对于跨 Goroutine 控制灵活，可以调动 context.WithTimeout 根据时间，或者主动调用 cancel 方法手动关闭。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="如何实现并行-goroutine">如何实现并行 Goroutine
&lt;/h2>&lt;p>通过设置最大的可同时使用的 CPU 核心数&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 设置并行 Goroutine 数量为 2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GOMAXPROCS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="为什么不能大量使用-goroutine">为什么不能大量使用 Goroutine
&lt;/h2>&lt;ul>
&lt;li>虽然 Goroutine 的初始栈（自动扩容）很小，但是大部分业务需要更多的栈空间，而频繁的扩容需要很大的成本。&lt;/li>
&lt;li>Golang 的 GMP 调度模型中的 M 和 P 是有数量限制的，大量的 Goroutine 会导致过长的调度队列，从而影响性能。&lt;/li>
&lt;li>过多的 Goroutine 还会导致频繁的 GC，影响性能。&lt;/li>
&lt;/ul>
&lt;h2 id="goroutine-a-能否停止另一个-goroutine">Goroutine A 能否停止另一个 Goroutine
&lt;/h2>&lt;p>不能。Goroutine 只有自己主动退出，不能被外界的 Goroutine 关闭。&lt;/p>
&lt;h2 id="父-goroutine-退出子-goroutine-一定会退出嘛">父 Goroutine 退出，子 Goroutine 一定会退出嘛
&lt;/h2>&lt;ul>
&lt;li>当&lt;strong>父 Goroutine 为 main&lt;/strong> 时，所有的子 Goroutine 都&lt;strong>会&lt;/strong>跟着父 Goroutine 退出&lt;/li>
&lt;li>若&lt;strong>父 Goroutine 不为 main&lt;/strong> 时，子 Goroutine &lt;strong>不会&lt;/strong>跟着父 Goroutine 退出&lt;/li>
&lt;/ul>
&lt;h2 id="goroutine-的状态流转">Goroutine 的状态流转
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501132129821.png"
loading="lazy"
alt="image-20250113212939765"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">&lt;/th>
&lt;th style="text-align: center">状态&lt;/th>
&lt;th style="text-align: center">含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">_Gidle&lt;/td>
&lt;td style="text-align: center">空闲态&lt;/td>
&lt;td style="text-align: center">G 刚刚创建，还未初始化&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Grunnable&lt;/td>
&lt;td style="text-align: center">就绪态&lt;/td>
&lt;td style="text-align: center">G 在运行队列，等待 M 取出（此时 M 有 P）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Grunning&lt;/td>
&lt;td style="text-align: center">运行态&lt;/td>
&lt;td style="text-align: center">M 正在运行 G&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Gsyscall&lt;/td>
&lt;td style="text-align: center">系统调用&lt;/td>
&lt;td style="text-align: center">M 中运行的 G 发起系统调用（此时 M 无 P）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Gwaiting&lt;/td>
&lt;td style="text-align: center">阻塞态&lt;/td>
&lt;td style="text-align: center">G 等待执行资源&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Gdead&lt;/td>
&lt;td style="text-align: center">完成态&lt;/td>
&lt;td style="text-align: center">G 已经执行完毕&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Gcopystack&lt;/td>
&lt;td style="text-align: center">复制栈&lt;/td>
&lt;td style="text-align: center">G 正获取一个新的栈空间，并将原内容复制过去&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="goroutine-泄露">Goroutine 泄露
&lt;/h2>&lt;p>Goroutine 没有被正确的关闭或管理，会导致他们在程序运行过程中无法被回收，最终导致资源浪费和潜在的性能问题&lt;/p>
&lt;h3 id="泄露原因">泄露原因
&lt;/h3>&lt;ul>
&lt;li>Goroutine 内部进行 channel/mutex 等读写操作被一直阻塞&lt;/li>
&lt;li>Goroutine 内的业务逻辑进入死循环，资源无法释放&lt;/li>
&lt;li>Goroutine 内的业务逻辑进入长时间等待，又不断新增的 Goroutine 进入等待&lt;/li>
&lt;/ul>
&lt;h3 id="泄露场景">泄露场景
&lt;/h3>&lt;ul>
&lt;li>未初始化 channel&lt;/li>
&lt;li>channel 发送未接收&lt;/li>
&lt;li>channel 接收未发送&lt;/li>
&lt;li>资源连接未关闭&lt;/li>
&lt;li>未成功解锁&lt;/li>
&lt;li>死循环&lt;/li>
&lt;li>sync.WaitGroup 使用不当&lt;/li>
&lt;/ul>
&lt;h2 id="多个协程交替打印奇偶数字">多个协程交替打印奇偶数字
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;sync&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 创建两个channel用于同步
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">even&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">odd&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 创建WaitGroup等待所有协程完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">wg&lt;/span> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">WaitGroup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 打印偶数的协程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">defer&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">even&lt;/span> &lt;span class="c1">// 等待偶数信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;偶数: %d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">odd&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span> &lt;span class="c1">// 发送奇数信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 最后一次打印完需要再消费一次even channel,避免死锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">even&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 打印奇数的协程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">defer&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;奇数: %d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">even&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span> &lt;span class="c1">// 发送偶数信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">odd&lt;/span> &lt;span class="c1">// 等待奇数信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 最后发送一次信号给偶数协程,让其能够退出
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">even&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 等待所有协程完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 关闭channel
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">even&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">odd&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Redis 数据类型</title><link>https://the-oone.github.io/p/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Wed, 18 Dec 2024 21:30:01 +0800</pubDate><guid>https://the-oone.github.io/p/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>&lt;h2 id="string">String
&lt;/h2>&lt;p>String 的底层数据结构是 int 和 SDS（Simple Dynamic String），相比 C 的原生字符串，增加了以下功能&lt;/p>
&lt;ol>
&lt;li>保存二进制文件&lt;/li>
&lt;li>获取字符串长度的时间复杂度是 O(1)&lt;/li>
&lt;li>SDS API 内存安全，保证不会造成缓冲区溢出&lt;/li>
&lt;/ol>
&lt;h3 id="内部编码">内部编码
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>int&lt;/strong>，若字符串保存的是整数值，并且可以转换为 long，那么该字符串对象的编码被设置为 &lt;code>int&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412182154153.png"
loading="lazy"
alt="image-20241218215412113"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>embstr&lt;/strong>，若字符串长度小于等于 44 字节（博主测试环境为 Redis 7.4.1），那么使用 &lt;code>embstr&lt;/code> 编码，&lt;strong>一次内存分配&lt;/strong>。只读，修改内容需先转换 &lt;code>raw&lt;/code> 编码。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412182150682.png"
loading="lazy"
alt="image-20241218215051546"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>raw&lt;/strong>，若字符串长度大于 44 字节，那么使用 &lt;code>raw&lt;/code> 编码，&lt;strong>两次内存分配&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412182151676.png"
loading="lazy"
alt="image-20241218215124643"
>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="常用指令">常用指令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/set/" target="_blank" rel="noopener"
>SET&lt;/a>&lt;/p>
&lt;p>设置 key 为字符串值。 如果 key 已有值，无论其类型如何，都会被覆盖。 在 SET 操作成功后，之前与键值相关的任何生存时间都将被丢弃。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SET key value [NX | XX] [GET] [EX seconds | PX milliseconds |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;code>EX&lt;/code> &amp;ndash; 设置指定的过期时间，以秒（正整数）为单位。&lt;/li>
&lt;li>&lt;code>PX&lt;/code> &amp;ndash; 设置指定的过期时间，以毫秒（正整数）为单位。&lt;/li>
&lt;li>&lt;code>EXAT&lt;/code> &amp;ndash; 设置指定的密钥过期时间，以秒（正整数）为单位。&lt;/li>
&lt;li>&lt;code>PXAT&lt;/code> &amp;ndash; 设置密钥过期的 Unix 时间，以毫秒为单位（正整数）。&lt;/li>
&lt;li>&lt;code>NX&lt;/code> &amp;ndash; 当且仅当 key 不存在时才设置。&lt;/li>
&lt;li>&lt;code>XX&lt;/code> &amp;ndash; 无论如何都会设置 key。&lt;/li>
&lt;li>&lt;code>KEEPTTL&lt;/code> &amp;ndash; 继承上一个 key 的有效时间。&lt;/li>
&lt;li>&lt;code>GET&lt;/code> &amp;ndash; 返回存储在密钥中的旧字符串，如果密钥不存在，则返回 nil。 如果键值不是字符串，会返回错误并中止 SET。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/mset/" target="_blank" rel="noopener"
>MSET&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/msetnx/" target="_blank" rel="noopener"
>MSETNX&lt;/a>&lt;/p>
&lt;p>将给定的键设置为各自的值。 两者都是原子式的，因此所有给定键都会被一次性设置。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">MSET key value [key value ...]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">MSETNX key value [key value ...] # key 必须均不存在
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/incr/" target="_blank" rel="noopener"
>INCR&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/incrby/" target="_blank" rel="noopener"
>INCRBY&lt;/a>&lt;/p>
&lt;p>对 key 中存储数字进行加法操作，如果键不存在，则在执行操作前将其设置为 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">INCR key # 将存储在键上的数字递增 1。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">INCRBY key increment # 将存储在键上的数字递增 increment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/decr/" target="_blank" rel="noopener"
>DECR&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/decrby/" target="_blank" rel="noopener"
>DECRBY&lt;/a>&lt;/p>
&lt;p>对 key 中存储数字进行减法操作，如果键不存在，则在执行操作前将其设置为 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">DECR key # 将存储在键上的数字递减 1。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">DECRBY key increment # 将存储在键上的数字递减 increment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/get/" target="_blank" rel="noopener"
>GET&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/mget/" target="_blank" rel="noopener"
>MGET&lt;/a>&lt;/p>
&lt;p>获取 key 的值。 如果键不存在，则返回特殊值 nil。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GET key
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">MGET key [key ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景">应用场景
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>缓存对象&lt;/p>
&lt;/li>
&lt;li>
&lt;p>计数器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分布式锁&lt;/p>
&lt;ul>
&lt;li>
&lt;p>若 key 不存在，则显示插入成功，表示加锁成功&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若 key 存在，则显示插入失败，表示加锁失败&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要配合 Lua 脚本实现原子性&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>共享 Session 信息&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="list">List
&lt;/h2>&lt;p>List 是简单的字符串列表（&lt;strong>按照插入顺序排序&lt;/strong>），可以从头部或者尾部向 List 添加元素，链表最大长度为&lt;code> $2^{32}-1$&lt;/code>&lt;/p>
&lt;h3 id="内部实现">内部实现
&lt;/h3>&lt;ul>
&lt;li>3.2 版本之前由双向链表或压缩链表实现。&lt;/li>
&lt;li>3.2 版本之后由 QuickList 实现。其是多个节点（压缩列表）组成的双向链表，每个元素可以是一个整数或一个字节数组。&lt;/li>
&lt;/ul>
&lt;h3 id="常用指令-1">常用指令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lpush/" target="_blank" rel="noopener"
>LPUSH&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/rpush/" target="_blank" rel="noopener"
>RPUSH&lt;/a>&lt;/p>
&lt;p>将所有指定值插入存储在 key 处的列表头部。 如果 key 不存在，则在执行推送操作前将其创建为空列表。 如果 key 持有的值不是 list，则会返回错误信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LPUSH/RPUSH key element [element ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;div>&lt;table frame=void> &lt;!--用了&lt;div>进行封装-->
&lt;tr>
&lt;td>&lt;div>&lt;center> &lt;!--每个格子内是图片加标题-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271043542.png"
alt="LPUSH 命令"
height="120"/> &lt;!--高度设置-->
&lt;br> &lt;!--换行-->
LPUSH 命令 &lt;!--标题1-->
&lt;/center>&lt;/div>&lt;/td>
&lt;td>&lt;div>&lt;center> &lt;!--第二张图片-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271044094.png"
alt="RPUSH 命令"
height="120"/>
&lt;br>
RPUSH 命令
&lt;/center>&lt;/div>&lt;/td>
&lt;/tr>
&lt;/table>&lt;/div>
&lt;ol start="2">
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lpushx/" target="_blank" rel="noopener"
>LPUSHX&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/rpushx/" target="_blank" rel="noopener"
>RPUSHX&lt;/a>&lt;/p>
&lt;p>仅在 key 已存在并持有一个列表的情况下，在 key 所在列表的首部插入指定值。 如果 key 不存在，则不会执行任何操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LPUSHX/RPUSHX key element [element ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lpop/" target="_blank" rel="noopener"
>LPOP&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/rpop/" target="_blank" rel="noopener"
>RPOP&lt;/a>&lt;/p>
&lt;p>删除并返回存储在 key 处的列表的 &lt;strong>最初/最后&lt;/strong> 一个元素。 默认情况下，该命令从列表 &lt;strong>头部/尾部&lt;/strong> 弹出一个元素。 如果提供了可选的 count 参数，则根据列表的长度，回复最多包含 count 个元素。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LPOP/RPOP key [count]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271354782.png"
loading="lazy"
alt="image-20241227135404729"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/blpop/" target="_blank" rel="noopener"
>BLPOP&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/brpop/" target="_blank" rel="noopener"
>BRPOP&lt;/a>&lt;/p>
&lt;p>&lt;strong>BLPOP/BRPOP&lt;/strong> 是一种阻塞列表弹出原语。 它是 &lt;strong>LPOP/RPOP&lt;/strong> 的阻塞版本，因为当没有元素从任何给定列表中弹出时，它会阻塞连接。 元素会从第一个非空列表的 &lt;strong>头部/尾部&lt;/strong> 弹出，并按照给定键的顺序进行检查。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">BLPOP/RLPOP key [key ...] timeout
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lindex/" target="_blank" rel="noopener"
>LINDEX&lt;/a>&lt;/p>
&lt;p>返回存储在 key 中的列表中位于 index 索引处的元素。 索引以 0 为单位，因此 0 表示第一个元素，1 表示第二个元素，以此类推。 负指数可用于指定从列表尾部开始的元素。 这里，-1 表示最后一个元素，-2 表示倒数第二个元素，以此类推。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LINDEX key index
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/llen/" target="_blank" rel="noopener"
>LLEN&lt;/a>&lt;/p>
&lt;p>返回存储在 key 处的 list 的长度。 如果 key 不存在，则将其解释为空列表，并返回 0。 如果 key 中存储的值不是 list，则会返回错误信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LLEN key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lrange/" target="_blank" rel="noopener"
>LRANGE&lt;/a>&lt;/p>
&lt;p>返回存储在 key 处的列表的指定元素。 偏移量 start 和 stop 是基于 0 的索引，0 代表列表的第一个元素（列表的头），1 代表下一个元素，以此类推。 这些偏移量也可以是负数，表示从列表的末尾开始的偏移量。 例如，-1 是列表的最后一个元素，-2 是倒数第二个元素，以此类推。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LRANGE key start stop
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lrem/" target="_blank" rel="noopener"
>LREM&lt;/a>&lt;/p>
&lt;p>从存储在 key 处的列表中移除与元素相同的元素的第一个出现次数。 计数参数对操作的影响如下：count &amp;gt; 0：删除从头部移到尾部的与元素相同的元素。 count &amp;lt; 0：删除从尾部移到头部的与元素相同的元素。 例如，LREM list -2 &amp;ldquo;hello &amp;ldquo;将删除存储在 list 中的 &amp;ldquo;hello &amp;ldquo;的最后两次出现。 请注意，不存在的键会被当作空 list 处理。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LREM key count element
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/ltrim/" target="_blank" rel="noopener"
>LTRIM&lt;/a>&lt;/p>
&lt;p>裁剪现有列表，使其只包含指定范围的元素。 start 和 stop 都是基于 0 的索引，其中 0 代表列表的第一个元素（头部），1 代表下一个元素，依此类推。 例如，LTRIM foobar 0 2 将修改存储在 foobar 处的列表，使其只保留列表的前三个元素： start 和 end 也可以是负数，表示与列表末尾的偏移量，其中 -1 表示列表的最后一个元素，-2 表示倒数第二个元素，依此类推。 超出范围的索引不会产生错误：如果 start 大于列表末尾，或 start &amp;gt; end，结果将是一个空列表（导致键被移除）。 如果 end 大于列表末尾，Redis 会将其视为列表的最后一个元素。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LTRIM key start stop
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lset/" target="_blank" rel="noopener"
>LSET&lt;/a>&lt;/p>
&lt;p>将索引处的列表元素设置为指定值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LSET key index element
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/linsert/" target="_blank" rel="noopener"
>LINSERT&lt;/a>&lt;/p>
&lt;p>将元素插入存储在 key 处的列表中的参考值 pivot 之前或之后。 如果 key 不存在，则视为空列表，不执行任何操作。 如果 key 存在但不包含列表值，则返回错误信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LINSERT key &amp;lt;BEFORE | AFTER&amp;gt; pivot element
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/brpoplpush/" target="_blank" rel="noopener"
>BRPOPLPUSH&lt;/a>&lt;/p>
&lt;p>BRPOPLPUSH 是 RPOPLPUSH 的阻塞变体。 当源代码包含元素时，该命令的行为与 RPOPLPUSH 完全相同。 在 MULTI/EXEC 块内使用时，该命令的行为与 RPOPLPUSH 完全相同。 当源为空时，Redis 会阻塞连接，直到有其他客户端向其推送或超时。 如果超时为零，则会无限期阻塞。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">BRPOPLPUSH source destination timeout
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-1">应用场景
&lt;/h3>&lt;ul>
&lt;li>消息队列
&lt;ul>
&lt;li>&lt;strong>消息保存&lt;/strong>：LPUSH + RPOP / RPUSH+LPOP 实现消息队列（使用 BRPOP 命令进行阻塞式读取，减少消费者性能损失）&lt;/li>
&lt;li>&lt;strong>重复消息处理&lt;/strong>：生产者实现全局唯一 ID&lt;/li>
&lt;li>&lt;strong>消息可靠性&lt;/strong>：BRPOPLPUSH（使得消费者从一个 List 中读取消息，同时 Redis 还会把消息再插入到另一个 List 留存）&lt;/li>
&lt;li>&lt;em>List 不支持多个消费者消费同一条信息&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="hash">Hash
&lt;/h2>&lt;p>Hash 是一个 key-value 集合，&lt;/p>
&lt;h3 id="内部实现-1">内部实现
&lt;/h3>&lt;div>&lt;table frame=void> &lt;!--用了&lt;div>进行封装-->
&lt;tr>
&lt;td>&lt;div>&lt;center> &lt;!--每个格子内是图片加标题-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271430099.png"
alt="压缩列表"
height="130"/> &lt;!--高度设置-->
&lt;br> &lt;!--换行-->
listpack &lt;!--标题1-->
&lt;/center>&lt;/div>&lt;/td>
&lt;td>&lt;div>&lt;center> &lt;!--第二张图片-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271431225.png"
alt="哈希表"
height="130"/>
&lt;br>
hashtable
&lt;/center>&lt;/div>&lt;/td>
&lt;/tr>
&lt;/table>&lt;/div>
&lt;ul>
&lt;li>如果 Hash 元素小于 512（默认） 个，所有值小于 64 字节（默认）时，Redis 会使用 listpack 作为底层数据结构。&lt;/li>
&lt;li>剩余情况，Redis 会使用 hashtable实现&lt;/li>
&lt;/ul>
&lt;h3 id="常用命令">常用命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hset/" target="_blank" rel="noopener"
>HSET&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/hsetnx/" target="_blank" rel="noopener"
>HSETNX&lt;/a>&lt;/p>
&lt;p>将指定字段的值设置为存储在 key 的哈希值中各自的值。 HSET 会覆盖哈希值中存在的指定字段的值，HSETNX 对于已存在的字段操作无效。 如果 key 不存在，则会创建一个新的散列键。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HSET key field value [field value ...]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HSETNX key field value
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hget/" target="_blank" rel="noopener"
>HGET&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/hmget/" target="_blank" rel="noopener"
>HMGET&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/hgetall/" target="_blank" rel="noopener"
>HGETALL&lt;/a>&lt;/p>
&lt;p>&lt;em>HGET/HMGET&lt;/em> 返回键存储的哈希值中与字段相关的值。 对于散列中不存在的每个字段，都会返回一个 nil 值。 由于不存在的键被视为空哈希值，因此针对不存在的键运行 HMGET 将返回一个 nil 值列表。&lt;/p>
&lt;p>&lt;em>HGETALL&lt;/em> 返回存储在 key 处的哈希值的所有字段和值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HGET key field
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HMGET key field [field ...]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HGETALL key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hdel/" target="_blank" rel="noopener"
>HDEL&lt;/a>&lt;/p>
&lt;p>从存储在 key 中的哈希值中删除指定字段。 不存在于散列中的指定字段将被忽略。 如果没有字段，则删除散列。 如果键不存在，则将其视为空散列，此命令返回 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HDEL key field [field ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hlen/" target="_blank" rel="noopener"
>HLEN&lt;/a>&lt;/p>
&lt;p>返回存储在 key 中的哈希值所包含字段的数量。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HLEN key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hexists/" target="_blank" rel="noopener"
>HEXISTS&lt;/a>&lt;/p>
&lt;p>如果字段是存储在 key 处的哈希值中的现有字段，则返回 1，否则返回 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HEXISTS key field
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hkeys/" target="_blank" rel="noopener"
>HKEYS&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/hvals/" target="_blank" rel="noopener"
>HVALS&lt;/a>&lt;/p>
&lt;p>&lt;em>HKEYS&lt;/em> 返回存储在 key 处的哈希值中的所有字段名。&lt;/p>
&lt;p>&lt;em>HVALS&lt;/em> 返回键存储的哈希值中的所有值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HKEYS key
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HVALS key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hincrby/" target="_blank" rel="noopener"
>HINCRBY&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/hincrbyfloat/" target="_blank" rel="noopener"
>HINCRBYFLOAT&lt;/a>&lt;/p>
&lt;p>&lt;em>HINCRBY&lt;/em> 按增量递增存储在 key 的哈希值中的字段数字。 如果 key 不存在，则会创建一个新的哈希值键。 如果字段不存在，则在执行操作前将其值设置为 0。&lt;/p>
&lt;p>&lt;em>HINCRBYFLOAT&lt;/em> 按指定增量递增存储在键值处的散列指定字段，该字段代表一个浮点数。 如果增量为负值，结果是哈希字段值递减而不是递增。 如果字段不存在，则在执行操作前将其设置为 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HINCRBY key field increment
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HINCRBYFLOAT key field increment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-2">应用场景
&lt;/h3>&lt;ul>
&lt;li>缓存对象
&lt;ul>
&lt;li>(key，field，value) 对应 (对象，属性，值)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>购物车
&lt;ul>
&lt;li>添加商品：HSET cart:{user_id}{goods_id} 1&lt;/li>
&lt;li>增加数量：HINCRBY cart:{user_id}{goods_id} 2&lt;/li>
&lt;li>商品总数：HLEN cart:{user_id}&lt;/li>
&lt;li>删除商品：HDEL cart:{user_id} {goods_id}&lt;/li>
&lt;li>获取所有商品：HGETALL cart:{usert_id}&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="set">Set
&lt;/h2>&lt;p>Set 是一个集合（最多支持存储 $2^{32}-1$ 个元素），其中元素&lt;strong>无序、唯一&lt;/strong>。除了支持集合内的增删改查，还支持多个集合交集、并集、差集。&lt;/p>
&lt;h3 id="内部实现-2">内部实现
&lt;/h3>&lt;ul>
&lt;li>如果集合元素都是整数，并且元素个数小于 512（默认），Redis 会使用 整数集合作为底层数据结构。&lt;/li>
&lt;li>其他情况，Redis 会使用 listpack 作为底层数据结构&lt;/li>
&lt;/ul>
&lt;div>&lt;table frame=void> &lt;!--用了&lt;div>进行封装-->
&lt;tr>
&lt;td>&lt;div>&lt;center> &lt;!--每个格子内是图片加标题-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271556118.png"
alt="整数集合"
height="130"/> &lt;!--高度设置-->
&lt;br> &lt;!--换行-->
intset &lt;!--标题1-->
&lt;/center>&lt;/div>&lt;/td>
&lt;td>&lt;div>&lt;center> &lt;!--第二张图片-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271558737.png"
alt="哈希表"
height="130"/>
&lt;br>
listpack
&lt;/center>&lt;/div>&lt;/td>
&lt;/tr>
&lt;/table>&lt;/div>
&lt;h3 id="常用命令-1">常用命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/sadd/" target="_blank" rel="noopener"
>SADD&lt;/a>&lt;/p>
&lt;p>将指定的成员添加到存储在 key 处的集合中。 如果指定的成员已经是这个集合的成员，则会被忽略。 如果 key 不存在，则会先创建一个新集合，然后再添加指定的成员。 如果存储在 key 中的值不是一个集合，则会返回错误信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SADD key member [member ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/srem/" target="_blank" rel="noopener"
>SREM&lt;/a>&lt;/p>
&lt;p>从存储在 key 处的集合中删除指定的成员。 不属于此集合的指定成员将被忽略。 如果 key 不存在，则将其视为空集，此命令返回 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SREM key member [member ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/smembers/" target="_blank" rel="noopener"
>SMEMBERS&lt;/a>&lt;/p>
&lt;p>返回存储在 key 处的集合值的所有成员。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SMEMBERS key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/sismember/" target="_blank" rel="noopener"
>SISMEMBER&lt;/a>&lt;/p>
&lt;p>返回成员是否是存储在 key 中的集合的成员。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SISMEMBER key member
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/scard/" target="_blank" rel="noopener"
>SCARD&lt;/a>&lt;/p>
&lt;p>返回存储在 key 处的集合的元素个数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SCARD key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/srandmember/" target="_blank" rel="noopener"
>SRANDMEMBER&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/spop/" target="_blank" rel="noopener"
>SPOP&lt;/a>&lt;/p>
&lt;p>&lt;em>SRANDMEMBER&lt;/em> 将从存储在 key 处的集合值中随机返回 count 个元素，元素不从 key 中删除。&lt;/p>
&lt;p>&lt;em>SPOP&lt;/em> 将从存储在 key 处的集合值中随机返回 count 个元素，元素从 key 中删除。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SRANDMEMBER key [count]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SPOP key [count]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/smove/" target="_blank" rel="noopener"
>SMOVE&lt;/a>&lt;/p>
&lt;p>将成员从源集合移动到目标集合。 该操作是原子操作。 如果源集合不存在或不包含指定元素，则不执行任何操作，并返回 0。 否则，该元素将从源集合中删除，并添加到目标集合中。 如果指定的元素已存在于目标集合中，则只会从源集合中移除。 如果源集合或目标集合中不存在集合值，则会返回错误信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SMOVE source destination member
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/sinter/" target="_blank" rel="noopener"
>SINTER&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/sinterstore/" target="_blank" rel="noopener"
>SINTERSTORE&lt;/a>&lt;/p>
&lt;p>&lt;em>SINTER&lt;/em> 返回所有给定集合的交集所产生的集合的成员。&lt;/p>
&lt;p>&lt;em>SINTERSTORE&lt;/em> 该命令等同于 SINTER，但不是返回结果集，而是将其存储在目的地中。 如果目的地已经存在，则会被覆盖。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SINTER key [key ...]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SINTERSTORE destination key [key ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-3">应用场景
&lt;/h3>&lt;ul>
&lt;li>点赞（元素唯一）&lt;/li>
&lt;li>共同好友（集合运算）
&lt;ul>
&lt;li>数据量较大时，可以让从库进行集合运算，将结果返回给客户端，防止 Redis 阻塞。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>抽奖（元素唯一，去重）&lt;/li>
&lt;/ul>
&lt;h2 id="zset">Zset
&lt;/h2>&lt;p>Zset 相较于 Set 多了个排序属性 score，每个存储元素相当于两个值组成，一个是有序集合的元素值，一个是排序值。&lt;/p>
&lt;h3 id="内部实现-3">内部实现
&lt;/h3>&lt;ul>
&lt;li>若 Zset 中元素小于 128 个，且每个元素小于 64 字节，Redis 使用 listpack 作为底层数据结构。&lt;/li>
&lt;li>剩余情况，Redis 会使用&lt;/li>
&lt;/ul>
&lt;div>&lt;table frame=void> &lt;!--用了&lt;div>进行封装-->
&lt;tr>
&lt;td>&lt;div>&lt;center> &lt;!--每个格子内是图片加标题-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271628134.png"
alt="listpack"
height="130"/> &lt;!--高度设置-->
&lt;br> &lt;!--换行-->
listpack &lt;!--标题1-->
&lt;/center>&lt;/div>&lt;/td>
&lt;td>&lt;div>&lt;center> &lt;!--第二张图片-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271628892.png"
alt="跳表"
height="130"/>
&lt;br>
skiplist
&lt;/center>&lt;/div>&lt;/td>
&lt;/tr>
&lt;/table>&lt;/div>
&lt;h3 id="常用命令-2">常用命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zadd/" target="_blank" rel="noopener"
>ZADD&lt;/a>&lt;/p>
&lt;p>将具有指定分数的所有指定成员添加到存储在 key 处的排序集合中。 可以指定多个分数/成员对。 如果指定的成员已经是排序集合的成员，则会更新得分，并将元素重新插入正确的位置，以确保排序正确。 如果 key 不存在，则会创建一个新的排序集合，并将指定的成员作为唯一成员，就像排序集合为空一样。 如果键存在，但没有排序集，则会返回错误信息。 分数值应是双精度浮点数的字符串表示。 +inf 和 -inf 值也是有效值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>XX&lt;/strong>: 只更新已存在的元素，不添加新元素。&lt;/li>
&lt;li>&lt;strong>NX&lt;/strong>: 只添加新元素，不更新已存在的元素。&lt;/li>
&lt;li>&lt;strong>LT&lt;/strong>: 只在新分数小于当前分数时更新现有元素。此标记不会阻止添加新元素。&lt;/li>
&lt;li>&lt;strong>GT&lt;/strong>: 仅在新分数大于当前分数时更新现有元素。 此标记不会阻止添加新元素。&lt;/li>
&lt;li>&lt;strong>CH&lt;/strong>: 将返回值从增加的新元素数量修改为改变的元素总数（CH 是 changed 的缩写）。 更改的元素是指新增的元素和已存在的元素，这些元素的分值已被更新。 因此，命令行中指定的元素如果得分与过去相同，则不计算在内。 注意：通常情况下，ZADD 的返回值只计算新增元素的数量。&lt;/li>
&lt;li>&lt;strong>INCR&lt;/strong>: 指定该选项时，ZADD 的作用与 ZINCRBY 类似。 在这种模式下，只能指定一个分数元素对。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zrem/" target="_blank" rel="noopener"
>ZREM&lt;/a>&lt;/p>
&lt;p>从存储在 key 中的排序集合中删除指定的成员。 如果 key 存在但没有排序集，则会返回错误信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZREM key member [member ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zscore/" target="_blank" rel="noopener"
>ZSCORE&lt;/a>&lt;/p>
&lt;p>返回排序集合中 key 处成员的得分。 如果排序集合中不存在成员或 key 不存在，则返回 nil。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZSCORE key member
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zcard/" target="_blank" rel="noopener"
>ZCARD&lt;/a>&lt;/p>
&lt;p>返回存储在 key 处的排序集的元素个数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZCARD key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zincrby/" target="_blank" rel="noopener"
>ZINCRBY&lt;/a>&lt;/p>
&lt;p>用增量递增键值存储的排序集合中成员的得分。 如果成员不存在于排序集合中，则会以增量作为其得分（就像它之前的得分是 0.0）。 如果 key 不存在，则会创建一个以指定成员为唯一成员的新排序集。 如果 key 存在但不包含排序集，则会返回错误信息。 分数值应是数值的字符串表示，并接受双精度浮点数。 可以提供一个负值来递减分数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZINCRBY key increment member
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zrange/" target="_blank" rel="noopener"
>ZRANGE&lt;/a>&lt;/p>
&lt;p>返回存储在 key 中的排序集合中元素的指定范围。 ZRANGE 可以执行不同类型的范围查询：按索引（秩）、按分数或按词典顺序。&lt;/p>
&lt;p>默认情况下，该命令执行索引范围查询。 start 和 stop 参数代表基于零的索引，其中 0 代表第一个元素。 这些参数指定了一个包含范围，例如，ZRANGE myzset 0 1 将同时返回排序集的第一个和第二个元素。 索引也可以是负数，表示从排序集末尾开始的偏移量，-1 表示排序集的最后一个元素。&lt;/p>
&lt;p>当提供 BYSCORE 选项时，命令的行为与 ZRANGEBYSCORE 类似，返回排序集中分数等于或介于 start 和 stop 之间的元素范围。&lt;/p>
&lt;p>使用 REV 选项会反转排序集，索引 0 将作为得分最高的元素。&lt;/p>
&lt;p>当使用 BYLEX 选项时，命令的行为与 ZRANGEBYLEX 类似，并返回排序集合中 start 和 stop 之间的元素范围。 请注意，词典排序依赖于所有元素具有相同的分数。 有效的 start 和 stop 必须以 ( 或 [ 开头，以便分别指定范围区间是排他的还是包含的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zunionstore/" target="_blank" rel="noopener"
>ZUNIONSTORE&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/zdiffstore/" target="_blank" rel="noopener"
>ZDIFFSTORE&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE &amp;lt;SUM | MIN | MAX&amp;gt;] # 并集
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ZDIFFSTORE destination numkeys key [key ...] # 第一个集合和之后集合的差集
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-4">应用场景
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>排行榜（有序唯一）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>电话、姓名排序&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="bitmap">BitMap
&lt;/h2>&lt;p>BitMap 是一串连续的二进制数组，可以通过偏移量定位元素，适合数据量大且使用二值统计的场景。&lt;/p>
&lt;h3 id="内部实现-4">内部实现
&lt;/h3>&lt;p>String 类型是会保存为二进制的字节数组&lt;/p>
&lt;h3 id="常用命令-3">常用命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/setbit/" target="_blank" rel="noopener"
>SETBIT&lt;/a>&lt;/p>
&lt;p>设置或清除存储在 key 处字符串值偏移量的位。 位的设置或清除取决于值，值可以是 0 或 1。当 key 不存在时，将创建一个新的字符串值。 字符串的增长是为了确保它能容纳偏移量处的位。 偏移参数必须大于或等于 0，且小于 2^32（这将位图限制在 512MB）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SETBIT key offset value
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/getbit/" target="_blank" rel="noopener"
>GETBIT&lt;/a>&lt;/p>
&lt;p>返回存储在 key 处的字符串值中偏移量处的比特值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GETBIT key offset
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/bitcount/" target="_blank" rel="noopener"
>BITCOUNT&lt;/a>&lt;/p>
&lt;p>获取指定范围内值为 1 的个数，默认以字节为单位。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">BITCOUNT key [start end [BYTE | BIT]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/bitop/" target="_blank" rel="noopener"
>BITOP&lt;/a>&lt;/p>
&lt;p>在多个键（包含字符串值）之间执行位操作，并将结果存储到目标键中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">BITOP &amp;lt;AND | OR | XOR | NOT&amp;gt; destkey key [key ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-5">应用场景
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>签到统计&lt;/p>
&lt;/li>
&lt;li>
&lt;p>判断用户登陆态&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="hyperloglog">HyperLogLog
&lt;/h2>&lt;p>HyperLogLog 是一种用于统计基数的数据集合类型，基数统计就是指&lt;strong>统计一个集合中不重复的元素个数&lt;/strong>。HyperLogLog 的&lt;strong>统计规则基于概率完成，标准误算率为 0.81%&lt;/strong>。&lt;/p>
&lt;h3 id="内部实现-5">内部实现
&lt;/h3>&lt;p>^ - ^&lt;/p>
&lt;h3 id="常见命令">常见命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/pfadd/" target="_blank" rel="noopener"
>PFADD&lt;/a>&lt;/p>
&lt;p>将所有元素参数添加到存储在作为第一个参数指定的变量名下的 HyperLogLog 中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">PFADD key [element [element ...]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/pfcount/" target="_blank" rel="noopener"
>PFCOUNT&lt;/a>&lt;/p>
&lt;p>使用单键调用时，返回存储在指定变量中的 HyperLogLog 的基数估算值，如果变量不存在，则返回 0。 使用多键调用时，通过内部合并存储在所提供键中的 HyperLogLog 成一个临时的 HyperLogLog，返回所传递的 HyperLogLog 联合的基数估算值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">PFCOUNT key [key ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/pfmerge/" target="_blank" rel="noopener"
>PFMERGE&lt;/a>&lt;/p>
&lt;p>将多个 HyperLogLog 值合并为一个 HyperLogLog 。如果目标 HyperLogLog 不存在（默认为空 HyperLogLog），则创建。 如果存在，则将其视为源集之一。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">PFMERGE destkey [sourcekey [sourcekey ...]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-6">应用场景
&lt;/h3>&lt;ul>
&lt;li>网页用户访问(UV)计数&lt;/li>
&lt;/ul>
&lt;h2 id="geo">GEO
&lt;/h2>&lt;p>主要用于存储地理信息&lt;/p>
&lt;h3 id="内部实现-6">内部实现
&lt;/h3>&lt;p>底层复用 Zset，使用 GeoHash 实现了经纬度到 Zset 中元素的权重分数的转换，关键机制是 &lt;em>二维地图区间划分&lt;/em> 和 &lt;em>区间编码&lt;/em> 。地理位置转换为经纬度后，使用区间编码标识，并将编码值作为 Zset 的权重分数。&lt;/p>
&lt;h3 id="常用命令-4">常用命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/geoadd/" target="_blank" rel="noopener"
>GEOADD&lt;/a>&lt;/p>
&lt;p>存储指定的地理位置信息，将经度，纬度，位置名称添加到指定的 key 中&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>XX&lt;/strong>: 只更新已存在的元素，从不添加元素。&lt;/li>
&lt;li>&lt;strong>NX&lt;/strong>: 不更新已存在的元素。&lt;/li>
&lt;li>&lt;strong>CH&lt;/strong>: 不更新已存在的元素。 总是添加新元素： 将返回值从添加的新元素数修改为更改的元素总数。 更改的元素是指新增的元素和坐标已更新的已有元素。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/geopos/" target="_blank" rel="noopener"
>GEOPOS&lt;/a>&lt;/p>
&lt;p>返回关键字处排序集所代表的地理空间索引中所有指定成员的位置（经度、纬度）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GEOPOS key [member [member ...]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/geodist/" target="_blank" rel="noopener"
>GEODIST&lt;/a>&lt;/p>
&lt;p>返回排序集所代表的地理空间索引中两个成员之间的距离。 单位必须是以下之一，默认为米：m 表示米。 km 表示公里。 mi 表示英里。 ft 表示英尺。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GEODIST key member1 member2 [M | KM | FT | MI]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/georadius/" target="_blank" rel="noopener"
>GEORADIUS&lt;/a>&lt;/p>
&lt;p>返回使用 GEOADD 填充了地理空间信息的排序集合的成员，这些成员位于以中心位置和距中心最大距离（半径）指定的区域边界内。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GEORADIUS key longitude latitude radius &amp;lt;M | KM | FT | MI&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC | DESC]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [STORE key | STOREDIST key]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-7">应用场景
&lt;/h3>&lt;ul>
&lt;li>位置信息服务&lt;/li>
&lt;/ul>
&lt;h2 id="stream">Stream
&lt;/h2>&lt;p>专为消息队列设计的数据类型，支持消息持久化、自动生成全局唯一 ID、支持 ACK 确认消息、支持消费组模式&lt;/p>
&lt;h3 id="内部实现-7">内部实现
&lt;/h3>&lt;p>^ - ^&lt;/p>
&lt;h3 id="常见命令-1">常见命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/xadd/" target="_blank" rel="noopener"
>XADD&lt;/a>&lt;/p>
&lt;p>将指定的数据流条目添加到指定键的数据流中。 如果键值不存在，则使用流的值创建键值。 可以使用 NOMKSTREAM 选项禁用创建数据流键。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">XADD key [NOMKSTREAM] [&amp;lt;MAXLEN | MINID&amp;gt; [= | ~] threshold
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [LIMIT count]] &amp;lt;* | id&amp;gt; field value [field value ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/xlen/" target="_blank" rel="noopener"
>XLEN&lt;/a>&lt;/p>
&lt;p>返回数据流中的条目数。 如果指定的键不存在，命令将返回 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">XLEN key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/xread/" target="_blank" rel="noopener"
>XREAD&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/xreadgroup/" target="_blank" rel="noopener"
>XREADGROUP&lt;/a>&lt;/p>
&lt;p>&lt;em>XREAD&lt;/em> 从一个或多个数据流中读取数据，只返回 ID 大于调用者报告的最后接收 ID 的条目。 该命令有一个选项，可在项目不可用时阻塞。&lt;/p>
&lt;p>&lt;em>XREADGROUP&lt;/em> 命令是 XREAD 命令的一个特殊版本，支持消费者组。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] id [id ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/xdel/" target="_blank" rel="noopener"
>XDEL&lt;/a>&lt;/p>
&lt;p>从数据流中删除指定条目，并返回已删除条目的数量。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">XDEL key id [id ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/xrange/" target="_blank" rel="noopener"
>XRANGE&lt;/a>&lt;/p>
&lt;p>该命令返回与给定 ID 范围匹配的数据流条目。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">XRANGE key start end [COUNT count]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/xpending/" target="_blank" rel="noopener"
>XPENDING&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/xack/" target="_blank" rel="noopener"
>XACK&lt;/a>&lt;/p>
&lt;p>&lt;em>XPENDING&lt;/em> 查询每个消费组内所有消费者 &lt;strong>已读取、尚未确认&lt;/strong> 的消息。&lt;/p>
&lt;p>&lt;em>XACK&lt;/em> 向消息队列确认消息处理已完成&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">XPENDING key group [[IDLE min-idle-time] start end count [consumer]]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">XACK key group id [id ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol></description></item><item><title>Redis简介</title><link>https://the-oone.github.io/p/redis%E7%AE%80%E4%BB%8B/</link><pubDate>Mon, 16 Dec 2024 20:29:41 +0800</pubDate><guid>https://the-oone.github.io/p/redis%E7%AE%80%E4%BB%8B/</guid><description>&lt;h2 id="redis-简介">Redis 简介
&lt;/h2>&lt;p>Redis（&lt;em>REmote DIctionary Serve&lt;/em>）是一个开源的基于内存的 Key-Value 数据库，常常用于&lt;strong>缓存、消息队列、分布式锁等场景&lt;/strong>。除此之外，Redis 还支持&lt;strong>事务、持久化、Lua 脚本、集群（主从、哨兵、切片）、发布/订阅&lt;/strong>等等。&lt;/p>
&lt;h2 id="redis-对比-memcached">Redis 对比 Memcached
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">&lt;/th>
&lt;th style="text-align: center">Redis&lt;/th>
&lt;th style="text-align: center">Memcached&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">数据类型&lt;/td>
&lt;td style="text-align: center">String、Hash、Lits、Set、ZSet、Bitmap&lt;br />HyperLogLog、GEO、Stream&lt;/td>
&lt;td style="text-align: center">String、Integer、ByteArray、List、Set&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">持久化&lt;/td>
&lt;td style="text-align: center">原生支持（AOF、RDB）&lt;/td>
&lt;td style="text-align: center">原生不支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">集群&lt;/td>
&lt;td style="text-align: center">原生支持（主从复制、哨兵、切片）&lt;/td>
&lt;td style="text-align: center">原生不支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">其他功能&lt;/td>
&lt;td style="text-align: center">发布/订阅、Lua 脚本、事务等等&lt;/td>
&lt;td style="text-align: center">——&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="redis-使用场景">Redis 使用场景
&lt;/h2>&lt;h2 id="相关资料">相关资料
&lt;/h2>&lt;p>&lt;a class="link" href="https://redis.io/" target="_blank" rel="noopener"
>Redis 官网&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/redis/redis" target="_blank" rel="noopener"
>Redis Github 地址&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://onecompiler.com/redis" target="_blank" rel="noopener"
>Redis 在线服务&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.redisio.com/" target="_blank" rel="noopener"
>Redis 中文文档&lt;/a>&lt;/p></description></item><item><title>Nginx 反向代理</title><link>https://the-oone.github.io/p/nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</link><pubDate>Sat, 07 Dec 2024 20:20:34 +0800</pubDate><guid>https://the-oone.github.io/p/nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</guid><description>&lt;h2 id="需求">需求
&lt;/h2>&lt;p>目前负责一个 Web 项目，该项目前后端是分离的，但是只给了一个端口和服务器进行远程连接。所以问题就出现了，前端需要一个端口用于用户访问，而后端也需要一个端口来和前端进行数据传输，那么就需要至少两个端口才能开启这个 Web 服务。为了解决这个问题，在网上查找资料发现 nginx 可以通过反向代理来实现同一个端口访问不同的服务。话不多说，直接开搞！&lt;/p>
&lt;h2 id="方案">方案
&lt;/h2>&lt;h3 id="nginx-安装">Nginx 安装
&lt;/h3>&lt;p>博主的服务器是 &lt;code>Ubuntu 22.04.4 LTS&lt;/code> ，首先更新一下系统软件包&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo apt update &lt;span class="c1"># 更新软件包列表&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt upgrade &lt;span class="c1"># 更新软件包&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install nginx &lt;span class="c1"># 安装 nginx&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>输入 &lt;code>nginx -v&lt;/code> 命令，如果能看到 nginx 的版本号，则安装成功&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412081720592.png"
loading="lazy"
alt="image-20241208172051452"
>&lt;/p>
&lt;p>安装好之后 Nginx一般会自动打开，如果没有可以使用命令手动打开。（注意如果你开启了防火墙，则需要配置防火墙允许 Nginx可以使用的端口的传输流量。）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo systemctl status nginx &lt;span class="c1"># 查看 nginx 状态&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo systemctl start nginx &lt;span class="c1"># 启动 nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo systemctl stop nginx &lt;span class="c1"># 关闭 nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo systemctl reload nginx &lt;span class="c1"># 重新加载配置文件（不中断服务）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo systemctl restart nginx &lt;span class="c1"># 重启 nginx&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="nginx-配置">Nginx 配置
&lt;/h3>&lt;p>进入你的 Nginx 配置文件，博主是在 &lt;code>/etc/nginx/sites-available/default&lt;/code> 文件中修改的配置。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo vim /etc/nginx/sites-available/default
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以下是博主的配置，前端服务配置在 &lt;code>/&lt;/code> 根路径下，后端配置在 &lt;code>/api/&lt;/code> 路径下。这样我们就可以通过 http://127.0.0.1/ 访问前端服务，http://127.0.0.1/api/ 访问后端服务。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">server &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> listen 80&lt;span class="p">;&lt;/span> &lt;span class="c1"># 监听端口&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> server_name 127.0.0.1&lt;span class="p">;&lt;/span> &lt;span class="c1"># 此处填写你的项目的域名或者 IP&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> location / &lt;span class="o">{&lt;/span> &lt;span class="c1"># 默认访问路径&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_pass http://127.0.0.1:5173&lt;span class="p">;&lt;/span> &lt;span class="c1"># 该项目对外暴露的接口路径&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_set_header Host &lt;span class="nv">$host&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_set_header X-realIP &lt;span class="nv">$remote_addr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_set_header X-Forwarded-for &lt;span class="nv">$proxy_add_x_forwarded_for&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> location /api/ &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_pass http://127.0.0.1:5000&lt;span class="p">;&lt;/span> &lt;span class="c1"># 该项目对外暴露的接口路径&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_set_header Host &lt;span class="nv">$host&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_set_header X-Real-IP &lt;span class="nv">$remote_addr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_set_header X-Forwarded-For &lt;span class="nv">$proxy_add_x_forwarded_for&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最终实现效果如下：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412082013591.png"
loading="lazy"
alt="image-20241208201301527"
>&lt;/p></description></item><item><title>GitHub ➕ PicGo 图床配置</title><link>https://the-oone.github.io/p/github-picgo-%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 07 Dec 2024 08:45:20 +0800</pubDate><guid>https://the-oone.github.io/p/github-picgo-%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE/</guid><description>&lt;h2 id="图床">图床
&lt;/h2>&lt;p>博客除了文字之外还有图片，但是由于图片的位置是在本地上，因此当上传至网站上时是没办法访问到这些图片的。而图床就可以解决这个问题，其本质上就是一个可以被互联网访问的存放图片的空间。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>大致可以分为下面几类：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>公共图床：只需要上传图片即可，网站会返回给你图片的 URL，例如 &lt;a class="link" href="https://www.helloimg.com/" target="_blank" rel="noopener"
>Hello图床&lt;/a> 。简单方便，但是不太稳定，并且有一些上传限制。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412071617487.png"
loading="lazy"
alt="image-20241207161745355"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码托管平台：类似于 GitHub，Gitee 这种。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>云服务器：类似于阿里云、腾讯云、华为云这些。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>本来想省心直接使用阿里云服务器，看了眼价格之后，默默放弃了（学生党伤不起~）。最后还是选择了 GitHub 作为图床，除了在国内访问不便之外其他方面都还好。&lt;/p>
&lt;h2 id="github-搭建图床">GitHub 搭建图床
&lt;/h2>&lt;p>首先需要一个 GitHub 仓库，仓库名随意，设置为 public，建议加上 README 文件，这样默认分支就会变成 main。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412071527305.png"
loading="lazy"
alt="image-20241207152656918"
>&lt;/p>
&lt;p>之后需要申请 Token，前往 &lt;strong>settings -&amp;gt; Developer Settings -&amp;gt; Personal access tokens&lt;/strong> 创建一个 &lt;strong>token(classic)&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412041431459.png"
loading="lazy"
alt="image-20241204143137362"
>&lt;/p>
&lt;p>勾选上 repo，如果要考虑安全的话，Token 有效期不要设置永不过期。还有就是注意这个 Token 只有在刚申请的时候才能看到，注意保存，否则只能重新申请一个新的。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412071536353.png"
loading="lazy"
alt="image-20241207153620166"
>&lt;/p>
&lt;h2 id="picgo">PicGo
&lt;/h2>&lt;p>这时候我们就可以将图片上传到仓库了，但是每次都需要手动 Git 上传到仓库这样太麻烦了，可以使用 PicGo 这款图片上传和管理工具。点击进入其 &lt;a class="link" href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener"
>GitHub&lt;/a> 页面，点击下图位置进去下载页面，选择一个版本下载好。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412071543273.png"
loading="lazy"
alt="image-20241207154307220"
>&lt;/p>
&lt;p>之后我们需要将我们的图床设置为 GitHub，&lt;strong>图床设置 -&amp;gt; GitHub&lt;/strong> ，填写好你的配置点击确定即可。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412071613264.png"
loading="lazy"
alt="image-20241207161334207"
>&lt;/p>
&lt;ul>
&lt;li>设定仓库名：你的 GitHub 用户名 / 你的图床仓库名&lt;/li>
&lt;li>设定分支名：上传到仓库的那个分支&lt;/li>
&lt;li>设定 Token：就是上面我们生成的那个 Token。&lt;/li>
&lt;li>设定存储路径：你要将上传的文件放到仓库的那个文件夹下（例如存放在根目录下的 static 目录下，填写 &lt;code>static/&lt;/code>）。若存储在根目录下，则不填。&lt;/li>
&lt;li>设定自定义域名：https://cdn.jsdelivr.net/gh/user/repo@brach，如果是上传到默认分支，则去掉 @ 及其之后的内容。（这里博主使用了 jsDelivr 来进行加速优化网站打开速度）&lt;/li>
&lt;/ul>
&lt;h2 id="typora-实现-cv-自动上传">Typora 实现 CV 自动上传
&lt;/h2>&lt;p>博主使用的 Typora 支持 PicGo，可以实现在文章内插入图片自动上传至图床。前往 &lt;strong>文件 -&amp;gt; 偏好设置&amp;hellip; -&amp;gt; 图像&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412071607907.png"
loading="lazy"
alt="image-20241207160710836"
>&lt;/p>
&lt;p>按照图示全部设置完成之后，点击 &lt;code>验证图片上传选项&lt;/code> ，可以看到上传成功&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412071606880.png"
loading="lazy"
alt="image-20241207160629837"
>&lt;/p></description></item><item><title>GitHub Pages ➕ Hugo 部署个人博客</title><link>https://the-oone.github.io/p/github-pages-hugo-%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link><pubDate>Mon, 02 Dec 2024 18:51:20 +0800</pubDate><guid>https://the-oone.github.io/p/github-pages-hugo-%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid><description>&lt;h2 id="准备工作">准备工作
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>&lt;a class="link" href="https://GitHub.com/gohugoio/hugo" target="_blank" rel="noopener"
>Hugo&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>从 Hugo GitHub 仓库选择合适版本的下载，从下图中所指示位置即可进入下载页面&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412041422942.png"
loading="lazy"
alt="image-20241204142246453"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>选择与你机器对应的版本（我这里选择 0.139.3 版本，windows 系统，对应文件为 hugo_extended_withdeploy_0.139.3_windows-amd64.zip）&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412041424519.png"
loading="lazy"
alt="image-20241204142409072"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将下载好的文件解压缩，在命令行敲击 &lt;strong>hugo version&lt;/strong>，看到如下结果则表示安装成功。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412041424936.png"
loading="lazy"
alt="image-20241204142449688"
>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://git-scm.com/" target="_blank" rel="noopener"
>Git&lt;/a>&lt;/p>
&lt;ul>
&lt;li>选择合适的版本下载，按照指引一路 next。（由于博主很早之前就已经下载了 Git，所以这块没有图片展示）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="创建博客站点">创建博客站点
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>使用 Hugo（建议将其加入环境变量） 创建你的站点，在命令行中输入 &lt;strong>hugo new site sitename&lt;/strong>。出现下图所示，则表明创建好了站点，按照这上面的步骤来即可。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412041425244.png"
loading="lazy"
alt="image-20241204142517147"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进入你的站点文件夹，可以看到 Hugo 创建了以下文件&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412041425109.png"
loading="lazy"
alt="image-20241204142549989"
>&lt;/p>
&lt;p>&lt;code>archetypes&lt;/code> 目录包含用于新内容的模板。&lt;/p>
&lt;p>&lt;code>assets&lt;/code> 目录包含通常通过资源管道传递的全局资源。包括图片、CSS、Sass、JavaScript 等。&lt;/p>
&lt;p>&lt;code>content&lt;/code> 目录包含组成站点内容的标记文件（通常是 markdown）和页面资源。&lt;/p>
&lt;p>&lt;code>data&lt;/code> 目录包含用于增强内容、配置、本地化和导航的数据文件（JSON、TOML、YAML 或 XML）。&lt;/p>
&lt;p>&lt;code>hugo.tomal&lt;/code> 是 Hugo 的配置文件&lt;/p>
&lt;p>&lt;code>i18n&lt;/code> 目录包含多语言站点的翻译表。&lt;/p>
&lt;p>&lt;code>layouts&lt;/code> 目录包含将内容、数据和资源转换为完整网站的模板。&lt;/p>
&lt;p>&lt;code>static&lt;/code> 目录包含在构建站点时将复制到 public 目录的文件，例如 &lt;code>favicon.ico&lt;/code>、&lt;code>robots.txt&lt;/code> 和用于验证站点拥有权的文件。在引入页面包和资源管道之前，&lt;code>static&lt;/code> 目录也用于存放图片、CSS 和 JavaScript 等资源。&lt;/p>
&lt;p>&lt;code>themes&lt;/code> 目录包含一个或多个主题，每个主题位于自己的子目录中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hugo 默认不带主题，因此你需要去 &lt;a class="link" href="https://themes.gohugo.io/" target="_blank" rel="noopener"
>主题社区&lt;/a> 下载主题，我这里选择 &lt;a class="link" href="https://GitHub.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener"
>Stack&lt;/a> 这款主题。首先将该文件夹初始为 Git 仓库，再增加主题作为子模块克隆到 theme 文件夹下。使用命令如下：&lt;/p>
&lt;p>初始化仓库：git init -b main&lt;/p>
&lt;p>添加主题：git submodule add &lt;a class="link" href="https://GitHub.com/CaiJimmy/hugo-theme-stack.git" target="_blank" rel="noopener"
>https://GitHub.com/CaiJimmy/hugo-theme-stack.git&lt;/a> themes/hugo-theme-stack&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 themes\hugo-theme-stack\exampleSite 目录下的 content 文件夹和 hugo.yaml 复制到站点根目录（也就是你上面创建的那个文件夹下，我这里是 myblog），并且删除 hugo.toml 文件。&lt;/p>
&lt;p>NOTE：需要删除 content\post\rich-content ，该文件夹内存放的资源访问不了，会导致 Hugo 无法启动）&lt;/p>
&lt;p>使用命令：hugo server -D 启动网站，可以发现站点多了两个文件夹。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412041426519.png"
loading="lazy"
alt="image-20241204142633162"
>&lt;/p>
&lt;p>&lt;code>public&lt;/code> 目录包含发布的网站，在运行 &lt;code>hugo&lt;/code> 命令时生成。Hugo 根据需要重建此目录及其内容。&lt;/p>
&lt;p>&lt;code>resources&lt;/code> 目录包含 Hugo 资源管道的缓存输出，在运行 &lt;code>hugo&lt;/code> 或 &lt;code>hugo server&lt;/code> 命令时生成。默认情况下，此缓存目录包括 CSS 和图片。Hugo 根据需要重建此目录及其内容。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>访问 http://localhost:1313/，看到如下结果表示你的博客已经在本地搭建好了&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412041427505.png"
loading="lazy"
alt="image-20241204142706065"
>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="github-部署">GitHub 部署
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>搭建好本地环境之后，就需要将网站部署在 GitHub 上。这里有两种部署方式：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一种是手动上传文件，只需要创建一个 GitHub Page仓库：&lt;/p>
&lt;ul>
&lt;li>存放网站的静态文件，设置为 Public；&lt;/li>
&lt;li>仓库名必须是 &amp;lt;username.github.io&amp;gt;，username 是你 GitHub 的用户名。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412041427039.png"
loading="lazy"
alt="image-20241204142744986"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建好仓库之后，按照图示开启 GitHub Page。前往 &lt;strong>setting -&amp;gt; Pages -&amp;gt; Branch&lt;/strong> 选择 &lt;strong>main&lt;/strong> 分支，保存设置。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412041430056.png"
loading="lazy"
alt="image-20241204143019772"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 public 文件夹上传至 GitHub 仓库，上传成功后访问 https://&amp;lt;GiuHub用户名&amp;gt;.github.io，就能看到自己的博客内容了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git init -b main
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git add .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># git config user.name &amp;#34;your_user_name&amp;#34; # 第一次使用 Git 或者未配置全局变量需要加上此行&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># git config user.email &amp;#34;your_user_email&amp;#34; # 第一次使用 Git 或者未配置全局变量需要加上此行&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -m &lt;span class="s2">&amp;#34;first commit&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote add origin &amp;lt;your_github_repository_address&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push -u origin main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>另一种是 GitHub Action 自动化部署，还需要创建一个博客源文件仓库：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>存放你的网站源文件，建议设置为 Private 防止源码文件泄露&lt;/p>
&lt;/li>
&lt;li>
&lt;p>前往 &lt;strong>settings -&amp;gt; Developer Settings -&amp;gt; Personal access tokens&lt;/strong> 创建一个 &lt;strong>token(classic)&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412041431459.png"
loading="lazy"
alt="image-20241204143137362"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果要考虑安全的话，Token 有效期不要设置永不过期。还有就是注意勾选上 repo 和 workflow。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412041432653.png"
loading="lazy"
alt="image-20241204143201582"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将生成的 Token（注意保存，只有当刚生成时才能看见）加入博客源文件仓库的 secrets 中，前往 &lt;strong>Settings -&amp;gt; Secrets and variables -&amp;gt; Actions&lt;/strong> 设置。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412041432649.png"
loading="lazy"
alt="image-20241204143222219"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在站点根目录下创建一个 &lt;strong>.github/workflows/xxx.yaml&lt;/strong> 文件配置工作流&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">name: deploy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">on:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> push:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> branches:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - main &lt;span class="c1"># 当 main 分支发生 push 的时候，运行下面的 jobs&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">jobs:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> deploy:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> runs-on: ubuntu-latest &lt;span class="c1"># 运行环境&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> steps:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - name: Checkout
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> uses: actions/checkout@v4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> with:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> fetch-depth: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - name: Setup Hugo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> uses: peaceiris/actions-hugo@v3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> with:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> hugo-version: &lt;span class="s2">&amp;#34;0.139.3&amp;#34;&lt;/span> &lt;span class="c1"># 建议和你下载的 hugo 版本一致&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> extended: &lt;span class="nb">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - name: Build Web
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> run: hugo -D &lt;span class="c1"># 使用 hugo 构建静态网页&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - name: Deploy Web
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> uses: peaceiris/actions-gh-pages@v4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> with:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> PERSONAL_TOKEN: &lt;span class="si">${&lt;/span>&lt;span class="p">{ secrets.你的Token变量名 &lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="c1"># 发布到其他 repo 需要提供上面生成的 personal access token&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> EXTERNAL_REPOSITORY: 你的GitHub名/你的仓库名 &lt;span class="c1"># 发布到哪个 repo&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> PUBLISH_BRANCH: main &lt;span class="c1"># 发布到哪个branch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> PUBLISH_DIR: ./public &lt;span class="c1"># 要发布哪个文件夹的内容&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> commit_message: auto deploy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>将站点根目录下的文件上传至博客源文件仓库，上传成功会出发 GitHub ACtion，自动部署静态页面，访问 https://&amp;lt;GiuHub用户名&amp;gt;.github.io，就能看到自己最新的博客内容了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>归档</title><link>https://the-oone.github.io/archives/</link><pubDate>Tue, 28 May 2019 00:00:00 +0800</pubDate><guid>https://the-oone.github.io/archives/</guid><description>&lt;p>This is a test page for i18n support.&lt;/p></description></item><item><title>博客</title><link>https://the-oone.github.io/categories/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://the-oone.github.io/categories/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2/</guid><description/></item><item><title>代码</title><link>https://the-oone.github.io/categories/%E7%BC%96%E7%A8%8B/_index.zh-ch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://the-oone.github.io/categories/%E7%BC%96%E7%A8%8B/_index.zh-ch/</guid><description>&lt;img src="https://the-oone.github.io/program.jpg" alt="Featured image of post 代码" /></description></item><item><title>关于</title><link>https://the-oone.github.io/%E5%85%B3%E4%BA%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://the-oone.github.io/%E5%85%B3%E4%BA%8E/</guid><description>&lt;p>This is a test page for i18n support.&lt;/p></description></item><item><title>链接</title><link>https://the-oone.github.io/%E9%93%BE%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://the-oone.github.io/%E9%93%BE%E6%8E%A5/</guid><description>&lt;p>To use this feature, add &lt;code>links&lt;/code> section to frontmatter.&lt;/p>
&lt;p>This page&amp;rsquo;s frontmatter:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">links&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">title&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">GitHub&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">description&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">GitHub is the world&amp;#39;s largest software development platform.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">website&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https://github.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">title&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TypeScript&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">description&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">website&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https://www.typescriptlang.org&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ts-logo-128.jpg&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>image&lt;/code> field accepts both local and external images.&lt;/p></description></item><item><title>生活</title><link>https://the-oone.github.io/categories/%E7%94%9F%E6%B4%BB/_index.zh-ch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://the-oone.github.io/categories/%E7%94%9F%E6%B4%BB/_index.zh-ch/</guid><description/></item><item><title>搜索</title><link>https://the-oone.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://the-oone.github.io/search/</guid><description>&lt;p>This is a test page for i18n support.&lt;/p></description></item></channel></rss>