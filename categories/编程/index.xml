<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程 on 踩坑记录</title><link>https://the-oone.github.io/categories/%E7%BC%96%E7%A8%8B/</link><description>Recent content in 编程 on 踩坑记录</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Ting</copyright><lastBuildDate>Tue, 14 Jan 2025 21:04:32 +0800</lastBuildDate><atom:link href="https://the-oone.github.io/categories/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Redis持久化</title><link>https://the-oone.github.io/p/redis%E6%8C%81%E4%B9%85%E5%8C%96/</link><pubDate>Tue, 14 Jan 2025 21:04:32 +0800</pubDate><guid>https://the-oone.github.io/p/redis%E6%8C%81%E4%B9%85%E5%8C%96/</guid><description>&lt;h2 id="redis-为什么需要持久化">Redis 为什么需要持久化
&lt;/h2>&lt;h2 id="rdbredis-database">RDB（Redis Database）
&lt;/h2>&lt;p>RDB 持久化以指定的时间间隔对数据集执行时间点快照（实际上就是记录某一个时间节点的&lt;strong>内存数据&lt;/strong>）。&lt;/p>
&lt;h3 id="配置操作">配置操作
&lt;/h3>&lt;p>Redis 7.4.2 默认 RDB 参数&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 1p/1h 或 100p/5m 或 10000p/60s &lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">save &lt;span class="m">3600&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">300&lt;/span> &lt;span class="m">100&lt;/span> &lt;span class="m">60&lt;/span> &lt;span class="m">10000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># RDB 快照保存文件名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">dbfilename dump.rdb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># RDB 快照保存目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">dir ./
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 在快照写入失败时是否停止写请求&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">stop-writes-on-bgsave-error yes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 是否开启 RDB 压缩（LZF压缩算法）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rdbcompression yes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 是否开启 RDB 数据校验（CRC64算法）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rdbchecksum yes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 是否删除未启用持久性的实例中复制使用的 RDB 文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rdb-del-sync-files no
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>默认情况下，Redis 会将数据集的快照保存在磁盘上一个名为 dump.rdb 的二进制文件中。 你也可以手动调用 SAVE 或 BGSAVE 命令。&lt;/p>
&lt;ul>
&lt;li>执行 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，&lt;strong>会阻塞主线程&lt;/strong>。&lt;strong>线上禁止使用&lt;/strong>&lt;/li>
&lt;li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以&lt;strong>避免主线程的阻塞&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>执行 flushall/flushdb 命令也会产生 &lt;code>.rdb&lt;/code> 文件，但是该文件中&lt;strong>没有任何数据&lt;/strong>（因为他是在清盘之后才保存的）。在恢复数据时，一定要将服务和备份分机隔离（防止备份的 .&lt;code>rdb&lt;/code> 文件被覆盖）。&lt;/p>
&lt;h3 id="触发时机">触发时机
&lt;/h3>&lt;ul>
&lt;li>配置文件中默认的快照配置&lt;/li>
&lt;li>手动 sava/bgsave 命令&lt;/li>
&lt;li>执行 flushall/flushdb 命令&lt;/li>
&lt;li>执行 shutdown 且没有设置 AOF 持久化&lt;/li>
&lt;li>主从复制，主节点自动触发&lt;/li>
&lt;/ul>
&lt;h3 id="优势">优势
&lt;/h3>&lt;ul>
&lt;li>适合大规模的数据恢复&lt;/li>
&lt;li>按照业务定时备份&lt;/li>
&lt;li>对数据完整性和一致性要求不高&lt;/li>
&lt;li>RDB 文件在内存中加载速度比 AOF 快得多&lt;/li>
&lt;/ul>
&lt;h3 id="劣势">劣势
&lt;/h3>&lt;ul>
&lt;li>RDB 会丢失备份间隔时间内的所有数据，也就是说距离上一次备份期间内的所有数据都会被丢失&lt;/li>
&lt;li>RDB 是全量快照，每次执行都会把所有的数据记录到磁盘中，频繁的磁盘 I/O 可能影响服务器性能&lt;/li>
&lt;li>RDB 依赖主进程的 fork，在极端形况下内存占用会变为原先的 2 倍。&lt;/li>
&lt;/ul>
&lt;h3 id="执行-rdb-快照时能否修改数据">执行 RDB 快照时能否修改数据
&lt;/h3>&lt;p>可以，使用&lt;strong>写时复制技术&lt;/strong>。&lt;/p>
&lt;p>执行 bgsave 命令时，通过 fork() 创建子进程，因此父进程、子进程共享同一片内存数据（两份页表，一份物理内存）。只有当发生数据修改时，才会复制一份新的物理内存（注意此时&lt;strong>子进程会将旧的物理内存写入 RDB 文件&lt;/strong>，而&lt;strong>主进程会在新的物理内存中修改数据&lt;/strong>）。这样就可以避免主线程阻塞。&lt;/p>
&lt;h3 id="修复破损的-rdb-文件">修复破损的 RDB 文件
&lt;/h3>&lt;h2 id="aofappend-only-file">AOF（Append Only File）
&lt;/h2>&lt;p>AOF 持久性记录服务器收到的每个写入操作。 这些操作可以在服务器启动时再次重放，重建原始数据集。 命令记录格式与 Redis 协议本身相同。&lt;/p></description></item><item><title>垃圾回收 GC</title><link>https://the-oone.github.io/p/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-gc/</link><pubDate>Tue, 14 Jan 2025 13:19:36 +0800</pubDate><guid>https://the-oone.github.io/p/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-gc/</guid><description>&lt;h2 id="什么是-gc">什么是 GC
&lt;/h2>&lt;p>垃圾回收（Garbage Collection，GC）是一种自动内存管理机制。&lt;/p>
&lt;p>现代高级编程语言管理内存有两种方式：&lt;/p>
&lt;ul>
&lt;li>手动：C/C++，Rust等，需要主动申请或者释放内存&lt;/li>
&lt;li>自动：Java，Golang等，有内存分配器和垃圾收集器自动分配和回收内存&lt;/li>
&lt;/ul>
&lt;p>程序中会使用两种内存：&lt;/p>
&lt;ul>
&lt;li>堆内存：程序共享的内存，由 GC 进行回收&lt;/li>
&lt;li>栈内存：线程专用的内存，存储函数的参数值、局部变量等，由操作系统自动分配释放&lt;/li>
&lt;/ul>
&lt;h2 id="go-的垃圾回收">Go 的垃圾回收
&lt;/h2>&lt;h3 id="gc-相关术语">GC 相关术语
&lt;/h3>&lt;ul>
&lt;li>STW：全称 stop the word，GC 期间某个阶段会停止所有的赋值器，中断程序逻辑，以确定引用关系。&lt;/li>
&lt;li>root 对象：根对象是指赋值器不需要通过其他对象就可以直接访问到的对象&lt;/li>
&lt;/ul>
&lt;h3 id="gc-v13">GC V1.3
&lt;/h3>&lt;p>1.3 版本 Go 使用&lt;strong>标记-清除&lt;/strong>作为垃圾回收算法：&lt;/p>
&lt;ol>
&lt;li>开启STW，停止程序的运行&lt;/li>
&lt;li>从根节点遍历，标记找出的所有可达对象&lt;/li>
&lt;li>清理未标记的对象&lt;/li>
&lt;li>继续运行程序&lt;/li>
&lt;/ol>
&lt;p>重复循环上述 1-4 步，直到 process 程序生命周期结束。标记清除法的&lt;strong>最大弊端就是在整个GC期间需要STW&lt;/strong>，将整个程序暂停。因为如果不进行STW的话，会出现已经被标记的对象A，引用了新的未被标记的对象B，但由于对象A已经标记过了，不会再重新扫描A对B的可达性，从而将B对象当做垃圾回收掉。&lt;/p>
&lt;h3 id="gc-v15">GC V1.5
&lt;/h3>&lt;p>1.5 版本使用&lt;strong>标记-清除算法，结合三色标记，插入写屏障&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>创建白、灰、黑三个集合&lt;/li>
&lt;li>将所有对象先放入白色集合中&lt;/li>
&lt;li>遍历所有 root 对象，把遍历到的对象从白色集合放入灰色集合（这里放入灰色集合的都是根节点直接可达的对象）&lt;/li>
&lt;li>遍历灰色集合，将灰色对象直接可达的对象从白色集合放入灰色集合，自身标记为黑色&lt;/li>
&lt;li>重复第四步，直至灰色集合中没有任何对象&lt;/li>
&lt;li>回收白色集合内的所有对象&lt;/li>
&lt;/ol>
&lt;p>对于上述的算法来讲,仍然需要依赖STW的。因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。&lt;/p>
&lt;p>在三色标记法过程中对象丢失需要同时满足两个条件：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>条件一&lt;/strong>：白色对象被黑色对象引用&lt;/li>
&lt;li>&lt;strong>条件二&lt;/strong>：灰色对象和白色对象之间的可达关系遭到破坏&lt;/li>
&lt;/ul>
&lt;p>Go 团队提出两个解决方案&lt;/p>
&lt;ul>
&lt;li>&lt;strong>强三色不变式&lt;/strong>：不允许黑色对象引用白色对象，破坏条件一&lt;/li>
&lt;li>&lt;strong>弱三色不变式&lt;/strong>：黑色对象可以引用白色对象，但是白色对象的上游必须存在灰色对象，破坏条件二&lt;/li>
&lt;/ul>
&lt;p>Go 团队基于上述不变式提出两种实现机制：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>插入写屏障&lt;/strong>（满足强三色不变式）
&lt;ul>
&lt;li>规则：当一个对象引用另一个对象时，将另一个对象标记为灰色&lt;/li>
&lt;li>劣势：无法管理栈操作，需要 STW 重新扫描栈&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>删除写屏障&lt;/strong>（满足弱三色不变式）
&lt;ul>
&lt;li>规则：在删除引用时，如果被删除引用的对象自身为灰色或者白色，那么会标记为灰色&lt;/li>
&lt;li>劣势：冗余扫描成本高，回收精度低&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="gc-v18">GC V1.8
&lt;/h3>&lt;p>1.8 版本使用&lt;strong>标记-清除算法，结合三色标记法和混合写屏障&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>GC 开始将栈上的所有可达对象均标记为黑色&lt;/li>
&lt;li>GC 期间，任何在栈上创建的新对象，均为黑色&lt;/li>
&lt;li>堆上被删除对象标记为灰色&lt;/li>
&lt;li>堆上被添加的对象标记为灰色&lt;/li>
&lt;/ol>
&lt;h2 id="gc-的触发时间">GC 的触发时间
&lt;/h2>&lt;ul>
&lt;li>主动触发：调用 &lt;code>runtime.GC()&lt;/code> 方法&lt;/li>
&lt;li>被动触发：
&lt;ul>
&lt;li>定时触发，该触发条件由 &lt;code>runtime.forcegcperiod&lt;/code> 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，触发 GC&lt;/li>
&lt;li>根据内存分配阈值触发，该触发条件由环境变量 GOGC 控制，默认值为100（100%），当前堆内存占用是上次 GC 结束后占用内存的 2 倍时，触发 GC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="gc-调优">GC 调优
&lt;/h2>&lt;ul>
&lt;li>控制内存分配的速度，限制&lt;code>Goroutine&lt;/code>的数量，提高赋值器&lt;code>mutator&lt;/code>的CPU利用率(降低GC的CPU利用率)&lt;/li>
&lt;li>少量使用&lt;code>+&lt;/code>连接&lt;code>string&lt;/code>&lt;/li>
&lt;li>&lt;code>slice&lt;/code>提前分配足够的内存来降低扩容带来的拷贝&lt;/li>
&lt;li>避免&lt;code>map key&lt;/code>对象过多，导致扫描时间增加&lt;/li>
&lt;li>变量复用，减少对象分配，例如使用&lt;code>sync.Pool&lt;/code>来复用需要频繁创建临时对象，使用全局变量&lt;/li>
&lt;li>增大&lt;code>GOGC&lt;/code>的值，降低GC的运行频率&lt;/li>
&lt;/ul></description></item><item><title>GMP 调度模型</title><link>https://the-oone.github.io/p/gmp-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 13 Jan 2025 14:46:19 +0800</pubDate><guid>https://the-oone.github.io/p/gmp-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h2 id="历史背景">历史背景
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">&lt;/th>
&lt;th style="text-align: center">含义&lt;/th>
&lt;th style="text-align: center">缺点&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">进程时代&lt;/td>
&lt;td style="text-align: center">一个程序就是一个进程，所有进程严格按照时间执行&lt;/td>
&lt;td style="text-align: center">进程阻塞十分损耗性能、只能串行执行任务&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">线程时代&lt;/td>
&lt;td style="text-align: center">一个进程阻塞，可以切换到其他进程&lt;/td>
&lt;td style="text-align: center">上下文切换成本高、协程内存占用较高&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">协程时代&lt;/td>
&lt;td style="text-align: center">协程绑定线程，CPU 调度线程执行&lt;/td>
&lt;td style="text-align: center">实现复杂，协程和线程的绑定依赖调度器算法&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="gmp-调度模型是什么">GMP 调度模型是什么
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131539627.png"
loading="lazy"
alt="image-20250113153916514"
>&lt;/p>
&lt;p>G：&lt;em>Goroutine&lt;/em>，是 Go 的用户级线程，每个 go 关键字都会创建一个 Goroutine。其数量理论上只受内存大小影响。&lt;/p>
&lt;p>M：&lt;em>Machine&lt;/em>，Go 对&lt;strong>操作系统线程&lt;/strong>的封装，M在绑定有效的 P 后，进入一个调度循环，而调度循环的机制大致是从 P 的本地运行队列以及全局队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。&lt;strong>M的数量有限制，默认数量限制是 10000&lt;/strong>，可以通过 debug.SetMaxThreads() 方法进行设置，如果有M空闲，那么就会回收或者睡眠。&lt;/p>
&lt;p>P：&lt;em>Processor&lt;/em>，&lt;strong>虚拟处理器，M执行G所需要的资源和上下文，只有将 P 和 M 绑定，才能让 P 的 runq 中的 G 真正运行起来&lt;/strong>。P的数量受本机的CPU核数影响，可通过环境变量$GOMAXPROCS或在runtime.GOMAXPROCS()来设置，默认为CPU核心数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//src/runtime/runtime2.go
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">g&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">goid&lt;/span> &lt;span class="kt">int64&lt;/span> &lt;span class="c1">// 唯一的goroutine的ID
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">sched&lt;/span> &lt;span class="nx">gobuf&lt;/span> &lt;span class="c1">// goroutine切换时，用于保存g的上下文
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">stack&lt;/span> &lt;span class="nx">stack&lt;/span> &lt;span class="c1">// 栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gopc&lt;/span> &lt;span class="c1">// pc of go statement that created this goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">startpc&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// pc of goroutine function
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">lock&lt;/span> &lt;span class="nx">mutex&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">id&lt;/span> &lt;span class="kt">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">status&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// one of pidle/prunning/...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Queue of runnable goroutines. Accessed without lock.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runqhead&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// 本地队列队头
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runqtail&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// 本地队列队尾
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runq&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">256&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">guintptr&lt;/span> &lt;span class="c1">// 本地队列，大小256的数组，数组往往会被都读入到缓存中，对缓存友好，效率较高
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runnext&lt;/span> &lt;span class="nx">guintptr&lt;/span> &lt;span class="c1">// 下一个优先执行的goroutine（一定是最后生产出来的)，为了实现局部性原理，runnext中的G永远会被最先调度执行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">m&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">g0&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 每个M都有一个自己的G0，不指向任何可执行的函数，在调度或系统调用时，M会切换到G0，使用G0的栈空间来调度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">curg&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 当前正在执行的G
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">schedt&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">runq&lt;/span> &lt;span class="nx">gQueue&lt;/span> &lt;span class="c1">// 全局队列，链表（长度无限制）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runqsize&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">// 全局队列长度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="go-调度原理">Go 调度原理
&lt;/h2>&lt;h3 id="调度对象">调度对象
&lt;/h3>&lt;ul>
&lt;li>G 的来源
&lt;ul>
&lt;li>P 的 runnext（1 个 G）&lt;/li>
&lt;li>P 的本地队列（数组，最多 256 个 G）&lt;/li>
&lt;li>全局 G 队列（链表，G 数量无限制）&lt;/li>
&lt;li>网络轮询器（存放网络调用阻塞的 G）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>P 的来源
&lt;ul>
&lt;li>全局 P 队列（数组，GOMAXPROCS个P）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>M 的来源
&lt;ul>
&lt;li>休眠线程队列（未绑定 P，长时间休眠会等待GC回收销毁）&lt;/li>
&lt;li>运行线程（绑定 P，指向 P 中的 G）&lt;/li>
&lt;li>自旋线程（绑定 P，指向 M 的 G0）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="goroutine-调度流程">Goroutine 调度流程
&lt;/h3>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131542604.png"
loading="lazy"
alt="image-20250113154209545"
>&lt;/p>
&lt;p>上图是一个完整调度流程：&lt;/p>
&lt;ol>
&lt;li>通过 go func() 创建一个 &lt;em>G&lt;/em>&lt;/li>
&lt;li>创建的 &lt;em>G&lt;/em> 优先保存到本地队列 &lt;em>P&lt;/em>，若本地 &lt;em>P&lt;/em> 已满则进去全局队列&lt;/li>
&lt;li>唤醒或者新建 &lt;em>M&lt;/em> 执行任务，进入调度循环（4，5，6)&lt;/li>
&lt;li>&lt;em>M&lt;/em> 依次会从本地队列 &lt;em>P&lt;/em>，全局队列，其他本地队列 &lt;em>P&lt;/em> 获取 &lt;em>G&lt;/em>&lt;/li>
&lt;li>&lt;em>M&lt;/em> 调度和执行 &lt;em>G&lt;/em>
&lt;ul>
&lt;li>如果 &lt;em>M&lt;/em> 在执行 &lt;em>G&lt;/em> 的过程发生&lt;strong>系统调用阻塞&lt;/strong>（同步），会阻塞 &lt;em>G&lt;/em> 和 &lt;em>M&lt;/em>（操作系统限制），此时 &lt;em>P&lt;/em> 会和当前 &lt;em>M&lt;/em> 解绑，并寻找新的 &lt;em>M&lt;/em>，如果没有空闲的 &lt;em>M&lt;/em> 就会新建一个 &lt;em>M&lt;/em> ，接管正在阻塞G所属的P，接着继续执行 P中其余的G，这种阻塞后释放P的方式称之为hand off。当&lt;strong>系统调用结束&lt;/strong>后，这个G会尝试获取一个空闲的P执行，优先获取之前绑定的P，并放入到这个P的本地队列，如果获取不到P，那么这个线程M变成休眠状态，加入到空闲线程中，然后这个G会被放入到全局队列中。&lt;/li>
&lt;li>如果M在执行G的过程发生网络IO等操作阻塞时（异步），阻塞G，&lt;strong>不会阻塞M&lt;/strong>。M会寻找P中其它可执行的G继续执行，G会被网络轮询器network poller 接手，当阻塞的G恢复后，G1从network poller 被移回到P的 LRQ 中，重新进入可执行状态。异步情况下，通过调度，Go scheduler 成功地将 I/O 的任务转变成了 CPU 任务，或者说将内核级别的线程切换转变成了用户级别的 goroutine 切换，大大提高了效率。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;em>M&lt;/em> 执行完 &lt;em>G&lt;/em> 后清理现场，重新进入调度循环（将 M 上运⾏的goroutine切换为G0，G0负责调度时协程的切换）&lt;/li>
&lt;/ol>
&lt;h3 id="调度器生命周期">调度器生命周期
&lt;/h3>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501132210897.png"
loading="lazy"
alt="image-20250113221048794"
>&lt;/p>
&lt;ul>
&lt;li>M0：M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。&lt;/li>
&lt;li>G0：G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。&lt;/li>
&lt;/ul>
&lt;h3 id="调度时机">调度时机
&lt;/h3>&lt;ul>
&lt;li>抢占式调度
&lt;ul>
&lt;li>sysmon检测到协程运行过久(比如sleep，死循环)&lt;/li>
&lt;li>切换到g0，进入调度循环&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>主动调度
&lt;ul>
&lt;li>新起一个协程和协程执行完毕触发调度循环&lt;/li>
&lt;li>主动调用runtime.Gosched()切换到g0，进入调度循环&lt;/li>
&lt;li>垃圾回收之后。stw之后，会重新选择g开始执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>被动调度
&lt;ul>
&lt;li>系统调用(比如文件IO)阻塞(同步)，阻塞G和M，P与M分离，将P交给其它M绑定，其它M执行P的剩余G&lt;/li>
&lt;li>网络IO调用阻塞(异步) ，阻塞G，G移动到NetPoller，M执行P的剩余G&lt;/li>
&lt;li>atomic/mutex/channel等阻塞(异步)，阻塞G，G移动到channel的等待队列中，M执行P的剩余G&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="如何挑选下一个执行的-goroutine">如何挑选下一个执行的 Goroutine
&lt;/h3>&lt;ol>
&lt;li>每执行61次调度循环，从全局队列获取G，若有则直接返回&lt;/li>
&lt;li>从P上的runnext看一下是否有G，若有则直接返回&lt;/li>
&lt;li>从P上的本地队列看一下是否有G，若有则直接返回&lt;/li>
&lt;li>上面都没查找到时，则去全局队列、网络轮询器查找或者从其他Р中窃取,t一直阻塞直到获取到一个可用 的G为止&lt;/li>
&lt;/ol>
&lt;p>netpoller中拿到的G是 &lt;code>_Gwaiting状态&lt;/code>（存放的是因为网络IO被阻塞的G)，从其它地方拿到的是&lt;code>_Grunnable状态&lt;/code>&lt;/p>
&lt;h3 id="goroutine-的调度方式">Goroutine 的调度方式
&lt;/h3>&lt;h4 id="基于协作的抢占式调度流程12-版本实现">基于协作的抢占式调度流程（1.2 版本实现）
&lt;/h4>&lt;ol>
&lt;li>编译器会在调用函数前插入runtime.morestack，让运行时有机会在这段代码中检查是否需要执行抢占
调度&lt;/li>
&lt;li>Go语言运行时会在垃圾回收暂停程序、系统监控发现Goroutine运行超过10ms，那么会在这个协程设置
一个抢占标记&lt;/li>
&lt;li>当发生函数调用时，可能会执行编译器插入的runtime.morestack，它调用的runtime.newstack会检查抢
占标记，如果有抢占标记就会触发抢占让出cpu，切到调度主协程里&lt;/li>
&lt;/ol>
&lt;p>只能局部解决问题，只在有函数调用的地方才能插入“抢占”代码（埋点），对于没有函数调用而是纯算法循环计算的 G，Go 调度器依然无法抢占。&lt;/p>
&lt;h4 id="基于信号的抢占式调度114版本实现">基于信号的抢占式调度（1.14版本实现）
&lt;/h4>&lt;ol>
&lt;li>M注册一个SIGURG信号的处理函数:sighandler&lt;/li>
&lt;li>sysmon启动后会间隔性的进行监控，最长间隔10ms，最短间隔20us。如果发现某协程独占
P超过10ms，会给M发送抢占信号&lt;/li>
&lt;li>M收到信号后，内核执行sighandler函数把当前协程的状态从_Grunning正在执行改成_Grunnable可执
行，把抢占的协程放到全局队列里，M继续寻找其他goroutine来运行&lt;/li>
&lt;li>被抢占的G再次调度过来执行时，会继续原来的执行流&lt;/li>
&lt;/ol>
&lt;p>抢占分为&lt;code>_Prunning&lt;/code>和&lt;code>_Psyscall&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>_Psyscall&lt;/code>抢占通常是由于阻塞性系统调用引起的，比如磁盘io、cgo。&lt;/li>
&lt;li>&lt;code>_Prunning&lt;/code>抢占通常是由于一些类似死循环的计算逻辑引起的。&lt;/li>
&lt;/ul>
&lt;h2 id="work-staeling--hand-off">work staeling &amp;amp; hand off
&lt;/h2>&lt;h3 id="work-stealing-机制">work stealing 机制
&lt;/h3>&lt;p>当线程M⽆可运⾏的G时，尝试从其他M绑定的 P （每次选择的 P 不一定相同）偷取 G（当前 P 中一半的 G），减少空转，提高了线程利用率。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131639460.png"
loading="lazy"
alt="image-20250113163923392"
>&lt;/p>
&lt;h3 id="hand-off-机制">hand off 机制
&lt;/h3>&lt;p>也称为 P 分离机制，当线程 M 因为 G 进行的系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的 M 执行，也提高了线程利用率。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501131646778.png"
loading="lazy"
alt="image-20250113164624713"
>&lt;/p></description></item><item><title>Goroutine</title><link>https://the-oone.github.io/p/goroutine/</link><pubDate>Sun, 12 Jan 2025 16:55:26 +0800</pubDate><guid>https://the-oone.github.io/p/goroutine/</guid><description>&lt;h2 id="为什么需要-goroutine">为什么需要 Goroutine
&lt;/h2>&lt;p>简单一句话，Goroutine 相比线程拥有更优越的开销性能。&lt;/p>
&lt;p>这里先简单介绍下进程、线程、协程：&lt;/p>
&lt;ul>
&lt;li>进程：操作系统创建、资源分配的基本单位、同一个进程内的线程会共享资源。&lt;/li>
&lt;li>线程：操作系统创建、CPU 调度的基本单位、有独立的堆栈空间&lt;/li>
&lt;li>协程：可通过用户程序创建
&lt;ul>
&lt;li>有栈协程：golang&lt;/li>
&lt;li>无栈协程：c++，rust 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Goroutine 就是一个用户级线程，相比传统线程更加轻量（传统协程 1 MB，Goroutine 约 2 KB）。其不涉及内核态的切换，因此 golang 的并发性能很好。&lt;/p>
&lt;h2 id="如何关闭-goroutine">如何关闭 Goroutine
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>关闭 channel&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 根据第二个参数进行判别，当关闭 channel 时，根据其返回结果跳出
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>定期轮询 channel&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">done&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="s">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">done&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ch&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">done&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;接收到的值：&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;over&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>变量 done 作为 channel 类型，用作信号量处理 Goroutine 的关闭。for-loop 结合 select 进行监听，处理完业务之后才会调用 close 关闭 channel。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 context&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">cancel&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WithCancel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Background&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">default&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">cancel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;over&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 context 中，可以借助 ctx.Done 获取一个只读的 channel，可用来识别当前 channel 是否已被关闭。context 对于跨 Goroutine 控制灵活，可以调动 context.WithTimeout 根据时间，或者主动调用 cancel 方法手动关闭。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="如何实现并行-goroutine">如何实现并行 Goroutine
&lt;/h2>&lt;p>通过设置最大的可同时使用的 CPU 核心数&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 设置并行 Goroutine 数量为 2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GOMAXPROCS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="为什么不能大量使用-goroutine">为什么不能大量使用 Goroutine
&lt;/h2>&lt;ul>
&lt;li>虽然 Goroutine 的初始栈（自动扩容）很小，但是大部分业务需要更多的栈空间，而频繁的扩容需要很大的成本。&lt;/li>
&lt;li>Golang 的 GMP 调度模型中的 M 和 P 是有数量限制的，大量的 Goroutine 会导致过长的调度队列，从而影响性能。&lt;/li>
&lt;li>过多的 Goroutine 还会导致频繁的 GC，影响性能。&lt;/li>
&lt;/ul>
&lt;h2 id="goroutine-a-能否停止另一个-goroutine">Goroutine A 能否停止另一个 Goroutine
&lt;/h2>&lt;p>不能。Goroutine 只有自己主动退出，不能被外界的 Goroutine 关闭。&lt;/p>
&lt;h2 id="父-goroutine-退出子-goroutine-一定会退出嘛">父 Goroutine 退出，子 Goroutine 一定会退出嘛
&lt;/h2>&lt;ul>
&lt;li>当&lt;strong>父 Goroutine 为 main&lt;/strong> 时，所有的子 Goroutine 都&lt;strong>会&lt;/strong>跟着父 Goroutine 退出&lt;/li>
&lt;li>若&lt;strong>父 Goroutine 不为 main&lt;/strong> 时，子 Goroutine &lt;strong>不会&lt;/strong>跟着父 Goroutine 退出&lt;/li>
&lt;/ul>
&lt;h2 id="goroutine-的状态流转">Goroutine 的状态流转
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202501132129821.png"
loading="lazy"
alt="image-20250113212939765"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">&lt;/th>
&lt;th style="text-align: center">状态&lt;/th>
&lt;th style="text-align: center">含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">_Gidle&lt;/td>
&lt;td style="text-align: center">空闲态&lt;/td>
&lt;td style="text-align: center">G 刚刚创建，还未初始化&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Grunnable&lt;/td>
&lt;td style="text-align: center">就绪态&lt;/td>
&lt;td style="text-align: center">G 在运行队列，等待 M 取出（此时 M 有 P）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Grunning&lt;/td>
&lt;td style="text-align: center">运行态&lt;/td>
&lt;td style="text-align: center">M 正在运行 G&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Gsyscall&lt;/td>
&lt;td style="text-align: center">系统调用&lt;/td>
&lt;td style="text-align: center">M 中运行的 G 发起系统调用（此时 M 无 P）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Gwaiting&lt;/td>
&lt;td style="text-align: center">阻塞态&lt;/td>
&lt;td style="text-align: center">G 等待执行资源&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Gdead&lt;/td>
&lt;td style="text-align: center">完成态&lt;/td>
&lt;td style="text-align: center">G 已经执行完毕&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">_Gcopystack&lt;/td>
&lt;td style="text-align: center">复制栈&lt;/td>
&lt;td style="text-align: center">G 正获取一个新的栈空间，并将原内容复制过去&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="goroutine-泄露">Goroutine 泄露
&lt;/h2>&lt;p>Goroutine 没有被正确的关闭或管理，会导致他们在程序运行过程中无法被回收，最终导致资源浪费和潜在的性能问题&lt;/p>
&lt;h3 id="泄露原因">泄露原因
&lt;/h3>&lt;ul>
&lt;li>Goroutine 内部进行 channel/mutex 等读写操作被一直阻塞&lt;/li>
&lt;li>Goroutine 内的业务逻辑进入死循环，资源无法释放&lt;/li>
&lt;li>Goroutine 内的业务逻辑进入长时间等待，又不断新增的 Goroutine 进入等待&lt;/li>
&lt;/ul>
&lt;h3 id="泄露场景">泄露场景
&lt;/h3>&lt;ul>
&lt;li>未初始化 channel&lt;/li>
&lt;li>channel 发送未接收&lt;/li>
&lt;li>channel 接收未发送&lt;/li>
&lt;li>资源连接未关闭&lt;/li>
&lt;li>未成功解锁&lt;/li>
&lt;li>死循环&lt;/li>
&lt;li>sync.WaitGroup 使用不当&lt;/li>
&lt;/ul>
&lt;h2 id="多个协程交替打印奇偶数字">多个协程交替打印奇偶数字
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;sync&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 创建两个channel用于同步
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">even&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">odd&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 创建WaitGroup等待所有协程完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">wg&lt;/span> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">WaitGroup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 打印偶数的协程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">defer&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">even&lt;/span> &lt;span class="c1">// 等待偶数信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;偶数: %d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">odd&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span> &lt;span class="c1">// 发送奇数信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 最后一次打印完需要再消费一次even channel,避免死锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">even&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 打印奇数的协程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">defer&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;奇数: %d\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">even&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span> &lt;span class="c1">// 发送偶数信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">odd&lt;/span> &lt;span class="c1">// 等待奇数信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 最后发送一次信号给偶数协程,让其能够退出
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">even&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 等待所有协程完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 关闭channel
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">even&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">odd&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Redis 数据类型</title><link>https://the-oone.github.io/p/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Wed, 18 Dec 2024 21:30:01 +0800</pubDate><guid>https://the-oone.github.io/p/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>&lt;h2 id="string">String
&lt;/h2>&lt;p>String 的底层数据结构是 int 和 SDS（Simple Dynamic String），相比 C 的原生字符串，增加了以下功能&lt;/p>
&lt;ol>
&lt;li>保存二进制文件&lt;/li>
&lt;li>获取字符串长度的时间复杂度是 O(1)&lt;/li>
&lt;li>SDS API 内存安全，保证不会造成缓冲区溢出&lt;/li>
&lt;/ol>
&lt;h3 id="内部编码">内部编码
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>int&lt;/strong>，若字符串保存的是整数值，并且可以转换为 long，那么该字符串对象的编码被设置为 &lt;code>int&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412182154153.png"
loading="lazy"
alt="image-20241218215412113"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>embstr&lt;/strong>，若字符串长度小于等于 44 字节（博主测试环境为 Redis 7.4.1），那么使用 &lt;code>embstr&lt;/code> 编码，&lt;strong>一次内存分配&lt;/strong>。只读，修改内容需先转换 &lt;code>raw&lt;/code> 编码。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412182150682.png"
loading="lazy"
alt="image-20241218215051546"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>raw&lt;/strong>，若字符串长度大于 44 字节，那么使用 &lt;code>raw&lt;/code> 编码，&lt;strong>两次内存分配&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412182151676.png"
loading="lazy"
alt="image-20241218215124643"
>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="常用指令">常用指令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/set/" target="_blank" rel="noopener"
>SET&lt;/a>&lt;/p>
&lt;p>设置 key 为字符串值。 如果 key 已有值，无论其类型如何，都会被覆盖。 在 SET 操作成功后，之前与键值相关的任何生存时间都将被丢弃。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SET key value [NX | XX] [GET] [EX seconds | PX milliseconds |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;code>EX&lt;/code> &amp;ndash; 设置指定的过期时间，以秒（正整数）为单位。&lt;/li>
&lt;li>&lt;code>PX&lt;/code> &amp;ndash; 设置指定的过期时间，以毫秒（正整数）为单位。&lt;/li>
&lt;li>&lt;code>EXAT&lt;/code> &amp;ndash; 设置指定的密钥过期时间，以秒（正整数）为单位。&lt;/li>
&lt;li>&lt;code>PXAT&lt;/code> &amp;ndash; 设置密钥过期的 Unix 时间，以毫秒为单位（正整数）。&lt;/li>
&lt;li>&lt;code>NX&lt;/code> &amp;ndash; 当且仅当 key 不存在时才设置。&lt;/li>
&lt;li>&lt;code>XX&lt;/code> &amp;ndash; 无论如何都会设置 key。&lt;/li>
&lt;li>&lt;code>KEEPTTL&lt;/code> &amp;ndash; 继承上一个 key 的有效时间。&lt;/li>
&lt;li>&lt;code>GET&lt;/code> &amp;ndash; 返回存储在密钥中的旧字符串，如果密钥不存在，则返回 nil。 如果键值不是字符串，会返回错误并中止 SET。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/mset/" target="_blank" rel="noopener"
>MSET&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/msetnx/" target="_blank" rel="noopener"
>MSETNX&lt;/a>&lt;/p>
&lt;p>将给定的键设置为各自的值。 两者都是原子式的，因此所有给定键都会被一次性设置。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">MSET key value [key value ...]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">MSETNX key value [key value ...] # key 必须均不存在
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/incr/" target="_blank" rel="noopener"
>INCR&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/incrby/" target="_blank" rel="noopener"
>INCRBY&lt;/a>&lt;/p>
&lt;p>对 key 中存储数字进行加法操作，如果键不存在，则在执行操作前将其设置为 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">INCR key # 将存储在键上的数字递增 1。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">INCRBY key increment # 将存储在键上的数字递增 increment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/decr/" target="_blank" rel="noopener"
>DECR&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/decrby/" target="_blank" rel="noopener"
>DECRBY&lt;/a>&lt;/p>
&lt;p>对 key 中存储数字进行减法操作，如果键不存在，则在执行操作前将其设置为 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">DECR key # 将存储在键上的数字递减 1。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">DECRBY key increment # 将存储在键上的数字递减 increment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/get/" target="_blank" rel="noopener"
>GET&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/mget/" target="_blank" rel="noopener"
>MGET&lt;/a>&lt;/p>
&lt;p>获取 key 的值。 如果键不存在，则返回特殊值 nil。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GET key
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">MGET key [key ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景">应用场景
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>缓存对象&lt;/p>
&lt;/li>
&lt;li>
&lt;p>计数器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分布式锁&lt;/p>
&lt;ul>
&lt;li>
&lt;p>若 key 不存在，则显示插入成功，表示加锁成功&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若 key 存在，则显示插入失败，表示加锁失败&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要配合 Lua 脚本实现原子性&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>共享 Session 信息&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="list">List
&lt;/h2>&lt;p>List 是简单的字符串列表（&lt;strong>按照插入顺序排序&lt;/strong>），可以从头部或者尾部向 List 添加元素，链表最大长度为&lt;code> $2^{32}-1$&lt;/code>&lt;/p>
&lt;h3 id="内部实现">内部实现
&lt;/h3>&lt;ul>
&lt;li>3.2 版本之前由双向链表或压缩链表实现。&lt;/li>
&lt;li>3.2 版本之后由 QuickList 实现。其是多个节点（压缩列表）组成的双向链表，每个元素可以是一个整数或一个字节数组。&lt;/li>
&lt;/ul>
&lt;h3 id="常用指令-1">常用指令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lpush/" target="_blank" rel="noopener"
>LPUSH&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/rpush/" target="_blank" rel="noopener"
>RPUSH&lt;/a>&lt;/p>
&lt;p>将所有指定值插入存储在 key 处的列表头部。 如果 key 不存在，则在执行推送操作前将其创建为空列表。 如果 key 持有的值不是 list，则会返回错误信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LPUSH/RPUSH key element [element ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;div>&lt;table frame=void> &lt;!--用了&lt;div>进行封装-->
&lt;tr>
&lt;td>&lt;div>&lt;center> &lt;!--每个格子内是图片加标题-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271043542.png"
alt="LPUSH 命令"
height="120"/> &lt;!--高度设置-->
&lt;br> &lt;!--换行-->
LPUSH 命令 &lt;!--标题1-->
&lt;/center>&lt;/div>&lt;/td>
&lt;td>&lt;div>&lt;center> &lt;!--第二张图片-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271044094.png"
alt="RPUSH 命令"
height="120"/>
&lt;br>
RPUSH 命令
&lt;/center>&lt;/div>&lt;/td>
&lt;/tr>
&lt;/table>&lt;/div>
&lt;ol start="2">
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lpushx/" target="_blank" rel="noopener"
>LPUSHX&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/rpushx/" target="_blank" rel="noopener"
>RPUSHX&lt;/a>&lt;/p>
&lt;p>仅在 key 已存在并持有一个列表的情况下，在 key 所在列表的首部插入指定值。 如果 key 不存在，则不会执行任何操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LPUSHX/RPUSHX key element [element ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lpop/" target="_blank" rel="noopener"
>LPOP&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/rpop/" target="_blank" rel="noopener"
>RPOP&lt;/a>&lt;/p>
&lt;p>删除并返回存储在 key 处的列表的 &lt;strong>最初/最后&lt;/strong> 一个元素。 默认情况下，该命令从列表 &lt;strong>头部/尾部&lt;/strong> 弹出一个元素。 如果提供了可选的 count 参数，则根据列表的长度，回复最多包含 count 个元素。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LPOP/RPOP key [count]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271354782.png"
loading="lazy"
alt="image-20241227135404729"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/blpop/" target="_blank" rel="noopener"
>BLPOP&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/brpop/" target="_blank" rel="noopener"
>BRPOP&lt;/a>&lt;/p>
&lt;p>&lt;strong>BLPOP/BRPOP&lt;/strong> 是一种阻塞列表弹出原语。 它是 &lt;strong>LPOP/RPOP&lt;/strong> 的阻塞版本，因为当没有元素从任何给定列表中弹出时，它会阻塞连接。 元素会从第一个非空列表的 &lt;strong>头部/尾部&lt;/strong> 弹出，并按照给定键的顺序进行检查。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">BLPOP/RLPOP key [key ...] timeout
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lindex/" target="_blank" rel="noopener"
>LINDEX&lt;/a>&lt;/p>
&lt;p>返回存储在 key 中的列表中位于 index 索引处的元素。 索引以 0 为单位，因此 0 表示第一个元素，1 表示第二个元素，以此类推。 负指数可用于指定从列表尾部开始的元素。 这里，-1 表示最后一个元素，-2 表示倒数第二个元素，以此类推。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LINDEX key index
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/llen/" target="_blank" rel="noopener"
>LLEN&lt;/a>&lt;/p>
&lt;p>返回存储在 key 处的 list 的长度。 如果 key 不存在，则将其解释为空列表，并返回 0。 如果 key 中存储的值不是 list，则会返回错误信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LLEN key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lrange/" target="_blank" rel="noopener"
>LRANGE&lt;/a>&lt;/p>
&lt;p>返回存储在 key 处的列表的指定元素。 偏移量 start 和 stop 是基于 0 的索引，0 代表列表的第一个元素（列表的头），1 代表下一个元素，以此类推。 这些偏移量也可以是负数，表示从列表的末尾开始的偏移量。 例如，-1 是列表的最后一个元素，-2 是倒数第二个元素，以此类推。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LRANGE key start stop
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lrem/" target="_blank" rel="noopener"
>LREM&lt;/a>&lt;/p>
&lt;p>从存储在 key 处的列表中移除与元素相同的元素的第一个出现次数。 计数参数对操作的影响如下：count &amp;gt; 0：删除从头部移到尾部的与元素相同的元素。 count &amp;lt; 0：删除从尾部移到头部的与元素相同的元素。 例如，LREM list -2 &amp;ldquo;hello &amp;ldquo;将删除存储在 list 中的 &amp;ldquo;hello &amp;ldquo;的最后两次出现。 请注意，不存在的键会被当作空 list 处理。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LREM key count element
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/ltrim/" target="_blank" rel="noopener"
>LTRIM&lt;/a>&lt;/p>
&lt;p>裁剪现有列表，使其只包含指定范围的元素。 start 和 stop 都是基于 0 的索引，其中 0 代表列表的第一个元素（头部），1 代表下一个元素，依此类推。 例如，LTRIM foobar 0 2 将修改存储在 foobar 处的列表，使其只保留列表的前三个元素： start 和 end 也可以是负数，表示与列表末尾的偏移量，其中 -1 表示列表的最后一个元素，-2 表示倒数第二个元素，依此类推。 超出范围的索引不会产生错误：如果 start 大于列表末尾，或 start &amp;gt; end，结果将是一个空列表（导致键被移除）。 如果 end 大于列表末尾，Redis 会将其视为列表的最后一个元素。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LTRIM key start stop
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/lset/" target="_blank" rel="noopener"
>LSET&lt;/a>&lt;/p>
&lt;p>将索引处的列表元素设置为指定值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LSET key index element
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/linsert/" target="_blank" rel="noopener"
>LINSERT&lt;/a>&lt;/p>
&lt;p>将元素插入存储在 key 处的列表中的参考值 pivot 之前或之后。 如果 key 不存在，则视为空列表，不执行任何操作。 如果 key 存在但不包含列表值，则返回错误信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">LINSERT key &amp;lt;BEFORE | AFTER&amp;gt; pivot element
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/brpoplpush/" target="_blank" rel="noopener"
>BRPOPLPUSH&lt;/a>&lt;/p>
&lt;p>BRPOPLPUSH 是 RPOPLPUSH 的阻塞变体。 当源代码包含元素时，该命令的行为与 RPOPLPUSH 完全相同。 在 MULTI/EXEC 块内使用时，该命令的行为与 RPOPLPUSH 完全相同。 当源为空时，Redis 会阻塞连接，直到有其他客户端向其推送或超时。 如果超时为零，则会无限期阻塞。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">BRPOPLPUSH source destination timeout
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-1">应用场景
&lt;/h3>&lt;ul>
&lt;li>消息队列
&lt;ul>
&lt;li>&lt;strong>消息保存&lt;/strong>：LPUSH + RPOP / RPUSH+LPOP 实现消息队列（使用 BRPOP 命令进行阻塞式读取，减少消费者性能损失）&lt;/li>
&lt;li>&lt;strong>重复消息处理&lt;/strong>：生产者实现全局唯一 ID&lt;/li>
&lt;li>&lt;strong>消息可靠性&lt;/strong>：BRPOPLPUSH（使得消费者从一个 List 中读取消息，同时 Redis 还会把消息再插入到另一个 List 留存）&lt;/li>
&lt;li>&lt;em>List 不支持多个消费者消费同一条信息&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="hash">Hash
&lt;/h2>&lt;p>Hash 是一个 key-value 集合，&lt;/p>
&lt;h3 id="内部实现-1">内部实现
&lt;/h3>&lt;div>&lt;table frame=void> &lt;!--用了&lt;div>进行封装-->
&lt;tr>
&lt;td>&lt;div>&lt;center> &lt;!--每个格子内是图片加标题-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271430099.png"
alt="压缩列表"
height="130"/> &lt;!--高度设置-->
&lt;br> &lt;!--换行-->
listpack &lt;!--标题1-->
&lt;/center>&lt;/div>&lt;/td>
&lt;td>&lt;div>&lt;center> &lt;!--第二张图片-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271431225.png"
alt="哈希表"
height="130"/>
&lt;br>
hashtable
&lt;/center>&lt;/div>&lt;/td>
&lt;/tr>
&lt;/table>&lt;/div>
&lt;ul>
&lt;li>如果 Hash 元素小于 512（默认） 个，所有值小于 64 字节（默认）时，Redis 会使用 listpack 作为底层数据结构。&lt;/li>
&lt;li>剩余情况，Redis 会使用 hashtable实现&lt;/li>
&lt;/ul>
&lt;h3 id="常用命令">常用命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hset/" target="_blank" rel="noopener"
>HSET&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/hsetnx/" target="_blank" rel="noopener"
>HSETNX&lt;/a>&lt;/p>
&lt;p>将指定字段的值设置为存储在 key 的哈希值中各自的值。 HSET 会覆盖哈希值中存在的指定字段的值，HSETNX 对于已存在的字段操作无效。 如果 key 不存在，则会创建一个新的散列键。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HSET key field value [field value ...]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HSETNX key field value
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hget/" target="_blank" rel="noopener"
>HGET&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/hmget/" target="_blank" rel="noopener"
>HMGET&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/hgetall/" target="_blank" rel="noopener"
>HGETALL&lt;/a>&lt;/p>
&lt;p>&lt;em>HGET/HMGET&lt;/em> 返回键存储的哈希值中与字段相关的值。 对于散列中不存在的每个字段，都会返回一个 nil 值。 由于不存在的键被视为空哈希值，因此针对不存在的键运行 HMGET 将返回一个 nil 值列表。&lt;/p>
&lt;p>&lt;em>HGETALL&lt;/em> 返回存储在 key 处的哈希值的所有字段和值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HGET key field
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HMGET key field [field ...]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HGETALL key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hdel/" target="_blank" rel="noopener"
>HDEL&lt;/a>&lt;/p>
&lt;p>从存储在 key 中的哈希值中删除指定字段。 不存在于散列中的指定字段将被忽略。 如果没有字段，则删除散列。 如果键不存在，则将其视为空散列，此命令返回 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HDEL key field [field ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hlen/" target="_blank" rel="noopener"
>HLEN&lt;/a>&lt;/p>
&lt;p>返回存储在 key 中的哈希值所包含字段的数量。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HLEN key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hexists/" target="_blank" rel="noopener"
>HEXISTS&lt;/a>&lt;/p>
&lt;p>如果字段是存储在 key 处的哈希值中的现有字段，则返回 1，否则返回 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HEXISTS key field
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hkeys/" target="_blank" rel="noopener"
>HKEYS&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/hvals/" target="_blank" rel="noopener"
>HVALS&lt;/a>&lt;/p>
&lt;p>&lt;em>HKEYS&lt;/em> 返回存储在 key 处的哈希值中的所有字段名。&lt;/p>
&lt;p>&lt;em>HVALS&lt;/em> 返回键存储的哈希值中的所有值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HKEYS key
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HVALS key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/hincrby/" target="_blank" rel="noopener"
>HINCRBY&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/hincrbyfloat/" target="_blank" rel="noopener"
>HINCRBYFLOAT&lt;/a>&lt;/p>
&lt;p>&lt;em>HINCRBY&lt;/em> 按增量递增存储在 key 的哈希值中的字段数字。 如果 key 不存在，则会创建一个新的哈希值键。 如果字段不存在，则在执行操作前将其值设置为 0。&lt;/p>
&lt;p>&lt;em>HINCRBYFLOAT&lt;/em> 按指定增量递增存储在键值处的散列指定字段，该字段代表一个浮点数。 如果增量为负值，结果是哈希字段值递减而不是递增。 如果字段不存在，则在执行操作前将其设置为 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">HINCRBY key field increment
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HINCRBYFLOAT key field increment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-2">应用场景
&lt;/h3>&lt;ul>
&lt;li>缓存对象
&lt;ul>
&lt;li>(key，field，value) 对应 (对象，属性，值)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>购物车
&lt;ul>
&lt;li>添加商品：HSET cart:{user_id}{goods_id} 1&lt;/li>
&lt;li>增加数量：HINCRBY cart:{user_id}{goods_id} 2&lt;/li>
&lt;li>商品总数：HLEN cart:{user_id}&lt;/li>
&lt;li>删除商品：HDEL cart:{user_id} {goods_id}&lt;/li>
&lt;li>获取所有商品：HGETALL cart:{usert_id}&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="set">Set
&lt;/h2>&lt;p>Set 是一个集合（最多支持存储 $2^{32}-1$ 个元素），其中元素&lt;strong>无序、唯一&lt;/strong>。除了支持集合内的增删改查，还支持多个集合交集、并集、差集。&lt;/p>
&lt;h3 id="内部实现-2">内部实现
&lt;/h3>&lt;ul>
&lt;li>如果集合元素都是整数，并且元素个数小于 512（默认），Redis 会使用 整数集合作为底层数据结构。&lt;/li>
&lt;li>其他情况，Redis 会使用 listpack 作为底层数据结构&lt;/li>
&lt;/ul>
&lt;div>&lt;table frame=void> &lt;!--用了&lt;div>进行封装-->
&lt;tr>
&lt;td>&lt;div>&lt;center> &lt;!--每个格子内是图片加标题-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271556118.png"
alt="整数集合"
height="130"/> &lt;!--高度设置-->
&lt;br> &lt;!--换行-->
intset &lt;!--标题1-->
&lt;/center>&lt;/div>&lt;/td>
&lt;td>&lt;div>&lt;center> &lt;!--第二张图片-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271558737.png"
alt="哈希表"
height="130"/>
&lt;br>
listpack
&lt;/center>&lt;/div>&lt;/td>
&lt;/tr>
&lt;/table>&lt;/div>
&lt;h3 id="常用命令-1">常用命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/sadd/" target="_blank" rel="noopener"
>SADD&lt;/a>&lt;/p>
&lt;p>将指定的成员添加到存储在 key 处的集合中。 如果指定的成员已经是这个集合的成员，则会被忽略。 如果 key 不存在，则会先创建一个新集合，然后再添加指定的成员。 如果存储在 key 中的值不是一个集合，则会返回错误信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SADD key member [member ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/srem/" target="_blank" rel="noopener"
>SREM&lt;/a>&lt;/p>
&lt;p>从存储在 key 处的集合中删除指定的成员。 不属于此集合的指定成员将被忽略。 如果 key 不存在，则将其视为空集，此命令返回 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SREM key member [member ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/smembers/" target="_blank" rel="noopener"
>SMEMBERS&lt;/a>&lt;/p>
&lt;p>返回存储在 key 处的集合值的所有成员。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SMEMBERS key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/sismember/" target="_blank" rel="noopener"
>SISMEMBER&lt;/a>&lt;/p>
&lt;p>返回成员是否是存储在 key 中的集合的成员。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SISMEMBER key member
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/scard/" target="_blank" rel="noopener"
>SCARD&lt;/a>&lt;/p>
&lt;p>返回存储在 key 处的集合的元素个数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SCARD key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/srandmember/" target="_blank" rel="noopener"
>SRANDMEMBER&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/spop/" target="_blank" rel="noopener"
>SPOP&lt;/a>&lt;/p>
&lt;p>&lt;em>SRANDMEMBER&lt;/em> 将从存储在 key 处的集合值中随机返回 count 个元素，元素不从 key 中删除。&lt;/p>
&lt;p>&lt;em>SPOP&lt;/em> 将从存储在 key 处的集合值中随机返回 count 个元素，元素从 key 中删除。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SRANDMEMBER key [count]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SPOP key [count]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/smove/" target="_blank" rel="noopener"
>SMOVE&lt;/a>&lt;/p>
&lt;p>将成员从源集合移动到目标集合。 该操作是原子操作。 如果源集合不存在或不包含指定元素，则不执行任何操作，并返回 0。 否则，该元素将从源集合中删除，并添加到目标集合中。 如果指定的元素已存在于目标集合中，则只会从源集合中移除。 如果源集合或目标集合中不存在集合值，则会返回错误信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SMOVE source destination member
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/sinter/" target="_blank" rel="noopener"
>SINTER&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/sinterstore/" target="_blank" rel="noopener"
>SINTERSTORE&lt;/a>&lt;/p>
&lt;p>&lt;em>SINTER&lt;/em> 返回所有给定集合的交集所产生的集合的成员。&lt;/p>
&lt;p>&lt;em>SINTERSTORE&lt;/em> 该命令等同于 SINTER，但不是返回结果集，而是将其存储在目的地中。 如果目的地已经存在，则会被覆盖。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SINTER key [key ...]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SINTERSTORE destination key [key ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-3">应用场景
&lt;/h3>&lt;ul>
&lt;li>点赞（元素唯一）&lt;/li>
&lt;li>共同好友（集合运算）
&lt;ul>
&lt;li>数据量较大时，可以让从库进行集合运算，将结果返回给客户端，防止 Redis 阻塞。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>抽奖（元素唯一，去重）&lt;/li>
&lt;/ul>
&lt;h2 id="zset">Zset
&lt;/h2>&lt;p>Zset 相较于 Set 多了个排序属性 score，每个存储元素相当于两个值组成，一个是有序集合的元素值，一个是排序值。&lt;/p>
&lt;h3 id="内部实现-3">内部实现
&lt;/h3>&lt;ul>
&lt;li>若 Zset 中元素小于 128 个，且每个元素小于 64 字节，Redis 使用 listpack 作为底层数据结构。&lt;/li>
&lt;li>剩余情况，Redis 会使用&lt;/li>
&lt;/ul>
&lt;div>&lt;table frame=void> &lt;!--用了&lt;div>进行封装-->
&lt;tr>
&lt;td>&lt;div>&lt;center> &lt;!--每个格子内是图片加标题-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271628134.png"
alt="listpack"
height="130"/> &lt;!--高度设置-->
&lt;br> &lt;!--换行-->
listpack &lt;!--标题1-->
&lt;/center>&lt;/div>&lt;/td>
&lt;td>&lt;div>&lt;center> &lt;!--第二张图片-->
&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412271628892.png"
alt="跳表"
height="130"/>
&lt;br>
skiplist
&lt;/center>&lt;/div>&lt;/td>
&lt;/tr>
&lt;/table>&lt;/div>
&lt;h3 id="常用命令-2">常用命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zadd/" target="_blank" rel="noopener"
>ZADD&lt;/a>&lt;/p>
&lt;p>将具有指定分数的所有指定成员添加到存储在 key 处的排序集合中。 可以指定多个分数/成员对。 如果指定的成员已经是排序集合的成员，则会更新得分，并将元素重新插入正确的位置，以确保排序正确。 如果 key 不存在，则会创建一个新的排序集合，并将指定的成员作为唯一成员，就像排序集合为空一样。 如果键存在，但没有排序集，则会返回错误信息。 分数值应是双精度浮点数的字符串表示。 +inf 和 -inf 值也是有效值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>XX&lt;/strong>: 只更新已存在的元素，不添加新元素。&lt;/li>
&lt;li>&lt;strong>NX&lt;/strong>: 只添加新元素，不更新已存在的元素。&lt;/li>
&lt;li>&lt;strong>LT&lt;/strong>: 只在新分数小于当前分数时更新现有元素。此标记不会阻止添加新元素。&lt;/li>
&lt;li>&lt;strong>GT&lt;/strong>: 仅在新分数大于当前分数时更新现有元素。 此标记不会阻止添加新元素。&lt;/li>
&lt;li>&lt;strong>CH&lt;/strong>: 将返回值从增加的新元素数量修改为改变的元素总数（CH 是 changed 的缩写）。 更改的元素是指新增的元素和已存在的元素，这些元素的分值已被更新。 因此，命令行中指定的元素如果得分与过去相同，则不计算在内。 注意：通常情况下，ZADD 的返回值只计算新增元素的数量。&lt;/li>
&lt;li>&lt;strong>INCR&lt;/strong>: 指定该选项时，ZADD 的作用与 ZINCRBY 类似。 在这种模式下，只能指定一个分数元素对。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zrem/" target="_blank" rel="noopener"
>ZREM&lt;/a>&lt;/p>
&lt;p>从存储在 key 中的排序集合中删除指定的成员。 如果 key 存在但没有排序集，则会返回错误信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZREM key member [member ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zscore/" target="_blank" rel="noopener"
>ZSCORE&lt;/a>&lt;/p>
&lt;p>返回排序集合中 key 处成员的得分。 如果排序集合中不存在成员或 key 不存在，则返回 nil。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZSCORE key member
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zcard/" target="_blank" rel="noopener"
>ZCARD&lt;/a>&lt;/p>
&lt;p>返回存储在 key 处的排序集的元素个数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZCARD key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zincrby/" target="_blank" rel="noopener"
>ZINCRBY&lt;/a>&lt;/p>
&lt;p>用增量递增键值存储的排序集合中成员的得分。 如果成员不存在于排序集合中，则会以增量作为其得分（就像它之前的得分是 0.0）。 如果 key 不存在，则会创建一个以指定成员为唯一成员的新排序集。 如果 key 存在但不包含排序集，则会返回错误信息。 分数值应是数值的字符串表示，并接受双精度浮点数。 可以提供一个负值来递减分数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZINCRBY key increment member
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zrange/" target="_blank" rel="noopener"
>ZRANGE&lt;/a>&lt;/p>
&lt;p>返回存储在 key 中的排序集合中元素的指定范围。 ZRANGE 可以执行不同类型的范围查询：按索引（秩）、按分数或按词典顺序。&lt;/p>
&lt;p>默认情况下，该命令执行索引范围查询。 start 和 stop 参数代表基于零的索引，其中 0 代表第一个元素。 这些参数指定了一个包含范围，例如，ZRANGE myzset 0 1 将同时返回排序集的第一个和第二个元素。 索引也可以是负数，表示从排序集末尾开始的偏移量，-1 表示排序集的最后一个元素。&lt;/p>
&lt;p>当提供 BYSCORE 选项时，命令的行为与 ZRANGEBYSCORE 类似，返回排序集中分数等于或介于 start 和 stop 之间的元素范围。&lt;/p>
&lt;p>使用 REV 选项会反转排序集，索引 0 将作为得分最高的元素。&lt;/p>
&lt;p>当使用 BYLEX 选项时，命令的行为与 ZRANGEBYLEX 类似，并返回排序集合中 start 和 stop 之间的元素范围。 请注意，词典排序依赖于所有元素具有相同的分数。 有效的 start 和 stop 必须以 ( 或 [ 开头，以便分别指定范围区间是排他的还是包含的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/zunionstore/" target="_blank" rel="noopener"
>ZUNIONSTORE&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/zdiffstore/" target="_blank" rel="noopener"
>ZDIFFSTORE&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE &amp;lt;SUM | MIN | MAX&amp;gt;] # 并集
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ZDIFFSTORE destination numkeys key [key ...] # 第一个集合和之后集合的差集
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-4">应用场景
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>排行榜（有序唯一）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>电话、姓名排序&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="bitmap">BitMap
&lt;/h2>&lt;p>BitMap 是一串连续的二进制数组，可以通过偏移量定位元素，适合数据量大且使用二值统计的场景。&lt;/p>
&lt;h3 id="内部实现-4">内部实现
&lt;/h3>&lt;p>String 类型是会保存为二进制的字节数组&lt;/p>
&lt;h3 id="常用命令-3">常用命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/setbit/" target="_blank" rel="noopener"
>SETBIT&lt;/a>&lt;/p>
&lt;p>设置或清除存储在 key 处字符串值偏移量的位。 位的设置或清除取决于值，值可以是 0 或 1。当 key 不存在时，将创建一个新的字符串值。 字符串的增长是为了确保它能容纳偏移量处的位。 偏移参数必须大于或等于 0，且小于 2^32（这将位图限制在 512MB）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SETBIT key offset value
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/getbit/" target="_blank" rel="noopener"
>GETBIT&lt;/a>&lt;/p>
&lt;p>返回存储在 key 处的字符串值中偏移量处的比特值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GETBIT key offset
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/bitcount/" target="_blank" rel="noopener"
>BITCOUNT&lt;/a>&lt;/p>
&lt;p>获取指定范围内值为 1 的个数，默认以字节为单位。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">BITCOUNT key [start end [BYTE | BIT]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/bitop/" target="_blank" rel="noopener"
>BITOP&lt;/a>&lt;/p>
&lt;p>在多个键（包含字符串值）之间执行位操作，并将结果存储到目标键中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">BITOP &amp;lt;AND | OR | XOR | NOT&amp;gt; destkey key [key ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-5">应用场景
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>签到统计&lt;/p>
&lt;/li>
&lt;li>
&lt;p>判断用户登陆态&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="hyperloglog">HyperLogLog
&lt;/h2>&lt;p>HyperLogLog 是一种用于统计基数的数据集合类型，基数统计就是指&lt;strong>统计一个集合中不重复的元素个数&lt;/strong>。HyperLogLog 的&lt;strong>统计规则基于概率完成，标准误算率为 0.81%&lt;/strong>。&lt;/p>
&lt;h3 id="内部实现-5">内部实现
&lt;/h3>&lt;p>^ - ^&lt;/p>
&lt;h3 id="常见命令">常见命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/pfadd/" target="_blank" rel="noopener"
>PFADD&lt;/a>&lt;/p>
&lt;p>将所有元素参数添加到存储在作为第一个参数指定的变量名下的 HyperLogLog 中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">PFADD key [element [element ...]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/pfcount/" target="_blank" rel="noopener"
>PFCOUNT&lt;/a>&lt;/p>
&lt;p>使用单键调用时，返回存储在指定变量中的 HyperLogLog 的基数估算值，如果变量不存在，则返回 0。 使用多键调用时，通过内部合并存储在所提供键中的 HyperLogLog 成一个临时的 HyperLogLog，返回所传递的 HyperLogLog 联合的基数估算值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">PFCOUNT key [key ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/pfmerge/" target="_blank" rel="noopener"
>PFMERGE&lt;/a>&lt;/p>
&lt;p>将多个 HyperLogLog 值合并为一个 HyperLogLog 。如果目标 HyperLogLog 不存在（默认为空 HyperLogLog），则创建。 如果存在，则将其视为源集之一。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">PFMERGE destkey [sourcekey [sourcekey ...]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-6">应用场景
&lt;/h3>&lt;ul>
&lt;li>网页用户访问(UV)计数&lt;/li>
&lt;/ul>
&lt;h2 id="geo">GEO
&lt;/h2>&lt;p>主要用于存储地理信息&lt;/p>
&lt;h3 id="内部实现-6">内部实现
&lt;/h3>&lt;p>底层复用 Zset，使用 GeoHash 实现了经纬度到 Zset 中元素的权重分数的转换，关键机制是 &lt;em>二维地图区间划分&lt;/em> 和 &lt;em>区间编码&lt;/em> 。地理位置转换为经纬度后，使用区间编码标识，并将编码值作为 Zset 的权重分数。&lt;/p>
&lt;h3 id="常用命令-4">常用命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/geoadd/" target="_blank" rel="noopener"
>GEOADD&lt;/a>&lt;/p>
&lt;p>存储指定的地理位置信息，将经度，纬度，位置名称添加到指定的 key 中&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>XX&lt;/strong>: 只更新已存在的元素，从不添加元素。&lt;/li>
&lt;li>&lt;strong>NX&lt;/strong>: 不更新已存在的元素。&lt;/li>
&lt;li>&lt;strong>CH&lt;/strong>: 不更新已存在的元素。 总是添加新元素： 将返回值从添加的新元素数修改为更改的元素总数。 更改的元素是指新增的元素和坐标已更新的已有元素。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/geopos/" target="_blank" rel="noopener"
>GEOPOS&lt;/a>&lt;/p>
&lt;p>返回关键字处排序集所代表的地理空间索引中所有指定成员的位置（经度、纬度）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GEOPOS key [member [member ...]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/geodist/" target="_blank" rel="noopener"
>GEODIST&lt;/a>&lt;/p>
&lt;p>返回排序集所代表的地理空间索引中两个成员之间的距离。 单位必须是以下之一，默认为米：m 表示米。 km 表示公里。 mi 表示英里。 ft 表示英尺。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GEODIST key member1 member2 [M | KM | FT | MI]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/georadius/" target="_blank" rel="noopener"
>GEORADIUS&lt;/a>&lt;/p>
&lt;p>返回使用 GEOADD 填充了地理空间信息的排序集合的成员，这些成员位于以中心位置和距中心最大距离（半径）指定的区域边界内。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GEORADIUS key longitude latitude radius &amp;lt;M | KM | FT | MI&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC | DESC]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [STORE key | STOREDIST key]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="应用场景-7">应用场景
&lt;/h3>&lt;ul>
&lt;li>位置信息服务&lt;/li>
&lt;/ul>
&lt;h2 id="stream">Stream
&lt;/h2>&lt;p>专为消息队列设计的数据类型，支持消息持久化、自动生成全局唯一 ID、支持 ACK 确认消息、支持消费组模式&lt;/p>
&lt;h3 id="内部实现-7">内部实现
&lt;/h3>&lt;p>^ - ^&lt;/p>
&lt;h3 id="常见命令-1">常见命令
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/xadd/" target="_blank" rel="noopener"
>XADD&lt;/a>&lt;/p>
&lt;p>将指定的数据流条目添加到指定键的数据流中。 如果键值不存在，则使用流的值创建键值。 可以使用 NOMKSTREAM 选项禁用创建数据流键。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">XADD key [NOMKSTREAM] [&amp;lt;MAXLEN | MINID&amp;gt; [= | ~] threshold
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [LIMIT count]] &amp;lt;* | id&amp;gt; field value [field value ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/xlen/" target="_blank" rel="noopener"
>XLEN&lt;/a>&lt;/p>
&lt;p>返回数据流中的条目数。 如果指定的键不存在，命令将返回 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">XLEN key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/xread/" target="_blank" rel="noopener"
>XREAD&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/xreadgroup/" target="_blank" rel="noopener"
>XREADGROUP&lt;/a>&lt;/p>
&lt;p>&lt;em>XREAD&lt;/em> 从一个或多个数据流中读取数据，只返回 ID 大于调用者报告的最后接收 ID 的条目。 该命令有一个选项，可在项目不可用时阻塞。&lt;/p>
&lt;p>&lt;em>XREADGROUP&lt;/em> 命令是 XREAD 命令的一个特殊版本，支持消费者组。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] id [id ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/xdel/" target="_blank" rel="noopener"
>XDEL&lt;/a>&lt;/p>
&lt;p>从数据流中删除指定条目，并返回已删除条目的数量。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">XDEL key id [id ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/xrange/" target="_blank" rel="noopener"
>XRANGE&lt;/a>&lt;/p>
&lt;p>该命令返回与给定 ID 范围匹配的数据流条目。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">XRANGE key start end [COUNT count]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://redis.io/docs/latest/commands/xpending/" target="_blank" rel="noopener"
>XPENDING&lt;/a> / &lt;a class="link" href="https://redis.io/docs/latest/commands/xack/" target="_blank" rel="noopener"
>XACK&lt;/a>&lt;/p>
&lt;p>&lt;em>XPENDING&lt;/em> 查询每个消费组内所有消费者 &lt;strong>已读取、尚未确认&lt;/strong> 的消息。&lt;/p>
&lt;p>&lt;em>XACK&lt;/em> 向消息队列确认消息处理已完成&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">XPENDING key group [[IDLE min-idle-time] start end count [consumer]]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">XACK key group id [id ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol></description></item><item><title>Redis简介</title><link>https://the-oone.github.io/p/redis%E7%AE%80%E4%BB%8B/</link><pubDate>Mon, 16 Dec 2024 20:29:41 +0800</pubDate><guid>https://the-oone.github.io/p/redis%E7%AE%80%E4%BB%8B/</guid><description>&lt;h2 id="redis-简介">Redis 简介
&lt;/h2>&lt;p>Redis（&lt;em>REmote DIctionary Serve&lt;/em>）是一个开源的基于内存的 Key-Value 数据库，常常用于&lt;strong>缓存、消息队列、分布式锁等场景&lt;/strong>。除此之外，Redis 还支持&lt;strong>事务、持久化、Lua 脚本、集群（主从、哨兵、切片）、发布/订阅&lt;/strong>等等。&lt;/p>
&lt;h2 id="redis-对比-memcached">Redis 对比 Memcached
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">&lt;/th>
&lt;th style="text-align: center">Redis&lt;/th>
&lt;th style="text-align: center">Memcached&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">数据类型&lt;/td>
&lt;td style="text-align: center">String、Hash、Lits、Set、ZSet、Bitmap&lt;br />HyperLogLog、GEO、Stream&lt;/td>
&lt;td style="text-align: center">String、Integer、ByteArray、List、Set&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">持久化&lt;/td>
&lt;td style="text-align: center">原生支持（AOF、RDB）&lt;/td>
&lt;td style="text-align: center">原生不支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">集群&lt;/td>
&lt;td style="text-align: center">原生支持（主从复制、哨兵、切片）&lt;/td>
&lt;td style="text-align: center">原生不支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">其他功能&lt;/td>
&lt;td style="text-align: center">发布/订阅、Lua 脚本、事务等等&lt;/td>
&lt;td style="text-align: center">——&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="redis-使用场景">Redis 使用场景
&lt;/h2>&lt;h2 id="相关资料">相关资料
&lt;/h2>&lt;p>&lt;a class="link" href="https://redis.io/" target="_blank" rel="noopener"
>Redis 官网&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/redis/redis" target="_blank" rel="noopener"
>Redis Github 地址&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://onecompiler.com/redis" target="_blank" rel="noopener"
>Redis 在线服务&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.redisio.com/" target="_blank" rel="noopener"
>Redis 中文文档&lt;/a>&lt;/p></description></item><item><title>Nginx 反向代理</title><link>https://the-oone.github.io/p/nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</link><pubDate>Sat, 07 Dec 2024 20:20:34 +0800</pubDate><guid>https://the-oone.github.io/p/nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</guid><description>&lt;h2 id="需求">需求
&lt;/h2>&lt;p>目前负责一个 Web 项目，该项目前后端是分离的，但是只给了一个端口和服务器进行远程连接。所以问题就出现了，前端需要一个端口用于用户访问，而后端也需要一个端口来和前端进行数据传输，那么就需要至少两个端口才能开启这个 Web 服务。为了解决这个问题，在网上查找资料发现 nginx 可以通过反向代理来实现同一个端口访问不同的服务。话不多说，直接开搞！&lt;/p>
&lt;h2 id="方案">方案
&lt;/h2>&lt;h3 id="nginx-安装">Nginx 安装
&lt;/h3>&lt;p>博主的服务器是 &lt;code>Ubuntu 22.04.4 LTS&lt;/code> ，首先更新一下系统软件包&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo apt update &lt;span class="c1"># 更新软件包列表&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt upgrade &lt;span class="c1"># 更新软件包&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install nginx &lt;span class="c1"># 安装 nginx&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>输入 &lt;code>nginx -v&lt;/code> 命令，如果能看到 nginx 的版本号，则安装成功&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412081720592.png"
loading="lazy"
alt="image-20241208172051452"
>&lt;/p>
&lt;p>安装好之后 Nginx一般会自动打开，如果没有可以使用命令手动打开。（注意如果你开启了防火墙，则需要配置防火墙允许 Nginx可以使用的端口的传输流量。）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo systemctl status nginx &lt;span class="c1"># 查看 nginx 状态&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo systemctl start nginx &lt;span class="c1"># 启动 nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo systemctl stop nginx &lt;span class="c1"># 关闭 nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo systemctl reload nginx &lt;span class="c1"># 重新加载配置文件（不中断服务）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo systemctl restart nginx &lt;span class="c1"># 重启 nginx&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="nginx-配置">Nginx 配置
&lt;/h3>&lt;p>进入你的 Nginx 配置文件，博主是在 &lt;code>/etc/nginx/sites-available/default&lt;/code> 文件中修改的配置。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo vim /etc/nginx/sites-available/default
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以下是博主的配置，前端服务配置在 &lt;code>/&lt;/code> 根路径下，后端配置在 &lt;code>/api/&lt;/code> 路径下。这样我们就可以通过 http://127.0.0.1/ 访问前端服务，http://127.0.0.1/api/ 访问后端服务。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">server &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> listen 80&lt;span class="p">;&lt;/span> &lt;span class="c1"># 监听端口&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> server_name 127.0.0.1&lt;span class="p">;&lt;/span> &lt;span class="c1"># 此处填写你的项目的域名或者 IP&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> location / &lt;span class="o">{&lt;/span> &lt;span class="c1"># 默认访问路径&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_pass http://127.0.0.1:5173&lt;span class="p">;&lt;/span> &lt;span class="c1"># 该项目对外暴露的接口路径&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_set_header Host &lt;span class="nv">$host&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_set_header X-realIP &lt;span class="nv">$remote_addr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_set_header X-Forwarded-for &lt;span class="nv">$proxy_add_x_forwarded_for&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> location /api/ &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_pass http://127.0.0.1:5000&lt;span class="p">;&lt;/span> &lt;span class="c1"># 该项目对外暴露的接口路径&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_set_header Host &lt;span class="nv">$host&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_set_header X-Real-IP &lt;span class="nv">$remote_addr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_set_header X-Forwarded-For &lt;span class="nv">$proxy_add_x_forwarded_for&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最终实现效果如下：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/The-Oone/blogImg/202412082013591.png"
loading="lazy"
alt="image-20241208201301527"
>&lt;/p></description></item></channel></rss>